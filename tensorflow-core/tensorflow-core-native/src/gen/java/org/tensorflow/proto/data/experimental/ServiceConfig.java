// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/service_config.proto

package org.tensorflow.proto.data.experimental;

public final class ServiceConfig {
  private ServiceConfig() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface DispatcherConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.data.experimental.DispatcherConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The port for the dispatcher to bind to. A value of 0 indicates that the
     * dispatcher may bind to any available port.
     * </pre>
     *
     * <code>int64 port = 1;</code>
     * @return The port.
     */
    long getPort();

    /**
     * <pre>
     * The protocol for the dispatcher to use when connecting to workers.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The protocol.
     */
    java.lang.String getProtocol();
    /**
     * <pre>
     * The protocol for the dispatcher to use when connecting to workers.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The bytes for protocol.
     */
    com.google.protobuf.ByteString
        getProtocolBytes();

    /**
     * <pre>
     * A work directory to use for storing dispatcher state, and for recovering
     * during restarts. The empty string indicates not to use any work directory.
     * </pre>
     *
     * <code>string work_dir = 3;</code>
     * @return The workDir.
     */
    java.lang.String getWorkDir();
    /**
     * <pre>
     * A work directory to use for storing dispatcher state, and for recovering
     * during restarts. The empty string indicates not to use any work directory.
     * </pre>
     *
     * <code>string work_dir = 3;</code>
     * @return The bytes for workDir.
     */
    com.google.protobuf.ByteString
        getWorkDirBytes();

    /**
     * <pre>
     * Whether to run in fault tolerant mode, where dispatcher state is saved
     * across restarts. Requires that `work_dir` is nonempty.
     * </pre>
     *
     * <code>bool fault_tolerant_mode = 4;</code>
     * @return The faultTolerantMode.
     */
    boolean getFaultTolerantMode();

    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @return A list containing the workerAddresses.
     */
    java.util.List<java.lang.String>
        getWorkerAddressesList();
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @return The count of workerAddresses.
     */
    int getWorkerAddressesCount();
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @param index The index of the element to return.
     * @return The workerAddresses at the given index.
     */
    java.lang.String getWorkerAddresses(int index);
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the workerAddresses at the given index.
     */
    com.google.protobuf.ByteString
        getWorkerAddressesBytes(int index);

    /**
     * <pre>
     * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
     * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
     * </pre>
     *
     * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
     * @return The enum numeric value on the wire for deploymentMode.
     */
    int getDeploymentModeValue();
    /**
     * <pre>
     * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
     * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
     * </pre>
     *
     * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
     * @return The deploymentMode.
     */
    org.tensorflow.proto.data.DataService.DeploymentMode getDeploymentMode();

    /**
     * <pre>
     * How often the dispatcher should scan through to delete old and unused
     * jobs. A value of 0 indicates that the decision should be left up to the
     * runtime.
     * </pre>
     *
     * <code>int64 job_gc_check_interval_ms = 5;</code>
     * @return The jobGcCheckIntervalMs.
     */
    long getJobGcCheckIntervalMs();

    /**
     * <pre>
     * How long a job needs to be unused before it becomes a candidate for garbage
     * collection. A value of -1 indicates that jobs should never be garbage
     * collected. A value of 0 indicates that the decision should be left up to
     * the runtime. Note: This does not apply to dynamic sharding unless users
     * explicitly opt-in by enabling `gc_dynamic_sharding_jobs` below.
     * </pre>
     *
     * <code>int64 job_gc_timeout_ms = 6;</code>
     * @return The jobGcTimeoutMs.
     */
    long getJobGcTimeoutMs();

    /**
     * <pre>
     * Whether dynamically sharded jobs should be eligible for garbage collection.
     * These jobs are not garbage collected by default, since if a job is garbage
     * collected and then re-created, it will revisit all data from the start. If
     * revisiting data is acceptible and you want automatic reclamation of
     * iterator memory, set `gc_dynamic_sharding_jobs` to `true`.
     * </pre>
     *
     * <code>bool gc_dynamic_sharding_jobs = 11;</code>
     * @return The gcDynamicShardingJobs.
     */
    boolean getGcDynamicShardingJobs();

    /**
     * <pre>
     * How long to wait before garbage-collecting a client that hasn't
     * heartbeated to the dispatcher. A value of 0 indicates that the timeout
     * should be left to the runtime.
     * </pre>
     *
     * <code>int64 client_timeout_ms = 8;</code>
     * @return The clientTimeoutMs.
     */
    long getClientTimeoutMs();

    /**
     * <pre>
     * How long to wait for a worker to heartbeat before considering it missing.
     * A value of 0 indicates that the timeout should be left to the runtime.
     * </pre>
     *
     * <code>int64 worker_timeout_ms = 10;</code>
     * @return The workerTimeoutMs.
     */
    long getWorkerTimeoutMs();

    /**
     * <pre>
     * The maximum number of snapshots that a worker can concurrently process at a
     * given point in time. This is a tradeoff between worker resource usage and
     * snapshot wall time. A value of 0 indicates that the decision should be left
     * up to the runtime.
     * </pre>
     *
     * <code>int64 worker_max_concurrent_snapshots = 12;</code>
     * @return The workerMaxConcurrentSnapshots.
     */
    long getWorkerMaxConcurrentSnapshots();
  }
  /**
   * <pre>
   * Configuration for a tf.data service DispatchServer.
   * Next id: 13
   * </pre>
   *
   * Protobuf type {@code tensorflow.data.experimental.DispatcherConfig}
   */
  public static final class DispatcherConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.data.experimental.DispatcherConfig)
      DispatcherConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DispatcherConfig.newBuilder() to construct.
    private DispatcherConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DispatcherConfig() {
      protocol_ = "";
      workDir_ = "";
      workerAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      deploymentMode_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DispatcherConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_DispatcherConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.class, org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.Builder.class);
    }

    public static final int PORT_FIELD_NUMBER = 1;
    private long port_;
    /**
     * <pre>
     * The port for the dispatcher to bind to. A value of 0 indicates that the
     * dispatcher may bind to any available port.
     * </pre>
     *
     * <code>int64 port = 1;</code>
     * @return The port.
     */
    @java.lang.Override
    public long getPort() {
      return port_;
    }

    public static final int PROTOCOL_FIELD_NUMBER = 2;
    private volatile java.lang.Object protocol_;
    /**
     * <pre>
     * The protocol for the dispatcher to use when connecting to workers.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The protocol.
     */
    @java.lang.Override
    public java.lang.String getProtocol() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        protocol_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The protocol for the dispatcher to use when connecting to workers.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The bytes for protocol.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getProtocolBytes() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        protocol_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WORK_DIR_FIELD_NUMBER = 3;
    private volatile java.lang.Object workDir_;
    /**
     * <pre>
     * A work directory to use for storing dispatcher state, and for recovering
     * during restarts. The empty string indicates not to use any work directory.
     * </pre>
     *
     * <code>string work_dir = 3;</code>
     * @return The workDir.
     */
    @java.lang.Override
    public java.lang.String getWorkDir() {
      java.lang.Object ref = workDir_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        workDir_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A work directory to use for storing dispatcher state, and for recovering
     * during restarts. The empty string indicates not to use any work directory.
     * </pre>
     *
     * <code>string work_dir = 3;</code>
     * @return The bytes for workDir.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWorkDirBytes() {
      java.lang.Object ref = workDir_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        workDir_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FAULT_TOLERANT_MODE_FIELD_NUMBER = 4;
    private boolean faultTolerantMode_;
    /**
     * <pre>
     * Whether to run in fault tolerant mode, where dispatcher state is saved
     * across restarts. Requires that `work_dir` is nonempty.
     * </pre>
     *
     * <code>bool fault_tolerant_mode = 4;</code>
     * @return The faultTolerantMode.
     */
    @java.lang.Override
    public boolean getFaultTolerantMode() {
      return faultTolerantMode_;
    }

    public static final int WORKER_ADDRESSES_FIELD_NUMBER = 7;
    private com.google.protobuf.LazyStringList workerAddresses_;
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @return A list containing the workerAddresses.
     */
    public com.google.protobuf.ProtocolStringList
        getWorkerAddressesList() {
      return workerAddresses_;
    }
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @return The count of workerAddresses.
     */
    public int getWorkerAddressesCount() {
      return workerAddresses_.size();
    }
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @param index The index of the element to return.
     * @return The workerAddresses at the given index.
     */
    public java.lang.String getWorkerAddresses(int index) {
      return workerAddresses_.get(index);
    }
    /**
     * <pre>
     * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
     * of worker addresses that will register with the dispatcher. The worker
     * addresses should be in the format "host" or "host:port", where "port" is an
     * integer, named port, or %port% to match any port.
     * </pre>
     *
     * <code>repeated string worker_addresses = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the workerAddresses at the given index.
     */
    public com.google.protobuf.ByteString
        getWorkerAddressesBytes(int index) {
      return workerAddresses_.getByteString(index);
    }

    public static final int DEPLOYMENT_MODE_FIELD_NUMBER = 9;
    private int deploymentMode_;
    /**
     * <pre>
     * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
     * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
     * </pre>
     *
     * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
     * @return The enum numeric value on the wire for deploymentMode.
     */
    @java.lang.Override public int getDeploymentModeValue() {
      return deploymentMode_;
    }
    /**
     * <pre>
     * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
     * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
     * </pre>
     *
     * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
     * @return The deploymentMode.
     */
    @java.lang.Override public org.tensorflow.proto.data.DataService.DeploymentMode getDeploymentMode() {
      @SuppressWarnings("deprecation")
      org.tensorflow.proto.data.DataService.DeploymentMode result = org.tensorflow.proto.data.DataService.DeploymentMode.valueOf(deploymentMode_);
      return result == null ? org.tensorflow.proto.data.DataService.DeploymentMode.UNRECOGNIZED : result;
    }

    public static final int JOB_GC_CHECK_INTERVAL_MS_FIELD_NUMBER = 5;
    private long jobGcCheckIntervalMs_;
    /**
     * <pre>
     * How often the dispatcher should scan through to delete old and unused
     * jobs. A value of 0 indicates that the decision should be left up to the
     * runtime.
     * </pre>
     *
     * <code>int64 job_gc_check_interval_ms = 5;</code>
     * @return The jobGcCheckIntervalMs.
     */
    @java.lang.Override
    public long getJobGcCheckIntervalMs() {
      return jobGcCheckIntervalMs_;
    }

    public static final int JOB_GC_TIMEOUT_MS_FIELD_NUMBER = 6;
    private long jobGcTimeoutMs_;
    /**
     * <pre>
     * How long a job needs to be unused before it becomes a candidate for garbage
     * collection. A value of -1 indicates that jobs should never be garbage
     * collected. A value of 0 indicates that the decision should be left up to
     * the runtime. Note: This does not apply to dynamic sharding unless users
     * explicitly opt-in by enabling `gc_dynamic_sharding_jobs` below.
     * </pre>
     *
     * <code>int64 job_gc_timeout_ms = 6;</code>
     * @return The jobGcTimeoutMs.
     */
    @java.lang.Override
    public long getJobGcTimeoutMs() {
      return jobGcTimeoutMs_;
    }

    public static final int GC_DYNAMIC_SHARDING_JOBS_FIELD_NUMBER = 11;
    private boolean gcDynamicShardingJobs_;
    /**
     * <pre>
     * Whether dynamically sharded jobs should be eligible for garbage collection.
     * These jobs are not garbage collected by default, since if a job is garbage
     * collected and then re-created, it will revisit all data from the start. If
     * revisiting data is acceptible and you want automatic reclamation of
     * iterator memory, set `gc_dynamic_sharding_jobs` to `true`.
     * </pre>
     *
     * <code>bool gc_dynamic_sharding_jobs = 11;</code>
     * @return The gcDynamicShardingJobs.
     */
    @java.lang.Override
    public boolean getGcDynamicShardingJobs() {
      return gcDynamicShardingJobs_;
    }

    public static final int CLIENT_TIMEOUT_MS_FIELD_NUMBER = 8;
    private long clientTimeoutMs_;
    /**
     * <pre>
     * How long to wait before garbage-collecting a client that hasn't
     * heartbeated to the dispatcher. A value of 0 indicates that the timeout
     * should be left to the runtime.
     * </pre>
     *
     * <code>int64 client_timeout_ms = 8;</code>
     * @return The clientTimeoutMs.
     */
    @java.lang.Override
    public long getClientTimeoutMs() {
      return clientTimeoutMs_;
    }

    public static final int WORKER_TIMEOUT_MS_FIELD_NUMBER = 10;
    private long workerTimeoutMs_;
    /**
     * <pre>
     * How long to wait for a worker to heartbeat before considering it missing.
     * A value of 0 indicates that the timeout should be left to the runtime.
     * </pre>
     *
     * <code>int64 worker_timeout_ms = 10;</code>
     * @return The workerTimeoutMs.
     */
    @java.lang.Override
    public long getWorkerTimeoutMs() {
      return workerTimeoutMs_;
    }

    public static final int WORKER_MAX_CONCURRENT_SNAPSHOTS_FIELD_NUMBER = 12;
    private long workerMaxConcurrentSnapshots_;
    /**
     * <pre>
     * The maximum number of snapshots that a worker can concurrently process at a
     * given point in time. This is a tradeoff between worker resource usage and
     * snapshot wall time. A value of 0 indicates that the decision should be left
     * up to the runtime.
     * </pre>
     *
     * <code>int64 worker_max_concurrent_snapshots = 12;</code>
     * @return The workerMaxConcurrentSnapshots.
     */
    @java.lang.Override
    public long getWorkerMaxConcurrentSnapshots() {
      return workerMaxConcurrentSnapshots_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (port_ != 0L) {
        output.writeInt64(1, port_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(protocol_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, protocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(workDir_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, workDir_);
      }
      if (faultTolerantMode_ != false) {
        output.writeBool(4, faultTolerantMode_);
      }
      if (jobGcCheckIntervalMs_ != 0L) {
        output.writeInt64(5, jobGcCheckIntervalMs_);
      }
      if (jobGcTimeoutMs_ != 0L) {
        output.writeInt64(6, jobGcTimeoutMs_);
      }
      for (int i = 0; i < workerAddresses_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, workerAddresses_.getRaw(i));
      }
      if (clientTimeoutMs_ != 0L) {
        output.writeInt64(8, clientTimeoutMs_);
      }
      if (deploymentMode_ != org.tensorflow.proto.data.DataService.DeploymentMode.DEPLOYMENT_MODE_UNSPECIFIED.getNumber()) {
        output.writeEnum(9, deploymentMode_);
      }
      if (workerTimeoutMs_ != 0L) {
        output.writeInt64(10, workerTimeoutMs_);
      }
      if (gcDynamicShardingJobs_ != false) {
        output.writeBool(11, gcDynamicShardingJobs_);
      }
      if (workerMaxConcurrentSnapshots_ != 0L) {
        output.writeInt64(12, workerMaxConcurrentSnapshots_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (port_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, port_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(protocol_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, protocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(workDir_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, workDir_);
      }
      if (faultTolerantMode_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, faultTolerantMode_);
      }
      if (jobGcCheckIntervalMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, jobGcCheckIntervalMs_);
      }
      if (jobGcTimeoutMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, jobGcTimeoutMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < workerAddresses_.size(); i++) {
          dataSize += computeStringSizeNoTag(workerAddresses_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getWorkerAddressesList().size();
      }
      if (clientTimeoutMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(8, clientTimeoutMs_);
      }
      if (deploymentMode_ != org.tensorflow.proto.data.DataService.DeploymentMode.DEPLOYMENT_MODE_UNSPECIFIED.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(9, deploymentMode_);
      }
      if (workerTimeoutMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(10, workerTimeoutMs_);
      }
      if (gcDynamicShardingJobs_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, gcDynamicShardingJobs_);
      }
      if (workerMaxConcurrentSnapshots_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(12, workerMaxConcurrentSnapshots_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig)) {
        return super.equals(obj);
      }
      org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig other = (org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig) obj;

      if (getPort()
          != other.getPort()) return false;
      if (!getProtocol()
          .equals(other.getProtocol())) return false;
      if (!getWorkDir()
          .equals(other.getWorkDir())) return false;
      if (getFaultTolerantMode()
          != other.getFaultTolerantMode()) return false;
      if (!getWorkerAddressesList()
          .equals(other.getWorkerAddressesList())) return false;
      if (deploymentMode_ != other.deploymentMode_) return false;
      if (getJobGcCheckIntervalMs()
          != other.getJobGcCheckIntervalMs()) return false;
      if (getJobGcTimeoutMs()
          != other.getJobGcTimeoutMs()) return false;
      if (getGcDynamicShardingJobs()
          != other.getGcDynamicShardingJobs()) return false;
      if (getClientTimeoutMs()
          != other.getClientTimeoutMs()) return false;
      if (getWorkerTimeoutMs()
          != other.getWorkerTimeoutMs()) return false;
      if (getWorkerMaxConcurrentSnapshots()
          != other.getWorkerMaxConcurrentSnapshots()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PORT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPort());
      hash = (37 * hash) + PROTOCOL_FIELD_NUMBER;
      hash = (53 * hash) + getProtocol().hashCode();
      hash = (37 * hash) + WORK_DIR_FIELD_NUMBER;
      hash = (53 * hash) + getWorkDir().hashCode();
      hash = (37 * hash) + FAULT_TOLERANT_MODE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getFaultTolerantMode());
      if (getWorkerAddressesCount() > 0) {
        hash = (37 * hash) + WORKER_ADDRESSES_FIELD_NUMBER;
        hash = (53 * hash) + getWorkerAddressesList().hashCode();
      }
      hash = (37 * hash) + DEPLOYMENT_MODE_FIELD_NUMBER;
      hash = (53 * hash) + deploymentMode_;
      hash = (37 * hash) + JOB_GC_CHECK_INTERVAL_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getJobGcCheckIntervalMs());
      hash = (37 * hash) + JOB_GC_TIMEOUT_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getJobGcTimeoutMs());
      hash = (37 * hash) + GC_DYNAMIC_SHARDING_JOBS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getGcDynamicShardingJobs());
      hash = (37 * hash) + CLIENT_TIMEOUT_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getClientTimeoutMs());
      hash = (37 * hash) + WORKER_TIMEOUT_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getWorkerTimeoutMs());
      hash = (37 * hash) + WORKER_MAX_CONCURRENT_SNAPSHOTS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getWorkerMaxConcurrentSnapshots());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for a tf.data service DispatchServer.
     * Next id: 13
     * </pre>
     *
     * Protobuf type {@code tensorflow.data.experimental.DispatcherConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.data.experimental.DispatcherConfig)
        org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_DispatcherConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.class, org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.Builder.class);
      }

      // Construct using org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        port_ = 0L;

        protocol_ = "";

        workDir_ = "";

        faultTolerantMode_ = false;

        workerAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        deploymentMode_ = 0;

        jobGcCheckIntervalMs_ = 0L;

        jobGcTimeoutMs_ = 0L;

        gcDynamicShardingJobs_ = false;

        clientTimeoutMs_ = 0L;

        workerTimeoutMs_ = 0L;

        workerMaxConcurrentSnapshots_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor;
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig getDefaultInstanceForType() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.getDefaultInstance();
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig build() {
        org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig buildPartial() {
        org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig result = new org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig(this);
        int from_bitField0_ = bitField0_;
        result.port_ = port_;
        result.protocol_ = protocol_;
        result.workDir_ = workDir_;
        result.faultTolerantMode_ = faultTolerantMode_;
        if (((bitField0_ & 0x00000001) != 0)) {
          workerAddresses_ = workerAddresses_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.workerAddresses_ = workerAddresses_;
        result.deploymentMode_ = deploymentMode_;
        result.jobGcCheckIntervalMs_ = jobGcCheckIntervalMs_;
        result.jobGcTimeoutMs_ = jobGcTimeoutMs_;
        result.gcDynamicShardingJobs_ = gcDynamicShardingJobs_;
        result.clientTimeoutMs_ = clientTimeoutMs_;
        result.workerTimeoutMs_ = workerTimeoutMs_;
        result.workerMaxConcurrentSnapshots_ = workerMaxConcurrentSnapshots_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig) {
          return mergeFrom((org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig other) {
        if (other == org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig.getDefaultInstance()) return this;
        if (other.getPort() != 0L) {
          setPort(other.getPort());
        }
        if (!other.getProtocol().isEmpty()) {
          protocol_ = other.protocol_;
          onChanged();
        }
        if (!other.getWorkDir().isEmpty()) {
          workDir_ = other.workDir_;
          onChanged();
        }
        if (other.getFaultTolerantMode() != false) {
          setFaultTolerantMode(other.getFaultTolerantMode());
        }
        if (!other.workerAddresses_.isEmpty()) {
          if (workerAddresses_.isEmpty()) {
            workerAddresses_ = other.workerAddresses_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureWorkerAddressesIsMutable();
            workerAddresses_.addAll(other.workerAddresses_);
          }
          onChanged();
        }
        if (other.deploymentMode_ != 0) {
          setDeploymentModeValue(other.getDeploymentModeValue());
        }
        if (other.getJobGcCheckIntervalMs() != 0L) {
          setJobGcCheckIntervalMs(other.getJobGcCheckIntervalMs());
        }
        if (other.getJobGcTimeoutMs() != 0L) {
          setJobGcTimeoutMs(other.getJobGcTimeoutMs());
        }
        if (other.getGcDynamicShardingJobs() != false) {
          setGcDynamicShardingJobs(other.getGcDynamicShardingJobs());
        }
        if (other.getClientTimeoutMs() != 0L) {
          setClientTimeoutMs(other.getClientTimeoutMs());
        }
        if (other.getWorkerTimeoutMs() != 0L) {
          setWorkerTimeoutMs(other.getWorkerTimeoutMs());
        }
        if (other.getWorkerMaxConcurrentSnapshots() != 0L) {
          setWorkerMaxConcurrentSnapshots(other.getWorkerMaxConcurrentSnapshots());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                port_ = input.readInt64();

                break;
              } // case 8
              case 18: {
                protocol_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                workDir_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 32: {
                faultTolerantMode_ = input.readBool();

                break;
              } // case 32
              case 40: {
                jobGcCheckIntervalMs_ = input.readInt64();

                break;
              } // case 40
              case 48: {
                jobGcTimeoutMs_ = input.readInt64();

                break;
              } // case 48
              case 58: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureWorkerAddressesIsMutable();
                workerAddresses_.add(s);
                break;
              } // case 58
              case 64: {
                clientTimeoutMs_ = input.readInt64();

                break;
              } // case 64
              case 72: {
                deploymentMode_ = input.readEnum();

                break;
              } // case 72
              case 80: {
                workerTimeoutMs_ = input.readInt64();

                break;
              } // case 80
              case 88: {
                gcDynamicShardingJobs_ = input.readBool();

                break;
              } // case 88
              case 96: {
                workerMaxConcurrentSnapshots_ = input.readInt64();

                break;
              } // case 96
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long port_ ;
      /**
       * <pre>
       * The port for the dispatcher to bind to. A value of 0 indicates that the
       * dispatcher may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @return The port.
       */
      @java.lang.Override
      public long getPort() {
        return port_;
      }
      /**
       * <pre>
       * The port for the dispatcher to bind to. A value of 0 indicates that the
       * dispatcher may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @param value The port to set.
       * @return This builder for chaining.
       */
      public Builder setPort(long value) {
        
        port_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The port for the dispatcher to bind to. A value of 0 indicates that the
       * dispatcher may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPort() {
        
        port_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object protocol_ = "";
      /**
       * <pre>
       * The protocol for the dispatcher to use when connecting to workers.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return The protocol.
       */
      public java.lang.String getProtocol() {
        java.lang.Object ref = protocol_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          protocol_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The protocol for the dispatcher to use when connecting to workers.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return The bytes for protocol.
       */
      public com.google.protobuf.ByteString
          getProtocolBytes() {
        java.lang.Object ref = protocol_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          protocol_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The protocol for the dispatcher to use when connecting to workers.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @param value The protocol to set.
       * @return This builder for chaining.
       */
      public Builder setProtocol(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        protocol_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The protocol for the dispatcher to use when connecting to workers.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearProtocol() {
        
        protocol_ = getDefaultInstance().getProtocol();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The protocol for the dispatcher to use when connecting to workers.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @param value The bytes for protocol to set.
       * @return This builder for chaining.
       */
      public Builder setProtocolBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        protocol_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object workDir_ = "";
      /**
       * <pre>
       * A work directory to use for storing dispatcher state, and for recovering
       * during restarts. The empty string indicates not to use any work directory.
       * </pre>
       *
       * <code>string work_dir = 3;</code>
       * @return The workDir.
       */
      public java.lang.String getWorkDir() {
        java.lang.Object ref = workDir_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          workDir_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A work directory to use for storing dispatcher state, and for recovering
       * during restarts. The empty string indicates not to use any work directory.
       * </pre>
       *
       * <code>string work_dir = 3;</code>
       * @return The bytes for workDir.
       */
      public com.google.protobuf.ByteString
          getWorkDirBytes() {
        java.lang.Object ref = workDir_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          workDir_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A work directory to use for storing dispatcher state, and for recovering
       * during restarts. The empty string indicates not to use any work directory.
       * </pre>
       *
       * <code>string work_dir = 3;</code>
       * @param value The workDir to set.
       * @return This builder for chaining.
       */
      public Builder setWorkDir(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        workDir_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A work directory to use for storing dispatcher state, and for recovering
       * during restarts. The empty string indicates not to use any work directory.
       * </pre>
       *
       * <code>string work_dir = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkDir() {
        
        workDir_ = getDefaultInstance().getWorkDir();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A work directory to use for storing dispatcher state, and for recovering
       * during restarts. The empty string indicates not to use any work directory.
       * </pre>
       *
       * <code>string work_dir = 3;</code>
       * @param value The bytes for workDir to set.
       * @return This builder for chaining.
       */
      public Builder setWorkDirBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        workDir_ = value;
        onChanged();
        return this;
      }

      private boolean faultTolerantMode_ ;
      /**
       * <pre>
       * Whether to run in fault tolerant mode, where dispatcher state is saved
       * across restarts. Requires that `work_dir` is nonempty.
       * </pre>
       *
       * <code>bool fault_tolerant_mode = 4;</code>
       * @return The faultTolerantMode.
       */
      @java.lang.Override
      public boolean getFaultTolerantMode() {
        return faultTolerantMode_;
      }
      /**
       * <pre>
       * Whether to run in fault tolerant mode, where dispatcher state is saved
       * across restarts. Requires that `work_dir` is nonempty.
       * </pre>
       *
       * <code>bool fault_tolerant_mode = 4;</code>
       * @param value The faultTolerantMode to set.
       * @return This builder for chaining.
       */
      public Builder setFaultTolerantMode(boolean value) {
        
        faultTolerantMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether to run in fault tolerant mode, where dispatcher state is saved
       * across restarts. Requires that `work_dir` is nonempty.
       * </pre>
       *
       * <code>bool fault_tolerant_mode = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearFaultTolerantMode() {
        
        faultTolerantMode_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList workerAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureWorkerAddressesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          workerAddresses_ = new com.google.protobuf.LazyStringArrayList(workerAddresses_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @return A list containing the workerAddresses.
       */
      public com.google.protobuf.ProtocolStringList
          getWorkerAddressesList() {
        return workerAddresses_.getUnmodifiableView();
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @return The count of workerAddresses.
       */
      public int getWorkerAddressesCount() {
        return workerAddresses_.size();
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param index The index of the element to return.
       * @return The workerAddresses at the given index.
       */
      public java.lang.String getWorkerAddresses(int index) {
        return workerAddresses_.get(index);
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param index The index of the value to return.
       * @return The bytes of the workerAddresses at the given index.
       */
      public com.google.protobuf.ByteString
          getWorkerAddressesBytes(int index) {
        return workerAddresses_.getByteString(index);
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param index The index to set the value at.
       * @param value The workerAddresses to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerAddresses(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureWorkerAddressesIsMutable();
        workerAddresses_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param value The workerAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addWorkerAddresses(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureWorkerAddressesIsMutable();
        workerAddresses_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param values The workerAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addAllWorkerAddresses(
          java.lang.Iterable<java.lang.String> values) {
        ensureWorkerAddressesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, workerAddresses_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkerAddresses() {
        workerAddresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) If the job uses auto-sharding, it needs to specify a fixed list
       * of worker addresses that will register with the dispatcher. The worker
       * addresses should be in the format "host" or "host:port", where "port" is an
       * integer, named port, or %port% to match any port.
       * </pre>
       *
       * <code>repeated string worker_addresses = 7;</code>
       * @param value The bytes of the workerAddresses to add.
       * @return This builder for chaining.
       */
      public Builder addWorkerAddressesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureWorkerAddressesIsMutable();
        workerAddresses_.add(value);
        onChanged();
        return this;
      }

      private int deploymentMode_ = 0;
      /**
       * <pre>
       * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
       * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
       * </pre>
       *
       * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
       * @return The enum numeric value on the wire for deploymentMode.
       */
      @java.lang.Override public int getDeploymentModeValue() {
        return deploymentMode_;
      }
      /**
       * <pre>
       * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
       * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
       * </pre>
       *
       * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
       * @param value The enum numeric value on the wire for deploymentMode to set.
       * @return This builder for chaining.
       */
      public Builder setDeploymentModeValue(int value) {
        
        deploymentMode_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
       * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
       * </pre>
       *
       * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
       * @return The deploymentMode.
       */
      @java.lang.Override
      public org.tensorflow.proto.data.DataService.DeploymentMode getDeploymentMode() {
        @SuppressWarnings("deprecation")
        org.tensorflow.proto.data.DataService.DeploymentMode result = org.tensorflow.proto.data.DataService.DeploymentMode.valueOf(deploymentMode_);
        return result == null ? org.tensorflow.proto.data.DataService.DeploymentMode.UNRECOGNIZED : result;
      }
      /**
       * <pre>
       * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
       * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
       * </pre>
       *
       * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
       * @param value The deploymentMode to set.
       * @return This builder for chaining.
       */
      public Builder setDeploymentMode(org.tensorflow.proto.data.DataService.DeploymentMode value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        deploymentMode_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * (Optional.) tf.data service deployment mode. Supported values are "REMOTE",
       * "COLOCATED", and "HYBRID". If unspecified, it is assumed to be "REMOTE".
       * </pre>
       *
       * <code>.tensorflow.data.DeploymentMode deployment_mode = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearDeploymentMode() {
        
        deploymentMode_ = 0;
        onChanged();
        return this;
      }

      private long jobGcCheckIntervalMs_ ;
      /**
       * <pre>
       * How often the dispatcher should scan through to delete old and unused
       * jobs. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 job_gc_check_interval_ms = 5;</code>
       * @return The jobGcCheckIntervalMs.
       */
      @java.lang.Override
      public long getJobGcCheckIntervalMs() {
        return jobGcCheckIntervalMs_;
      }
      /**
       * <pre>
       * How often the dispatcher should scan through to delete old and unused
       * jobs. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 job_gc_check_interval_ms = 5;</code>
       * @param value The jobGcCheckIntervalMs to set.
       * @return This builder for chaining.
       */
      public Builder setJobGcCheckIntervalMs(long value) {
        
        jobGcCheckIntervalMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How often the dispatcher should scan through to delete old and unused
       * jobs. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 job_gc_check_interval_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearJobGcCheckIntervalMs() {
        
        jobGcCheckIntervalMs_ = 0L;
        onChanged();
        return this;
      }

      private long jobGcTimeoutMs_ ;
      /**
       * <pre>
       * How long a job needs to be unused before it becomes a candidate for garbage
       * collection. A value of -1 indicates that jobs should never be garbage
       * collected. A value of 0 indicates that the decision should be left up to
       * the runtime. Note: This does not apply to dynamic sharding unless users
       * explicitly opt-in by enabling `gc_dynamic_sharding_jobs` below.
       * </pre>
       *
       * <code>int64 job_gc_timeout_ms = 6;</code>
       * @return The jobGcTimeoutMs.
       */
      @java.lang.Override
      public long getJobGcTimeoutMs() {
        return jobGcTimeoutMs_;
      }
      /**
       * <pre>
       * How long a job needs to be unused before it becomes a candidate for garbage
       * collection. A value of -1 indicates that jobs should never be garbage
       * collected. A value of 0 indicates that the decision should be left up to
       * the runtime. Note: This does not apply to dynamic sharding unless users
       * explicitly opt-in by enabling `gc_dynamic_sharding_jobs` below.
       * </pre>
       *
       * <code>int64 job_gc_timeout_ms = 6;</code>
       * @param value The jobGcTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setJobGcTimeoutMs(long value) {
        
        jobGcTimeoutMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How long a job needs to be unused before it becomes a candidate for garbage
       * collection. A value of -1 indicates that jobs should never be garbage
       * collected. A value of 0 indicates that the decision should be left up to
       * the runtime. Note: This does not apply to dynamic sharding unless users
       * explicitly opt-in by enabling `gc_dynamic_sharding_jobs` below.
       * </pre>
       *
       * <code>int64 job_gc_timeout_ms = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearJobGcTimeoutMs() {
        
        jobGcTimeoutMs_ = 0L;
        onChanged();
        return this;
      }

      private boolean gcDynamicShardingJobs_ ;
      /**
       * <pre>
       * Whether dynamically sharded jobs should be eligible for garbage collection.
       * These jobs are not garbage collected by default, since if a job is garbage
       * collected and then re-created, it will revisit all data from the start. If
       * revisiting data is acceptible and you want automatic reclamation of
       * iterator memory, set `gc_dynamic_sharding_jobs` to `true`.
       * </pre>
       *
       * <code>bool gc_dynamic_sharding_jobs = 11;</code>
       * @return The gcDynamicShardingJobs.
       */
      @java.lang.Override
      public boolean getGcDynamicShardingJobs() {
        return gcDynamicShardingJobs_;
      }
      /**
       * <pre>
       * Whether dynamically sharded jobs should be eligible for garbage collection.
       * These jobs are not garbage collected by default, since if a job is garbage
       * collected and then re-created, it will revisit all data from the start. If
       * revisiting data is acceptible and you want automatic reclamation of
       * iterator memory, set `gc_dynamic_sharding_jobs` to `true`.
       * </pre>
       *
       * <code>bool gc_dynamic_sharding_jobs = 11;</code>
       * @param value The gcDynamicShardingJobs to set.
       * @return This builder for chaining.
       */
      public Builder setGcDynamicShardingJobs(boolean value) {
        
        gcDynamicShardingJobs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Whether dynamically sharded jobs should be eligible for garbage collection.
       * These jobs are not garbage collected by default, since if a job is garbage
       * collected and then re-created, it will revisit all data from the start. If
       * revisiting data is acceptible and you want automatic reclamation of
       * iterator memory, set `gc_dynamic_sharding_jobs` to `true`.
       * </pre>
       *
       * <code>bool gc_dynamic_sharding_jobs = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearGcDynamicShardingJobs() {
        
        gcDynamicShardingJobs_ = false;
        onChanged();
        return this;
      }

      private long clientTimeoutMs_ ;
      /**
       * <pre>
       * How long to wait before garbage-collecting a client that hasn't
       * heartbeated to the dispatcher. A value of 0 indicates that the timeout
       * should be left to the runtime.
       * </pre>
       *
       * <code>int64 client_timeout_ms = 8;</code>
       * @return The clientTimeoutMs.
       */
      @java.lang.Override
      public long getClientTimeoutMs() {
        return clientTimeoutMs_;
      }
      /**
       * <pre>
       * How long to wait before garbage-collecting a client that hasn't
       * heartbeated to the dispatcher. A value of 0 indicates that the timeout
       * should be left to the runtime.
       * </pre>
       *
       * <code>int64 client_timeout_ms = 8;</code>
       * @param value The clientTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setClientTimeoutMs(long value) {
        
        clientTimeoutMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How long to wait before garbage-collecting a client that hasn't
       * heartbeated to the dispatcher. A value of 0 indicates that the timeout
       * should be left to the runtime.
       * </pre>
       *
       * <code>int64 client_timeout_ms = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearClientTimeoutMs() {
        
        clientTimeoutMs_ = 0L;
        onChanged();
        return this;
      }

      private long workerTimeoutMs_ ;
      /**
       * <pre>
       * How long to wait for a worker to heartbeat before considering it missing.
       * A value of 0 indicates that the timeout should be left to the runtime.
       * </pre>
       *
       * <code>int64 worker_timeout_ms = 10;</code>
       * @return The workerTimeoutMs.
       */
      @java.lang.Override
      public long getWorkerTimeoutMs() {
        return workerTimeoutMs_;
      }
      /**
       * <pre>
       * How long to wait for a worker to heartbeat before considering it missing.
       * A value of 0 indicates that the timeout should be left to the runtime.
       * </pre>
       *
       * <code>int64 worker_timeout_ms = 10;</code>
       * @param value The workerTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerTimeoutMs(long value) {
        
        workerTimeoutMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How long to wait for a worker to heartbeat before considering it missing.
       * A value of 0 indicates that the timeout should be left to the runtime.
       * </pre>
       *
       * <code>int64 worker_timeout_ms = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkerTimeoutMs() {
        
        workerTimeoutMs_ = 0L;
        onChanged();
        return this;
      }

      private long workerMaxConcurrentSnapshots_ ;
      /**
       * <pre>
       * The maximum number of snapshots that a worker can concurrently process at a
       * given point in time. This is a tradeoff between worker resource usage and
       * snapshot wall time. A value of 0 indicates that the decision should be left
       * up to the runtime.
       * </pre>
       *
       * <code>int64 worker_max_concurrent_snapshots = 12;</code>
       * @return The workerMaxConcurrentSnapshots.
       */
      @java.lang.Override
      public long getWorkerMaxConcurrentSnapshots() {
        return workerMaxConcurrentSnapshots_;
      }
      /**
       * <pre>
       * The maximum number of snapshots that a worker can concurrently process at a
       * given point in time. This is a tradeoff between worker resource usage and
       * snapshot wall time. A value of 0 indicates that the decision should be left
       * up to the runtime.
       * </pre>
       *
       * <code>int64 worker_max_concurrent_snapshots = 12;</code>
       * @param value The workerMaxConcurrentSnapshots to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerMaxConcurrentSnapshots(long value) {
        
        workerMaxConcurrentSnapshots_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum number of snapshots that a worker can concurrently process at a
       * given point in time. This is a tradeoff between worker resource usage and
       * snapshot wall time. A value of 0 indicates that the decision should be left
       * up to the runtime.
       * </pre>
       *
       * <code>int64 worker_max_concurrent_snapshots = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkerMaxConcurrentSnapshots() {
        
        workerMaxConcurrentSnapshots_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.data.experimental.DispatcherConfig)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.data.experimental.DispatcherConfig)
    private static final org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig();
    }

    public static org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DispatcherConfig>
        PARSER = new com.google.protobuf.AbstractParser<DispatcherConfig>() {
      @java.lang.Override
      public DispatcherConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DispatcherConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DispatcherConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.tensorflow.proto.data.experimental.ServiceConfig.DispatcherConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface WorkerConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:tensorflow.data.experimental.WorkerConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The port for the worker to bind to. A value of 0 indicates that the
     * worker may bind to any available port.
     * </pre>
     *
     * <code>int64 port = 1;</code>
     * @return The port.
     */
    long getPort();

    /**
     * <pre>
     * The protocol for the worker to use when connecting to the dispatcher.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The protocol.
     */
    java.lang.String getProtocol();
    /**
     * <pre>
     * The protocol for the worker to use when connecting to the dispatcher.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The bytes for protocol.
     */
    com.google.protobuf.ByteString
        getProtocolBytes();

    /**
     * <pre>
     * The address of the dispatcher to register with.
     * </pre>
     *
     * <code>string dispatcher_address = 3;</code>
     * @return The dispatcherAddress.
     */
    java.lang.String getDispatcherAddress();
    /**
     * <pre>
     * The address of the dispatcher to register with.
     * </pre>
     *
     * <code>string dispatcher_address = 3;</code>
     * @return The bytes for dispatcherAddress.
     */
    com.google.protobuf.ByteString
        getDispatcherAddressBytes();

    /**
     * <pre>
     * The address of the worker server. The substring "%port%", if specified,
     * will be replaced with the worker's bound port. This is useful when the port
     * is set to `0`.
     * </pre>
     *
     * <code>string worker_address = 4;</code>
     * @return The workerAddress.
     */
    java.lang.String getWorkerAddress();
    /**
     * <pre>
     * The address of the worker server. The substring "%port%", if specified,
     * will be replaced with the worker's bound port. This is useful when the port
     * is set to `0`.
     * </pre>
     *
     * <code>string worker_address = 4;</code>
     * @return The bytes for workerAddress.
     */
    com.google.protobuf.ByteString
        getWorkerAddressBytes();

    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @return A list containing the workerTags.
     */
    java.util.List<java.lang.String>
        getWorkerTagsList();
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @return The count of workerTags.
     */
    int getWorkerTagsCount();
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @param index The index of the element to return.
     * @return The workerTags at the given index.
     */
    java.lang.String getWorkerTags(int index);
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @param index The index of the value to return.
     * @return The bytes of the workerTags at the given index.
     */
    com.google.protobuf.ByteString
        getWorkerTagsBytes(int index);

    /**
     * <pre>
     * How often the worker should heartbeat to the master. A value of 0 indicates
     * that the decision should be left up to the runtime.
     * </pre>
     *
     * <code>int64 heartbeat_interval_ms = 5;</code>
     * @return The heartbeatIntervalMs.
     */
    long getHeartbeatIntervalMs();

    /**
     * <pre>
     * How long to retry requests to the dispatcher before giving up and reporting
     * an error. A value of 0 indicates that the decision should be left up to the
     * runtime.
     * </pre>
     *
     * <code>int64 dispatcher_timeout_ms = 6;</code>
     * @return The dispatcherTimeoutMs.
     */
    long getDispatcherTimeoutMs();

    /**
     * <pre>
     * If set, the name of an alternative data transfer protocol for which the
     * worker starts an additional server ("data transfer server"); the trainer
     * can then get data from this server. If not set, no such server is started,
     * and the trainer can only get data from the regular worker server over
     * `protocol`.
     * </pre>
     *
     * <code>string data_transfer_protocol = 7;</code>
     * @return The dataTransferProtocol.
     */
    java.lang.String getDataTransferProtocol();
    /**
     * <pre>
     * If set, the name of an alternative data transfer protocol for which the
     * worker starts an additional server ("data transfer server"); the trainer
     * can then get data from this server. If not set, no such server is started,
     * and the trainer can only get data from the regular worker server over
     * `protocol`.
     * </pre>
     *
     * <code>string data_transfer_protocol = 7;</code>
     * @return The bytes for dataTransferProtocol.
     */
    com.google.protobuf.ByteString
        getDataTransferProtocolBytes();

    /**
     * <pre>
     * If `data_transfer_protocol` is set, the port to which the data transfer
     * server binds. If set to `0`, the server binds to any available port.
     * </pre>
     *
     * <code>int64 data_transfer_port = 13;</code>
     * @return The dataTransferPort.
     */
    long getDataTransferPort();

    /**
     * <pre>
     * If `data_transfer_protocol` is set, the address of the data transfer
     * server. The substring "%dts_port%" can be used to represent -- and is
     * replaced with -- the bound port of the data transfer server; this is useful
     * when `data_transfer_port` is set to `0`.
     * </pre>
     *
     * <code>string data_transfer_address = 8;</code>
     * @return The dataTransferAddress.
     */
    java.lang.String getDataTransferAddress();
    /**
     * <pre>
     * If `data_transfer_protocol` is set, the address of the data transfer
     * server. The substring "%dts_port%" can be used to represent -- and is
     * replaced with -- the bound port of the data transfer server; this is useful
     * when `data_transfer_port` is set to `0`.
     * </pre>
     *
     * <code>string data_transfer_address = 8;</code>
     * @return The bytes for dataTransferAddress.
     */
    com.google.protobuf.ByteString
        getDataTransferAddressBytes();

    /**
     * <pre>
     * Maximum size of the cross-trainer cache in bytes. If enabled, make sure
     * your training job provides sufficient memory resources.
     * </pre>
     *
     * <code>int64 cross_trainer_cache_size_bytes = 11;</code>
     * @return The crossTrainerCacheSizeBytes.
     */
    long getCrossTrainerCacheSizeBytes();

    /**
     * <pre>
     * The maximum size of a distributed snapshot chunk file. A value of 0
     * indicates that the decision should be left up to the runtime.
     * </pre>
     *
     * <code>int64 snapshot_max_chunk_size_bytes = 12;</code>
     * @return The snapshotMaxChunkSizeBytes.
     */
    long getSnapshotMaxChunkSizeBytes();

    /**
     * <pre>
     * When shutting down a worker, how long to wait for the gRPC server to
     * process the final requests. This is used to achieve clean shutdown in unit
     * tests.
     * </pre>
     *
     * <code>int64 shutdown_quiet_period_ms = 9;</code>
     * @return The shutdownQuietPeriodMs.
     */
    long getShutdownQuietPeriodMs();
  }
  /**
   * <pre>
   * Configuration for a tf.data service WorkerServer.
   * Next id: 14
   * </pre>
   *
   * Protobuf type {@code tensorflow.data.experimental.WorkerConfig}
   */
  public static final class WorkerConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:tensorflow.data.experimental.WorkerConfig)
      WorkerConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use WorkerConfig.newBuilder() to construct.
    private WorkerConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private WorkerConfig() {
      protocol_ = "";
      dispatcherAddress_ = "";
      workerAddress_ = "";
      workerTags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      dataTransferProtocol_ = "";
      dataTransferAddress_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new WorkerConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_WorkerConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_WorkerConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.class, org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.Builder.class);
    }

    public static final int PORT_FIELD_NUMBER = 1;
    private long port_;
    /**
     * <pre>
     * The port for the worker to bind to. A value of 0 indicates that the
     * worker may bind to any available port.
     * </pre>
     *
     * <code>int64 port = 1;</code>
     * @return The port.
     */
    @java.lang.Override
    public long getPort() {
      return port_;
    }

    public static final int PROTOCOL_FIELD_NUMBER = 2;
    private volatile java.lang.Object protocol_;
    /**
     * <pre>
     * The protocol for the worker to use when connecting to the dispatcher.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The protocol.
     */
    @java.lang.Override
    public java.lang.String getProtocol() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        protocol_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The protocol for the worker to use when connecting to the dispatcher.
     * </pre>
     *
     * <code>string protocol = 2;</code>
     * @return The bytes for protocol.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getProtocolBytes() {
      java.lang.Object ref = protocol_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        protocol_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DISPATCHER_ADDRESS_FIELD_NUMBER = 3;
    private volatile java.lang.Object dispatcherAddress_;
    /**
     * <pre>
     * The address of the dispatcher to register with.
     * </pre>
     *
     * <code>string dispatcher_address = 3;</code>
     * @return The dispatcherAddress.
     */
    @java.lang.Override
    public java.lang.String getDispatcherAddress() {
      java.lang.Object ref = dispatcherAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        dispatcherAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The address of the dispatcher to register with.
     * </pre>
     *
     * <code>string dispatcher_address = 3;</code>
     * @return The bytes for dispatcherAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDispatcherAddressBytes() {
      java.lang.Object ref = dispatcherAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        dispatcherAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WORKER_ADDRESS_FIELD_NUMBER = 4;
    private volatile java.lang.Object workerAddress_;
    /**
     * <pre>
     * The address of the worker server. The substring "%port%", if specified,
     * will be replaced with the worker's bound port. This is useful when the port
     * is set to `0`.
     * </pre>
     *
     * <code>string worker_address = 4;</code>
     * @return The workerAddress.
     */
    @java.lang.Override
    public java.lang.String getWorkerAddress() {
      java.lang.Object ref = workerAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        workerAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The address of the worker server. The substring "%port%", if specified,
     * will be replaced with the worker's bound port. This is useful when the port
     * is set to `0`.
     * </pre>
     *
     * <code>string worker_address = 4;</code>
     * @return The bytes for workerAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getWorkerAddressBytes() {
      java.lang.Object ref = workerAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        workerAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int WORKER_TAGS_FIELD_NUMBER = 10;
    private com.google.protobuf.LazyStringList workerTags_;
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @return A list containing the workerTags.
     */
    public com.google.protobuf.ProtocolStringList
        getWorkerTagsList() {
      return workerTags_;
    }
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @return The count of workerTags.
     */
    public int getWorkerTagsCount() {
      return workerTags_.size();
    }
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @param index The index of the element to return.
     * @return The workerTags at the given index.
     */
    public java.lang.String getWorkerTags(int index) {
      return workerTags_.get(index);
    }
    /**
     * <pre>
     * Tags attached to the worker. This allows reading from selected workers.
     * For example, by applying a "COLOCATED" tag, tf.data service is able to read
     * from the local tf.data worker if one exists, then from off-TF-host workers,
     * to avoid cross-TF-host reads.
     * </pre>
     *
     * <code>repeated string worker_tags = 10;</code>
     * @param index The index of the value to return.
     * @return The bytes of the workerTags at the given index.
     */
    public com.google.protobuf.ByteString
        getWorkerTagsBytes(int index) {
      return workerTags_.getByteString(index);
    }

    public static final int HEARTBEAT_INTERVAL_MS_FIELD_NUMBER = 5;
    private long heartbeatIntervalMs_;
    /**
     * <pre>
     * How often the worker should heartbeat to the master. A value of 0 indicates
     * that the decision should be left up to the runtime.
     * </pre>
     *
     * <code>int64 heartbeat_interval_ms = 5;</code>
     * @return The heartbeatIntervalMs.
     */
    @java.lang.Override
    public long getHeartbeatIntervalMs() {
      return heartbeatIntervalMs_;
    }

    public static final int DISPATCHER_TIMEOUT_MS_FIELD_NUMBER = 6;
    private long dispatcherTimeoutMs_;
    /**
     * <pre>
     * How long to retry requests to the dispatcher before giving up and reporting
     * an error. A value of 0 indicates that the decision should be left up to the
     * runtime.
     * </pre>
     *
     * <code>int64 dispatcher_timeout_ms = 6;</code>
     * @return The dispatcherTimeoutMs.
     */
    @java.lang.Override
    public long getDispatcherTimeoutMs() {
      return dispatcherTimeoutMs_;
    }

    public static final int DATA_TRANSFER_PROTOCOL_FIELD_NUMBER = 7;
    private volatile java.lang.Object dataTransferProtocol_;
    /**
     * <pre>
     * If set, the name of an alternative data transfer protocol for which the
     * worker starts an additional server ("data transfer server"); the trainer
     * can then get data from this server. If not set, no such server is started,
     * and the trainer can only get data from the regular worker server over
     * `protocol`.
     * </pre>
     *
     * <code>string data_transfer_protocol = 7;</code>
     * @return The dataTransferProtocol.
     */
    @java.lang.Override
    public java.lang.String getDataTransferProtocol() {
      java.lang.Object ref = dataTransferProtocol_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        dataTransferProtocol_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If set, the name of an alternative data transfer protocol for which the
     * worker starts an additional server ("data transfer server"); the trainer
     * can then get data from this server. If not set, no such server is started,
     * and the trainer can only get data from the regular worker server over
     * `protocol`.
     * </pre>
     *
     * <code>string data_transfer_protocol = 7;</code>
     * @return The bytes for dataTransferProtocol.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDataTransferProtocolBytes() {
      java.lang.Object ref = dataTransferProtocol_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        dataTransferProtocol_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int DATA_TRANSFER_PORT_FIELD_NUMBER = 13;
    private long dataTransferPort_;
    /**
     * <pre>
     * If `data_transfer_protocol` is set, the port to which the data transfer
     * server binds. If set to `0`, the server binds to any available port.
     * </pre>
     *
     * <code>int64 data_transfer_port = 13;</code>
     * @return The dataTransferPort.
     */
    @java.lang.Override
    public long getDataTransferPort() {
      return dataTransferPort_;
    }

    public static final int DATA_TRANSFER_ADDRESS_FIELD_NUMBER = 8;
    private volatile java.lang.Object dataTransferAddress_;
    /**
     * <pre>
     * If `data_transfer_protocol` is set, the address of the data transfer
     * server. The substring "%dts_port%" can be used to represent -- and is
     * replaced with -- the bound port of the data transfer server; this is useful
     * when `data_transfer_port` is set to `0`.
     * </pre>
     *
     * <code>string data_transfer_address = 8;</code>
     * @return The dataTransferAddress.
     */
    @java.lang.Override
    public java.lang.String getDataTransferAddress() {
      java.lang.Object ref = dataTransferAddress_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        dataTransferAddress_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If `data_transfer_protocol` is set, the address of the data transfer
     * server. The substring "%dts_port%" can be used to represent -- and is
     * replaced with -- the bound port of the data transfer server; this is useful
     * when `data_transfer_port` is set to `0`.
     * </pre>
     *
     * <code>string data_transfer_address = 8;</code>
     * @return The bytes for dataTransferAddress.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDataTransferAddressBytes() {
      java.lang.Object ref = dataTransferAddress_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        dataTransferAddress_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CROSS_TRAINER_CACHE_SIZE_BYTES_FIELD_NUMBER = 11;
    private long crossTrainerCacheSizeBytes_;
    /**
     * <pre>
     * Maximum size of the cross-trainer cache in bytes. If enabled, make sure
     * your training job provides sufficient memory resources.
     * </pre>
     *
     * <code>int64 cross_trainer_cache_size_bytes = 11;</code>
     * @return The crossTrainerCacheSizeBytes.
     */
    @java.lang.Override
    public long getCrossTrainerCacheSizeBytes() {
      return crossTrainerCacheSizeBytes_;
    }

    public static final int SNAPSHOT_MAX_CHUNK_SIZE_BYTES_FIELD_NUMBER = 12;
    private long snapshotMaxChunkSizeBytes_;
    /**
     * <pre>
     * The maximum size of a distributed snapshot chunk file. A value of 0
     * indicates that the decision should be left up to the runtime.
     * </pre>
     *
     * <code>int64 snapshot_max_chunk_size_bytes = 12;</code>
     * @return The snapshotMaxChunkSizeBytes.
     */
    @java.lang.Override
    public long getSnapshotMaxChunkSizeBytes() {
      return snapshotMaxChunkSizeBytes_;
    }

    public static final int SHUTDOWN_QUIET_PERIOD_MS_FIELD_NUMBER = 9;
    private long shutdownQuietPeriodMs_;
    /**
     * <pre>
     * When shutting down a worker, how long to wait for the gRPC server to
     * process the final requests. This is used to achieve clean shutdown in unit
     * tests.
     * </pre>
     *
     * <code>int64 shutdown_quiet_period_ms = 9;</code>
     * @return The shutdownQuietPeriodMs.
     */
    @java.lang.Override
    public long getShutdownQuietPeriodMs() {
      return shutdownQuietPeriodMs_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (port_ != 0L) {
        output.writeInt64(1, port_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(protocol_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, protocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dispatcherAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, dispatcherAddress_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(workerAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, workerAddress_);
      }
      if (heartbeatIntervalMs_ != 0L) {
        output.writeInt64(5, heartbeatIntervalMs_);
      }
      if (dispatcherTimeoutMs_ != 0L) {
        output.writeInt64(6, dispatcherTimeoutMs_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dataTransferProtocol_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, dataTransferProtocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dataTransferAddress_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 8, dataTransferAddress_);
      }
      if (shutdownQuietPeriodMs_ != 0L) {
        output.writeInt64(9, shutdownQuietPeriodMs_);
      }
      for (int i = 0; i < workerTags_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 10, workerTags_.getRaw(i));
      }
      if (crossTrainerCacheSizeBytes_ != 0L) {
        output.writeInt64(11, crossTrainerCacheSizeBytes_);
      }
      if (snapshotMaxChunkSizeBytes_ != 0L) {
        output.writeInt64(12, snapshotMaxChunkSizeBytes_);
      }
      if (dataTransferPort_ != 0L) {
        output.writeInt64(13, dataTransferPort_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (port_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(1, port_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(protocol_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, protocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dispatcherAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, dispatcherAddress_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(workerAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, workerAddress_);
      }
      if (heartbeatIntervalMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, heartbeatIntervalMs_);
      }
      if (dispatcherTimeoutMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(6, dispatcherTimeoutMs_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dataTransferProtocol_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, dataTransferProtocol_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(dataTransferAddress_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(8, dataTransferAddress_);
      }
      if (shutdownQuietPeriodMs_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(9, shutdownQuietPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < workerTags_.size(); i++) {
          dataSize += computeStringSizeNoTag(workerTags_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getWorkerTagsList().size();
      }
      if (crossTrainerCacheSizeBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(11, crossTrainerCacheSizeBytes_);
      }
      if (snapshotMaxChunkSizeBytes_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(12, snapshotMaxChunkSizeBytes_);
      }
      if (dataTransferPort_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(13, dataTransferPort_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig)) {
        return super.equals(obj);
      }
      org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig other = (org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig) obj;

      if (getPort()
          != other.getPort()) return false;
      if (!getProtocol()
          .equals(other.getProtocol())) return false;
      if (!getDispatcherAddress()
          .equals(other.getDispatcherAddress())) return false;
      if (!getWorkerAddress()
          .equals(other.getWorkerAddress())) return false;
      if (!getWorkerTagsList()
          .equals(other.getWorkerTagsList())) return false;
      if (getHeartbeatIntervalMs()
          != other.getHeartbeatIntervalMs()) return false;
      if (getDispatcherTimeoutMs()
          != other.getDispatcherTimeoutMs()) return false;
      if (!getDataTransferProtocol()
          .equals(other.getDataTransferProtocol())) return false;
      if (getDataTransferPort()
          != other.getDataTransferPort()) return false;
      if (!getDataTransferAddress()
          .equals(other.getDataTransferAddress())) return false;
      if (getCrossTrainerCacheSizeBytes()
          != other.getCrossTrainerCacheSizeBytes()) return false;
      if (getSnapshotMaxChunkSizeBytes()
          != other.getSnapshotMaxChunkSizeBytes()) return false;
      if (getShutdownQuietPeriodMs()
          != other.getShutdownQuietPeriodMs()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PORT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getPort());
      hash = (37 * hash) + PROTOCOL_FIELD_NUMBER;
      hash = (53 * hash) + getProtocol().hashCode();
      hash = (37 * hash) + DISPATCHER_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getDispatcherAddress().hashCode();
      hash = (37 * hash) + WORKER_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getWorkerAddress().hashCode();
      if (getWorkerTagsCount() > 0) {
        hash = (37 * hash) + WORKER_TAGS_FIELD_NUMBER;
        hash = (53 * hash) + getWorkerTagsList().hashCode();
      }
      hash = (37 * hash) + HEARTBEAT_INTERVAL_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHeartbeatIntervalMs());
      hash = (37 * hash) + DISPATCHER_TIMEOUT_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getDispatcherTimeoutMs());
      hash = (37 * hash) + DATA_TRANSFER_PROTOCOL_FIELD_NUMBER;
      hash = (53 * hash) + getDataTransferProtocol().hashCode();
      hash = (37 * hash) + DATA_TRANSFER_PORT_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getDataTransferPort());
      hash = (37 * hash) + DATA_TRANSFER_ADDRESS_FIELD_NUMBER;
      hash = (53 * hash) + getDataTransferAddress().hashCode();
      hash = (37 * hash) + CROSS_TRAINER_CACHE_SIZE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCrossTrainerCacheSizeBytes());
      hash = (37 * hash) + SNAPSHOT_MAX_CHUNK_SIZE_BYTES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSnapshotMaxChunkSizeBytes());
      hash = (37 * hash) + SHUTDOWN_QUIET_PERIOD_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getShutdownQuietPeriodMs());
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for a tf.data service WorkerServer.
     * Next id: 14
     * </pre>
     *
     * Protobuf type {@code tensorflow.data.experimental.WorkerConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:tensorflow.data.experimental.WorkerConfig)
        org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_WorkerConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_WorkerConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.class, org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.Builder.class);
      }

      // Construct using org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        port_ = 0L;

        protocol_ = "";

        dispatcherAddress_ = "";

        workerAddress_ = "";

        workerTags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        heartbeatIntervalMs_ = 0L;

        dispatcherTimeoutMs_ = 0L;

        dataTransferProtocol_ = "";

        dataTransferPort_ = 0L;

        dataTransferAddress_ = "";

        crossTrainerCacheSizeBytes_ = 0L;

        snapshotMaxChunkSizeBytes_ = 0L;

        shutdownQuietPeriodMs_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.internal_static_tensorflow_data_experimental_WorkerConfig_descriptor;
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig getDefaultInstanceForType() {
        return org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.getDefaultInstance();
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig build() {
        org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig buildPartial() {
        org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig result = new org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig(this);
        int from_bitField0_ = bitField0_;
        result.port_ = port_;
        result.protocol_ = protocol_;
        result.dispatcherAddress_ = dispatcherAddress_;
        result.workerAddress_ = workerAddress_;
        if (((bitField0_ & 0x00000001) != 0)) {
          workerTags_ = workerTags_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.workerTags_ = workerTags_;
        result.heartbeatIntervalMs_ = heartbeatIntervalMs_;
        result.dispatcherTimeoutMs_ = dispatcherTimeoutMs_;
        result.dataTransferProtocol_ = dataTransferProtocol_;
        result.dataTransferPort_ = dataTransferPort_;
        result.dataTransferAddress_ = dataTransferAddress_;
        result.crossTrainerCacheSizeBytes_ = crossTrainerCacheSizeBytes_;
        result.snapshotMaxChunkSizeBytes_ = snapshotMaxChunkSizeBytes_;
        result.shutdownQuietPeriodMs_ = shutdownQuietPeriodMs_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig) {
          return mergeFrom((org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig other) {
        if (other == org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig.getDefaultInstance()) return this;
        if (other.getPort() != 0L) {
          setPort(other.getPort());
        }
        if (!other.getProtocol().isEmpty()) {
          protocol_ = other.protocol_;
          onChanged();
        }
        if (!other.getDispatcherAddress().isEmpty()) {
          dispatcherAddress_ = other.dispatcherAddress_;
          onChanged();
        }
        if (!other.getWorkerAddress().isEmpty()) {
          workerAddress_ = other.workerAddress_;
          onChanged();
        }
        if (!other.workerTags_.isEmpty()) {
          if (workerTags_.isEmpty()) {
            workerTags_ = other.workerTags_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureWorkerTagsIsMutable();
            workerTags_.addAll(other.workerTags_);
          }
          onChanged();
        }
        if (other.getHeartbeatIntervalMs() != 0L) {
          setHeartbeatIntervalMs(other.getHeartbeatIntervalMs());
        }
        if (other.getDispatcherTimeoutMs() != 0L) {
          setDispatcherTimeoutMs(other.getDispatcherTimeoutMs());
        }
        if (!other.getDataTransferProtocol().isEmpty()) {
          dataTransferProtocol_ = other.dataTransferProtocol_;
          onChanged();
        }
        if (other.getDataTransferPort() != 0L) {
          setDataTransferPort(other.getDataTransferPort());
        }
        if (!other.getDataTransferAddress().isEmpty()) {
          dataTransferAddress_ = other.dataTransferAddress_;
          onChanged();
        }
        if (other.getCrossTrainerCacheSizeBytes() != 0L) {
          setCrossTrainerCacheSizeBytes(other.getCrossTrainerCacheSizeBytes());
        }
        if (other.getSnapshotMaxChunkSizeBytes() != 0L) {
          setSnapshotMaxChunkSizeBytes(other.getSnapshotMaxChunkSizeBytes());
        }
        if (other.getShutdownQuietPeriodMs() != 0L) {
          setShutdownQuietPeriodMs(other.getShutdownQuietPeriodMs());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                port_ = input.readInt64();

                break;
              } // case 8
              case 18: {
                protocol_ = input.readStringRequireUtf8();

                break;
              } // case 18
              case 26: {
                dispatcherAddress_ = input.readStringRequireUtf8();

                break;
              } // case 26
              case 34: {
                workerAddress_ = input.readStringRequireUtf8();

                break;
              } // case 34
              case 40: {
                heartbeatIntervalMs_ = input.readInt64();

                break;
              } // case 40
              case 48: {
                dispatcherTimeoutMs_ = input.readInt64();

                break;
              } // case 48
              case 58: {
                dataTransferProtocol_ = input.readStringRequireUtf8();

                break;
              } // case 58
              case 66: {
                dataTransferAddress_ = input.readStringRequireUtf8();

                break;
              } // case 66
              case 72: {
                shutdownQuietPeriodMs_ = input.readInt64();

                break;
              } // case 72
              case 82: {
                java.lang.String s = input.readStringRequireUtf8();
                ensureWorkerTagsIsMutable();
                workerTags_.add(s);
                break;
              } // case 82
              case 88: {
                crossTrainerCacheSizeBytes_ = input.readInt64();

                break;
              } // case 88
              case 96: {
                snapshotMaxChunkSizeBytes_ = input.readInt64();

                break;
              } // case 96
              case 104: {
                dataTransferPort_ = input.readInt64();

                break;
              } // case 104
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long port_ ;
      /**
       * <pre>
       * The port for the worker to bind to. A value of 0 indicates that the
       * worker may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @return The port.
       */
      @java.lang.Override
      public long getPort() {
        return port_;
      }
      /**
       * <pre>
       * The port for the worker to bind to. A value of 0 indicates that the
       * worker may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @param value The port to set.
       * @return This builder for chaining.
       */
      public Builder setPort(long value) {
        
        port_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The port for the worker to bind to. A value of 0 indicates that the
       * worker may bind to any available port.
       * </pre>
       *
       * <code>int64 port = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPort() {
        
        port_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object protocol_ = "";
      /**
       * <pre>
       * The protocol for the worker to use when connecting to the dispatcher.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return The protocol.
       */
      public java.lang.String getProtocol() {
        java.lang.Object ref = protocol_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          protocol_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The protocol for the worker to use when connecting to the dispatcher.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return The bytes for protocol.
       */
      public com.google.protobuf.ByteString
          getProtocolBytes() {
        java.lang.Object ref = protocol_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          protocol_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The protocol for the worker to use when connecting to the dispatcher.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @param value The protocol to set.
       * @return This builder for chaining.
       */
      public Builder setProtocol(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        protocol_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The protocol for the worker to use when connecting to the dispatcher.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearProtocol() {
        
        protocol_ = getDefaultInstance().getProtocol();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The protocol for the worker to use when connecting to the dispatcher.
       * </pre>
       *
       * <code>string protocol = 2;</code>
       * @param value The bytes for protocol to set.
       * @return This builder for chaining.
       */
      public Builder setProtocolBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        protocol_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object dispatcherAddress_ = "";
      /**
       * <pre>
       * The address of the dispatcher to register with.
       * </pre>
       *
       * <code>string dispatcher_address = 3;</code>
       * @return The dispatcherAddress.
       */
      public java.lang.String getDispatcherAddress() {
        java.lang.Object ref = dispatcherAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          dispatcherAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The address of the dispatcher to register with.
       * </pre>
       *
       * <code>string dispatcher_address = 3;</code>
       * @return The bytes for dispatcherAddress.
       */
      public com.google.protobuf.ByteString
          getDispatcherAddressBytes() {
        java.lang.Object ref = dispatcherAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dispatcherAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The address of the dispatcher to register with.
       * </pre>
       *
       * <code>string dispatcher_address = 3;</code>
       * @param value The dispatcherAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDispatcherAddress(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        dispatcherAddress_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the dispatcher to register with.
       * </pre>
       *
       * <code>string dispatcher_address = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearDispatcherAddress() {
        
        dispatcherAddress_ = getDefaultInstance().getDispatcherAddress();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the dispatcher to register with.
       * </pre>
       *
       * <code>string dispatcher_address = 3;</code>
       * @param value The bytes for dispatcherAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDispatcherAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        dispatcherAddress_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object workerAddress_ = "";
      /**
       * <pre>
       * The address of the worker server. The substring "%port%", if specified,
       * will be replaced with the worker's bound port. This is useful when the port
       * is set to `0`.
       * </pre>
       *
       * <code>string worker_address = 4;</code>
       * @return The workerAddress.
       */
      public java.lang.String getWorkerAddress() {
        java.lang.Object ref = workerAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          workerAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The address of the worker server. The substring "%port%", if specified,
       * will be replaced with the worker's bound port. This is useful when the port
       * is set to `0`.
       * </pre>
       *
       * <code>string worker_address = 4;</code>
       * @return The bytes for workerAddress.
       */
      public com.google.protobuf.ByteString
          getWorkerAddressBytes() {
        java.lang.Object ref = workerAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          workerAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The address of the worker server. The substring "%port%", if specified,
       * will be replaced with the worker's bound port. This is useful when the port
       * is set to `0`.
       * </pre>
       *
       * <code>string worker_address = 4;</code>
       * @param value The workerAddress to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerAddress(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        workerAddress_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the worker server. The substring "%port%", if specified,
       * will be replaced with the worker's bound port. This is useful when the port
       * is set to `0`.
       * </pre>
       *
       * <code>string worker_address = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkerAddress() {
        
        workerAddress_ = getDefaultInstance().getWorkerAddress();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The address of the worker server. The substring "%port%", if specified,
       * will be replaced with the worker's bound port. This is useful when the port
       * is set to `0`.
       * </pre>
       *
       * <code>string worker_address = 4;</code>
       * @param value The bytes for workerAddress to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        workerAddress_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList workerTags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureWorkerTagsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          workerTags_ = new com.google.protobuf.LazyStringArrayList(workerTags_);
          bitField0_ |= 0x00000001;
         }
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @return A list containing the workerTags.
       */
      public com.google.protobuf.ProtocolStringList
          getWorkerTagsList() {
        return workerTags_.getUnmodifiableView();
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @return The count of workerTags.
       */
      public int getWorkerTagsCount() {
        return workerTags_.size();
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param index The index of the element to return.
       * @return The workerTags at the given index.
       */
      public java.lang.String getWorkerTags(int index) {
        return workerTags_.get(index);
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param index The index of the value to return.
       * @return The bytes of the workerTags at the given index.
       */
      public com.google.protobuf.ByteString
          getWorkerTagsBytes(int index) {
        return workerTags_.getByteString(index);
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param index The index to set the value at.
       * @param value The workerTags to set.
       * @return This builder for chaining.
       */
      public Builder setWorkerTags(
          int index, java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureWorkerTagsIsMutable();
        workerTags_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param value The workerTags to add.
       * @return This builder for chaining.
       */
      public Builder addWorkerTags(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureWorkerTagsIsMutable();
        workerTags_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param values The workerTags to add.
       * @return This builder for chaining.
       */
      public Builder addAllWorkerTags(
          java.lang.Iterable<java.lang.String> values) {
        ensureWorkerTagsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, workerTags_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearWorkerTags() {
        workerTags_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Tags attached to the worker. This allows reading from selected workers.
       * For example, by applying a "COLOCATED" tag, tf.data service is able to read
       * from the local tf.data worker if one exists, then from off-TF-host workers,
       * to avoid cross-TF-host reads.
       * </pre>
       *
       * <code>repeated string worker_tags = 10;</code>
       * @param value The bytes of the workerTags to add.
       * @return This builder for chaining.
       */
      public Builder addWorkerTagsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureWorkerTagsIsMutable();
        workerTags_.add(value);
        onChanged();
        return this;
      }

      private long heartbeatIntervalMs_ ;
      /**
       * <pre>
       * How often the worker should heartbeat to the master. A value of 0 indicates
       * that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 heartbeat_interval_ms = 5;</code>
       * @return The heartbeatIntervalMs.
       */
      @java.lang.Override
      public long getHeartbeatIntervalMs() {
        return heartbeatIntervalMs_;
      }
      /**
       * <pre>
       * How often the worker should heartbeat to the master. A value of 0 indicates
       * that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 heartbeat_interval_ms = 5;</code>
       * @param value The heartbeatIntervalMs to set.
       * @return This builder for chaining.
       */
      public Builder setHeartbeatIntervalMs(long value) {
        
        heartbeatIntervalMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How often the worker should heartbeat to the master. A value of 0 indicates
       * that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 heartbeat_interval_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearHeartbeatIntervalMs() {
        
        heartbeatIntervalMs_ = 0L;
        onChanged();
        return this;
      }

      private long dispatcherTimeoutMs_ ;
      /**
       * <pre>
       * How long to retry requests to the dispatcher before giving up and reporting
       * an error. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 dispatcher_timeout_ms = 6;</code>
       * @return The dispatcherTimeoutMs.
       */
      @java.lang.Override
      public long getDispatcherTimeoutMs() {
        return dispatcherTimeoutMs_;
      }
      /**
       * <pre>
       * How long to retry requests to the dispatcher before giving up and reporting
       * an error. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 dispatcher_timeout_ms = 6;</code>
       * @param value The dispatcherTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setDispatcherTimeoutMs(long value) {
        
        dispatcherTimeoutMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How long to retry requests to the dispatcher before giving up and reporting
       * an error. A value of 0 indicates that the decision should be left up to the
       * runtime.
       * </pre>
       *
       * <code>int64 dispatcher_timeout_ms = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearDispatcherTimeoutMs() {
        
        dispatcherTimeoutMs_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object dataTransferProtocol_ = "";
      /**
       * <pre>
       * If set, the name of an alternative data transfer protocol for which the
       * worker starts an additional server ("data transfer server"); the trainer
       * can then get data from this server. If not set, no such server is started,
       * and the trainer can only get data from the regular worker server over
       * `protocol`.
       * </pre>
       *
       * <code>string data_transfer_protocol = 7;</code>
       * @return The dataTransferProtocol.
       */
      public java.lang.String getDataTransferProtocol() {
        java.lang.Object ref = dataTransferProtocol_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          dataTransferProtocol_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If set, the name of an alternative data transfer protocol for which the
       * worker starts an additional server ("data transfer server"); the trainer
       * can then get data from this server. If not set, no such server is started,
       * and the trainer can only get data from the regular worker server over
       * `protocol`.
       * </pre>
       *
       * <code>string data_transfer_protocol = 7;</code>
       * @return The bytes for dataTransferProtocol.
       */
      public com.google.protobuf.ByteString
          getDataTransferProtocolBytes() {
        java.lang.Object ref = dataTransferProtocol_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dataTransferProtocol_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If set, the name of an alternative data transfer protocol for which the
       * worker starts an additional server ("data transfer server"); the trainer
       * can then get data from this server. If not set, no such server is started,
       * and the trainer can only get data from the regular worker server over
       * `protocol`.
       * </pre>
       *
       * <code>string data_transfer_protocol = 7;</code>
       * @param value The dataTransferProtocol to set.
       * @return This builder for chaining.
       */
      public Builder setDataTransferProtocol(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        dataTransferProtocol_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the name of an alternative data transfer protocol for which the
       * worker starts an additional server ("data transfer server"); the trainer
       * can then get data from this server. If not set, no such server is started,
       * and the trainer can only get data from the regular worker server over
       * `protocol`.
       * </pre>
       *
       * <code>string data_transfer_protocol = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataTransferProtocol() {
        
        dataTransferProtocol_ = getDefaultInstance().getDataTransferProtocol();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the name of an alternative data transfer protocol for which the
       * worker starts an additional server ("data transfer server"); the trainer
       * can then get data from this server. If not set, no such server is started,
       * and the trainer can only get data from the regular worker server over
       * `protocol`.
       * </pre>
       *
       * <code>string data_transfer_protocol = 7;</code>
       * @param value The bytes for dataTransferProtocol to set.
       * @return This builder for chaining.
       */
      public Builder setDataTransferProtocolBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        dataTransferProtocol_ = value;
        onChanged();
        return this;
      }

      private long dataTransferPort_ ;
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the port to which the data transfer
       * server binds. If set to `0`, the server binds to any available port.
       * </pre>
       *
       * <code>int64 data_transfer_port = 13;</code>
       * @return The dataTransferPort.
       */
      @java.lang.Override
      public long getDataTransferPort() {
        return dataTransferPort_;
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the port to which the data transfer
       * server binds. If set to `0`, the server binds to any available port.
       * </pre>
       *
       * <code>int64 data_transfer_port = 13;</code>
       * @param value The dataTransferPort to set.
       * @return This builder for chaining.
       */
      public Builder setDataTransferPort(long value) {
        
        dataTransferPort_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the port to which the data transfer
       * server binds. If set to `0`, the server binds to any available port.
       * </pre>
       *
       * <code>int64 data_transfer_port = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataTransferPort() {
        
        dataTransferPort_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object dataTransferAddress_ = "";
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the address of the data transfer
       * server. The substring "%dts_port%" can be used to represent -- and is
       * replaced with -- the bound port of the data transfer server; this is useful
       * when `data_transfer_port` is set to `0`.
       * </pre>
       *
       * <code>string data_transfer_address = 8;</code>
       * @return The dataTransferAddress.
       */
      public java.lang.String getDataTransferAddress() {
        java.lang.Object ref = dataTransferAddress_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          dataTransferAddress_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the address of the data transfer
       * server. The substring "%dts_port%" can be used to represent -- and is
       * replaced with -- the bound port of the data transfer server; this is useful
       * when `data_transfer_port` is set to `0`.
       * </pre>
       *
       * <code>string data_transfer_address = 8;</code>
       * @return The bytes for dataTransferAddress.
       */
      public com.google.protobuf.ByteString
          getDataTransferAddressBytes() {
        java.lang.Object ref = dataTransferAddress_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          dataTransferAddress_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the address of the data transfer
       * server. The substring "%dts_port%" can be used to represent -- and is
       * replaced with -- the bound port of the data transfer server; this is useful
       * when `data_transfer_port` is set to `0`.
       * </pre>
       *
       * <code>string data_transfer_address = 8;</code>
       * @param value The dataTransferAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDataTransferAddress(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        dataTransferAddress_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the address of the data transfer
       * server. The substring "%dts_port%" can be used to represent -- and is
       * replaced with -- the bound port of the data transfer server; this is useful
       * when `data_transfer_port` is set to `0`.
       * </pre>
       *
       * <code>string data_transfer_address = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataTransferAddress() {
        
        dataTransferAddress_ = getDefaultInstance().getDataTransferAddress();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If `data_transfer_protocol` is set, the address of the data transfer
       * server. The substring "%dts_port%" can be used to represent -- and is
       * replaced with -- the bound port of the data transfer server; this is useful
       * when `data_transfer_port` is set to `0`.
       * </pre>
       *
       * <code>string data_transfer_address = 8;</code>
       * @param value The bytes for dataTransferAddress to set.
       * @return This builder for chaining.
       */
      public Builder setDataTransferAddressBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        dataTransferAddress_ = value;
        onChanged();
        return this;
      }

      private long crossTrainerCacheSizeBytes_ ;
      /**
       * <pre>
       * Maximum size of the cross-trainer cache in bytes. If enabled, make sure
       * your training job provides sufficient memory resources.
       * </pre>
       *
       * <code>int64 cross_trainer_cache_size_bytes = 11;</code>
       * @return The crossTrainerCacheSizeBytes.
       */
      @java.lang.Override
      public long getCrossTrainerCacheSizeBytes() {
        return crossTrainerCacheSizeBytes_;
      }
      /**
       * <pre>
       * Maximum size of the cross-trainer cache in bytes. If enabled, make sure
       * your training job provides sufficient memory resources.
       * </pre>
       *
       * <code>int64 cross_trainer_cache_size_bytes = 11;</code>
       * @param value The crossTrainerCacheSizeBytes to set.
       * @return This builder for chaining.
       */
      public Builder setCrossTrainerCacheSizeBytes(long value) {
        
        crossTrainerCacheSizeBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Maximum size of the cross-trainer cache in bytes. If enabled, make sure
       * your training job provides sufficient memory resources.
       * </pre>
       *
       * <code>int64 cross_trainer_cache_size_bytes = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearCrossTrainerCacheSizeBytes() {
        
        crossTrainerCacheSizeBytes_ = 0L;
        onChanged();
        return this;
      }

      private long snapshotMaxChunkSizeBytes_ ;
      /**
       * <pre>
       * The maximum size of a distributed snapshot chunk file. A value of 0
       * indicates that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 snapshot_max_chunk_size_bytes = 12;</code>
       * @return The snapshotMaxChunkSizeBytes.
       */
      @java.lang.Override
      public long getSnapshotMaxChunkSizeBytes() {
        return snapshotMaxChunkSizeBytes_;
      }
      /**
       * <pre>
       * The maximum size of a distributed snapshot chunk file. A value of 0
       * indicates that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 snapshot_max_chunk_size_bytes = 12;</code>
       * @param value The snapshotMaxChunkSizeBytes to set.
       * @return This builder for chaining.
       */
      public Builder setSnapshotMaxChunkSizeBytes(long value) {
        
        snapshotMaxChunkSizeBytes_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The maximum size of a distributed snapshot chunk file. A value of 0
       * indicates that the decision should be left up to the runtime.
       * </pre>
       *
       * <code>int64 snapshot_max_chunk_size_bytes = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearSnapshotMaxChunkSizeBytes() {
        
        snapshotMaxChunkSizeBytes_ = 0L;
        onChanged();
        return this;
      }

      private long shutdownQuietPeriodMs_ ;
      /**
       * <pre>
       * When shutting down a worker, how long to wait for the gRPC server to
       * process the final requests. This is used to achieve clean shutdown in unit
       * tests.
       * </pre>
       *
       * <code>int64 shutdown_quiet_period_ms = 9;</code>
       * @return The shutdownQuietPeriodMs.
       */
      @java.lang.Override
      public long getShutdownQuietPeriodMs() {
        return shutdownQuietPeriodMs_;
      }
      /**
       * <pre>
       * When shutting down a worker, how long to wait for the gRPC server to
       * process the final requests. This is used to achieve clean shutdown in unit
       * tests.
       * </pre>
       *
       * <code>int64 shutdown_quiet_period_ms = 9;</code>
       * @param value The shutdownQuietPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setShutdownQuietPeriodMs(long value) {
        
        shutdownQuietPeriodMs_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When shutting down a worker, how long to wait for the gRPC server to
       * process the final requests. This is used to achieve clean shutdown in unit
       * tests.
       * </pre>
       *
       * <code>int64 shutdown_quiet_period_ms = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearShutdownQuietPeriodMs() {
        
        shutdownQuietPeriodMs_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:tensorflow.data.experimental.WorkerConfig)
    }

    // @@protoc_insertion_point(class_scope:tensorflow.data.experimental.WorkerConfig)
    private static final org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig();
    }

    public static org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<WorkerConfig>
        PARSER = new com.google.protobuf.AbstractParser<WorkerConfig>() {
      @java.lang.Override
      public WorkerConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<WorkerConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<WorkerConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.tensorflow.proto.data.experimental.ServiceConfig.WorkerConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_data_experimental_DispatcherConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_tensorflow_data_experimental_WorkerConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_tensorflow_data_experimental_WorkerConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n-tensorflow/core/protobuf/service_confi" +
      "g.proto\022\034tensorflow.data.experimental\032+t" +
      "ensorflow/core/protobuf/data_service.pro" +
      "to\"\363\002\n\020DispatcherConfig\022\014\n\004port\030\001 \001(\003\022\020\n" +
      "\010protocol\030\002 \001(\t\022\020\n\010work_dir\030\003 \001(\t\022\033\n\023fau" +
      "lt_tolerant_mode\030\004 \001(\010\022\030\n\020worker_address" +
      "es\030\007 \003(\t\0228\n\017deployment_mode\030\t \001(\0162\037.tens" +
      "orflow.data.DeploymentMode\022 \n\030job_gc_che" +
      "ck_interval_ms\030\005 \001(\003\022\031\n\021job_gc_timeout_m" +
      "s\030\006 \001(\003\022 \n\030gc_dynamic_sharding_jobs\030\013 \001(" +
      "\010\022\031\n\021client_timeout_ms\030\010 \001(\003\022\031\n\021worker_t" +
      "imeout_ms\030\n \001(\003\022\'\n\037worker_max_concurrent" +
      "_snapshots\030\014 \001(\003\"\201\003\n\014WorkerConfig\022\014\n\004por" +
      "t\030\001 \001(\003\022\020\n\010protocol\030\002 \001(\t\022\032\n\022dispatcher_" +
      "address\030\003 \001(\t\022\026\n\016worker_address\030\004 \001(\t\022\023\n" +
      "\013worker_tags\030\n \003(\t\022\035\n\025heartbeat_interval" +
      "_ms\030\005 \001(\003\022\035\n\025dispatcher_timeout_ms\030\006 \001(\003" +
      "\022\036\n\026data_transfer_protocol\030\007 \001(\t\022\032\n\022data" +
      "_transfer_port\030\r \001(\003\022\035\n\025data_transfer_ad" +
      "dress\030\010 \001(\t\022&\n\036cross_trainer_cache_size_" +
      "bytes\030\013 \001(\003\022%\n\035snapshot_max_chunk_size_b" +
      "ytes\030\014 \001(\003\022 \n\030shutdown_quiet_period_ms\030\t" +
      " \001(\003B\177\n&org.tensorflow.proto.data.experi" +
      "mentalZUgithub.com/tensorflow/tensorflow" +
      "/tensorflow/go/core/protobuf/for_core_pr" +
      "otos_go_protob\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          org.tensorflow.proto.data.DataService.getDescriptor(),
        });
    internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_tensorflow_data_experimental_DispatcherConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_data_experimental_DispatcherConfig_descriptor,
        new java.lang.String[] { "Port", "Protocol", "WorkDir", "FaultTolerantMode", "WorkerAddresses", "DeploymentMode", "JobGcCheckIntervalMs", "JobGcTimeoutMs", "GcDynamicShardingJobs", "ClientTimeoutMs", "WorkerTimeoutMs", "WorkerMaxConcurrentSnapshots", });
    internal_static_tensorflow_data_experimental_WorkerConfig_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_tensorflow_data_experimental_WorkerConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_tensorflow_data_experimental_WorkerConfig_descriptor,
        new java.lang.String[] { "Port", "Protocol", "DispatcherAddress", "WorkerAddress", "WorkerTags", "HeartbeatIntervalMs", "DispatcherTimeoutMs", "DataTransferProtocol", "DataTransferPort", "DataTransferAddress", "CrossTrainerCacheSizeBytes", "SnapshotMaxChunkSizeBytes", "ShutdownQuietPeriodMs", });
    org.tensorflow.proto.data.DataService.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
