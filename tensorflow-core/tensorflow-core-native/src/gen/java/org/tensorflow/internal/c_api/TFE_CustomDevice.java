// Targeted by JavaCPP version 1.5.9: DO NOT EDIT THIS FILE

package org.tensorflow.internal.c_api;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.tensorflow.internal.c_api.global.tensorflow.*;


// Struct to be filled in. Functions are required except where indicated.
@Properties(inherit = org.tensorflow.internal.c_api.presets.tensorflow.class)
public class TFE_CustomDevice extends Pointer {
    static { Loader.load(); }
    /** Default native constructor. */
    public TFE_CustomDevice() { super((Pointer)null); allocate(); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public TFE_CustomDevice(long size) { super((Pointer)null); allocateArray(size); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public TFE_CustomDevice(Pointer p) { super(p); }
    private native void allocate();
    private native void allocateArray(long size);
    @Override public TFE_CustomDevice position(long position) {
        return (TFE_CustomDevice)super.position(position);
    }
    @Override public TFE_CustomDevice getPointer(long i) {
        return new TFE_CustomDevice((Pointer)this).offsetAddress(i);
    }

  public native int version(); public native TFE_CustomDevice version(int setter);
  // Method to copy a tensor to the custom device.
  public static class Copy_tensor_to_device_TFE_Context_TFE_TensorHandle_TF_Status_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Copy_tensor_to_device_TFE_Context_TFE_TensorHandle_TF_Status_Pointer(Pointer p) { super(p); }
      protected Copy_tensor_to_device_TFE_Context_TFE_TensorHandle_TF_Status_Pointer() { allocate(); }
      private native void allocate();
      public native TFE_TensorHandle call(TFE_Context context,
                                               TFE_TensorHandle tensor,
                                               TF_Status status,
                                               Pointer device_info);
  }
  public native Copy_tensor_to_device_TFE_Context_TFE_TensorHandle_TF_Status_Pointer copy_tensor_to_device(); public native TFE_CustomDevice copy_tensor_to_device(Copy_tensor_to_device_TFE_Context_TFE_TensorHandle_TF_Status_Pointer setter);

  // Method to copy a tensor from the custom device to a target device.
  public static class Copy_tensor_from_device_TFE_Context_TFE_TensorHandle_BytePointer_TF_Status_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Copy_tensor_from_device_TFE_Context_TFE_TensorHandle_BytePointer_TF_Status_Pointer(Pointer p) { super(p); }
      protected Copy_tensor_from_device_TFE_Context_TFE_TensorHandle_BytePointer_TF_Status_Pointer() { allocate(); }
      private native void allocate();
      public native TFE_TensorHandle call(TFE_Context context,
                                                 TFE_TensorHandle tensor,
                                                 @Cast("const char*") BytePointer target_device_name,
                                                 TF_Status status,
                                                 Pointer device_info);
  }
  public native Copy_tensor_from_device_TFE_Context_TFE_TensorHandle_BytePointer_TF_Status_Pointer copy_tensor_from_device(); public native TFE_CustomDevice copy_tensor_from_device(Copy_tensor_from_device_TFE_Context_TFE_TensorHandle_BytePointer_TF_Status_Pointer setter);

  // Method to execute an operation.
  //
  // Arguments provide enough information to reconstruct the original `TFE_Op`,
  // or construct a transformed version, by inspecting the passed `op`.
  //
  // TFE_OpGetDevice(op) records the original placement of the operation. It may
  // be an empty string if no device was explicitly requested, but will
  // otherwise be the name of this custom device. Ops are placed onto a custom
  // device if any of their inputs are on that custom device, but custom devices
  // are free to set a bad status in order to require explicit placement.
  public static class Execute_TFE_Op_IntPointer_PointerPointer_TF_Status_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Execute_TFE_Op_IntPointer_PointerPointer_TF_Status_Pointer(Pointer p) { super(p); }
      protected Execute_TFE_Op_IntPointer_PointerPointer_TF_Status_Pointer() { allocate(); }
      private native void allocate();
      public native void call(@Const TFE_Op op, IntPointer num_outputs,
                    @Cast("TFE_TensorHandle**") PointerPointer outputs, TF_Status s, Pointer device_info);
  }
  public native Execute_TFE_Op_IntPointer_PointerPointer_TF_Status_Pointer execute(); public native TFE_CustomDevice execute(Execute_TFE_Op_IntPointer_PointerPointer_TF_Status_Pointer setter);

  // Method to delete a device.
  public static class Delete_device_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Delete_device_Pointer(Pointer p) { super(p); }
      protected Delete_device_Pointer() { allocate(); }
      private native void allocate();
      public native void call(Pointer device_info);
  }
  public native Delete_device_Pointer delete_device(); public native TFE_CustomDevice delete_device(Delete_device_Pointer setter);

  // Implements TFE_CreatePackedTensorHandle when one of `handles` is on this
  // custom device.
  //
  // Many devices will want to simply return an "unimplemented" status
  // here. This is the default behavior if `pack` is null when passed to
  // TFE_RegisterCustomDevice.
  public static class Pack_TFE_Context_PointerPointer_int_TF_Status_Pointer extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Pack_TFE_Context_PointerPointer_int_TF_Status_Pointer(Pointer p) { super(p); }
      protected Pack_TFE_Context_PointerPointer_int_TF_Status_Pointer() { allocate(); }
      private native void allocate();
      public native TFE_TensorHandle call(TFE_Context context, @Cast("TFE_TensorHandle**") PointerPointer handles,
                              int num_handles, TF_Status s,
                              Pointer device_info);
  }
  public native Pack_TFE_Context_PointerPointer_int_TF_Status_Pointer pack(); public native TFE_CustomDevice pack(Pack_TFE_Context_PointerPointer_int_TF_Status_Pointer setter);

  // Pins the op to `device` based on inputs to `op`. Returns true
  // signifying to pin to the current custom device. Returns false
  // to pin to the physical device.
  //
  // This function is guaranteed to be called only when all of the custom-device
  // inputs are on this device.
  public static class Shall_pin_to_this_device_TFE_Op_TF_Status extends FunctionPointer {
      static { Loader.load(); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public    Shall_pin_to_this_device_TFE_Op_TF_Status(Pointer p) { super(p); }
      protected Shall_pin_to_this_device_TFE_Op_TF_Status() { allocate(); }
      private native void allocate();
      public native @Cast("bool") boolean call(@Const TFE_Op op, TF_Status s);
  }
  public native Shall_pin_to_this_device_TFE_Op_TF_Status shall_pin_to_this_device(); public native TFE_CustomDevice shall_pin_to_this_device(Shall_pin_to_this_device_TFE_Op_TF_Status setter);
}
