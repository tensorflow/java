<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.tensorflow</groupId>
    <artifactId>tensorflow-core</artifactId>
    <version>0.1.0-SNAPSHOT</version>
  </parent>
  <artifactId>tensorflow-core-api</artifactId>
  <packaging>jar</packaging>

  <name>TensorFlow Core API Library</name>
  <description>Platform-dependent native code and pure-Java code for the TensorFlow machine intelligence library.</description>

  <properties>
    <!-- Match version used by TensorFlow, in tensorflow/workspace.bzl -->
    <protobuf.version>3.8.0</protobuf.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.bytedeco</groupId>
      <artifactId>javacpp</artifactId>
      <version>${javacpp.version}</version>
    </dependency>
    <dependency>
      <groupId>org.bytedeco</groupId>
      <artifactId>javacpp</artifactId>
      <version>${javacpp.version}</version>
      <classifier>${javacpp.platform}</classifier>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.google.protobuf</groupId>
      <artifactId>protobuf-java</artifactId>
      <version>${protobuf.version}</version>
    </dependency>
    <dependency>
      <groupId>org.tensorflow</groupId>
      <artifactId>tensorflow-core-generator</artifactId>
      <version>${project.version}</version>
      <optional>true</optional> <!-- for compilation only -->
    </dependency>
    <dependency>
      <groupId>org.tensorflow</groupId>
      <artifactId>tensorflow-tools</artifactId>
      <version>${project.version}</version>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-core</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-generator-annprocess</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>3.0.0</version>
        <executions>
          <!--
          Add generated classes to the source path
            These are classes generated by the javacpp-plugin, including TensorFlow operations
            wrappers and C API Java bindings
          -->
          <execution>
            <id>add-gen-sources</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>add-source</goal>
            </goals>
            <configuration>
              <sources>
                <source>${project.basedir}/src/gen/java</source>
              </sources>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.0</version>
        <executions>
          <!--
          Generate Ops classes
            All classes found in the source path that are annotated with `@Operator` are processed
            to be added as an endpoint to one of the generated Ops class
          -->
          <execution>
            <id>default-compile</id>
            <configuration>
              <annotationProcessors>
                <annotationProcessor>org.tensorflow.processor.operator.OperatorProcessor</annotationProcessor>
              </annotationProcessors>
              <!-- Important: Cannot be ${project.basedir}/src/gen/java or wherever the ops are -->
              <generatedSourcesDirectory>${project.basedir}/src/gen/annotations</generatedSourcesDirectory>
            </configuration>
          </execution>
          <!--
          Compile JavaCPP presets
            This must be done prematurely, at the generate-sources phase, since the javacpp-plugin
            will parse the compiled presets for generating Java bindings to the native APIs
          -->
          <execution>
            <id>javacpp-parser</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>compile</goal>
            </goals>
            <configuration>
              <includes>
                <include>org/tensorflow/internal/c_api/presets/*.java</include>
              </includes>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.bytedeco</groupId>
        <artifactId>javacpp</artifactId>
        <version>${javacpp.version}</version>
        <configuration>
          <properties>${javacpp.platform.properties}</properties>
          <propertyKeysAndValues>
            <property>
              <name>platform.root</name>
              <value>${javacpp.platform.root}</value>
            </property>
            <property>
              <name>platform.compiler</name>
              <value>${javacpp.platform.compiler}</value>
            </property>
            <property>
              <name>platform.extension</name>
              <value>${javacpp.platform.extension}</value>
            </property>
          </propertyKeysAndValues>
          <classPath>${project.build.outputDirectory}</classPath>
          <includePaths>
            <includePath>${project.basedir}/</includePath>
            <includePath>${project.basedir}/bazel-${project.artifactId}/external/org_tensorflow/</includePath>
          </includePaths>
          <linkPaths>
            <linkPath>${project.basedir}/bazel-bin/external/org_tensorflow/tensorflow/</linkPath>
          </linkPaths>
          <resourcePaths>
            <resourcePath>${project.basedir}/../../</resourcePath>
            <resourcePath>${project.basedir}/bazel-bin/external/org_tensorflow/tensorflow/tools/lib_package/</resourcePath>
          </resourcePaths>
          <preloadPaths>
            <preloadPath>${project.basedir}/bazel-${project.artifactId}/external/mkl_linux/lib/</preloadPath>
            <preloadPath>${project.basedir}/bazel-${project.artifactId}/external/mkl_darwin/lib/</preloadPath>
            <preloadPath>${project.basedir}/bazel-${project.artifactId}/external/mkl_windows/lib/</preloadPath>
          </preloadPaths>
        </configuration>
        <executions>
          <execution>
            <!--
            Validates the configuration of this plugin
            -->
            <id>javacpp-validate</id>
            <phase>validate</phase>
            <goals>
              <goal>build</goal>
            </goals>
          </execution>
          <execution>
            <!--
            Build TensorFlow core libraries
              This launch a script (build.sh) that will execute Bazel for uploading archives and
              executing the build, which may take many hours on a normal desktop. Libraries are then
              cached so only the first execution will actually trigger a full build.
              This task also trigger the generation of the operation wrappers issued from the code
              found in /src/bazel/op_generator.
            -->
            <id>javacpp-build</id>
            <phase>initialize</phase>
            <goals>
              <goal>build</goal>
            </goals>
            <configuration>
              <skip>${javacpp.build.skip}</skip>
              <buildCommand>
                <program>bash</program>
                <argument>${project.basedir}/build.sh</argument>
              </buildCommand>
              <environmentVariables>
                <EXTENSION>${javacpp.platform.extension}</EXTENSION>
              </environmentVariables>
              <workingDirectory>${project.basedir}</workingDirectory>
            </configuration>
          </execution>
          <execution>
            <!--
            Clean TensorFlow native libraries
              When this gets executed, all libraries build and cached by Bazel will be deleted and
              will be rebuild on the next execution.
            -->
            <id>javacpp-clean</id>
            <phase>clean</phase>
            <goals>
              <goal>build</goal>
            </goals>
            <configuration>
              <skip>${javacpp.build.skip}</skip>
              <buildCommand>
                <program>bazel</program>
                <argument>clean</argument>
              </buildCommand>
              <workingDirectory>${project.basedir}</workingDirectory>
            </configuration>
          </execution>
          <execution>
            <!--
            Generate TensorFlow C API binding sources
              The plugin will parse the pre-compiled TensorFlow C API presets and generate
              source classes for calling this API directly in Java.
            -->
            <id>javacpp-parser</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>parse</goal>
            </goals>
            <configuration>
              <skip>${javacpp.parser.skip}</skip>
              <outputDirectory>${project.basedir}/src/gen/java</outputDirectory>
              <classOrPackageName>org.tensorflow.internal.c_api.presets.*</classOrPackageName>
            </configuration>
          </execution>
          <execution>
            <!--
            Compile JNI native code from this project
              This code is used to called the TensorFlow C API right now but should be eventually
              replaced by the usage of JavaCPP generated bindings
            -->
            <id>javacpp-compiler</id>
            <phase>process-classes</phase>
            <goals>
              <goal>build</goal>
            </goals>
            <configuration>
              <outputDirectory>${project.build.directory}/native/org/tensorflow/internal/c_api/${native.classifier}/</outputDirectory>
              <skip>${javacpp.compiler.skip}</skip>
              <classOrPackageName>org.tensorflow.internal.c_api.**</classOrPackageName>
              <copyLibs>true</copyLibs>
              <copyResources>true</copyResources>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
            <version>${protobuf.version}</version>
          </dependency>
        </dependencies>
      </plugin>
      <plugin>
        <artifactId>maven-jar-plugin</artifactId>
        <version>3.1.0</version>
        <executions>
          <execution>
            <!--
            Create the native artifact
              This artifact will contain only native libraries compiled by the javacpp-plugin,
              and will be classified under the active platform (OS, arch, extension...)
            -->
            <id>native-jar</id>
            <phase>package</phase>
            <goals>
              <goal>jar</goal>
            </goals>
            <configuration>
              <classifier>${native.classifier}</classifier>
              <skipIfEmpty>true</skipIfEmpty>
              <includes> 
                <!-- In case of successive builds for multiple platforms without cleaning, ensures
                     we only include files for this platform. -->
                <include>org/tensorflow/internal/c_api/${native.classifier}/</include>
              </includes>
              <classesDirectory>${project.build.directory}/native</classesDirectory>
              <excludes>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.exp</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.lib</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.obj</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*mklml*</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*iomp5*</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*msvcr120*</exclude>
              </excludes>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>2.22.0</version>
        <configuration>
          <!--
          Ensure the discovery of the native libraries by JUnit
            While only adding elements to the classpath is enough for running tests in Maven,
            we need to explicitly add them to the Java library path to run them from some IDEs
          -->
          <argLine>
            -Djava.library.path=${project.build.directory}/native/org/tensorflow/internal/c_api/${native.classifier}
          </argLine>
          <additionalClasspathElements>${project.build.directory}/native/</additionalClasspathElements>
          <systemPropertyVariables>
            <NATIVE_PLATFORM>${javacpp.platform}</NATIVE_PLATFORM>
          </systemPropertyVariables>
        </configuration>
      </plugin>
      <plugin>
        <artifactId>maven-source-plugin</artifactId>
        <version>3.0.1</version>
        <executions>
          <execution>
            <id>attach-sources</id>
            <phase>leave-disabled-to-not-generate-sources-twice-on-release</phase>
          </execution>
          <execution>
            <id>attach-source</id>
            <goals>
              <goal>jar-no-fork</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-javadoc-plugin</artifactId>
        <version>3.0.1</version>
        <executions>
          <execution>
            <id>attach-javadocs</id>
            <goals>
              <goal>jar</goal>
            </goals>
            <configuration>
              <failOnError>false</failOnError>
              <minmemory>256m</minmemory>
              <maxmemory>2048m</maxmemory>
              <quiet>true</quiet>
              <links>
                <link>http://bytedeco.org/javacpp/apidocs</link>
              </links>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <version>3.2.0</version>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
