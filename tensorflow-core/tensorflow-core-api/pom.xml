<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>org.tensorflow</groupId>
    <artifactId>tensorflow-core</artifactId>
    <version>0.6.0-SNAPSHOT</version>
  </parent>
  <artifactId>tensorflow-core-api</artifactId>
  <packaging>jar</packaging>

  <name>TensorFlow Core API Library</name>
  <description>Platform-dependent native code and pure-Java code for the TensorFlow machine intelligence library.</description>

  <properties>
    <native.download.skip>false</native.download.skip>
    <native.download.folder>${project.build.directory}/native-download/</native.download.folder>
    <native.target.folder>${project.build.directory}/native/org/tensorflow/internal/c_api/${native.classifier}/</native.target.folder>
    <native.build.bazel>true</native.build.bazel>
    <native.build.flags/>
    <javacpp.build.skip>false</javacpp.build.skip>
    <javacpp.parser.skip>false</javacpp.parser.skip>
    <javacpp.compiler.skip>false</javacpp.compiler.skip>
    <java.module.name>org.tensorflow.core.api</java.module.name>
    <ndarray.version>0.4.0</ndarray.version>
    <truth.version>1.1.5</truth.version>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.bytedeco</groupId>
      <artifactId>javacpp</artifactId>
      <version>${javacpp.version}</version>
    </dependency>
    <dependency>
      <groupId>org.bytedeco</groupId>
      <artifactId>javacpp</artifactId>
      <version>${javacpp.version}</version>
      <classifier>${javacpp.platform}</classifier>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.google.protobuf</groupId>
      <artifactId>protobuf-java</artifactId>
      <version>${protobuf.version}</version>
    </dependency>
    <dependency>
      <groupId>org.tensorflow</groupId>
      <artifactId>ndarray</artifactId>
      <version>${ndarray.version}</version>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-core</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.google.truth</groupId>
      <artifactId>truth</artifactId>
      <version>${truth.version}</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.openjdk.jmh</groupId>
      <artifactId>jmh-generator-annprocess</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <profiles>
    <profile>
      <!--
        Native Build Profile
          By default, TensorFlow Java build downloads the native runtime libraries from the official Python wheels distribution
          to generate Java bindings and bundle them into a JAR. This is only possible if a full TensorFlow build has been done
          previously, which will take care of generating the Java protos and operators.

          If you want to upgrade the version of TensorFlow in your distribution, or if you need to build TensorFlow for
          a platform that is not supported officially by TensorFlow Java, you need to run locally a native build. On a
          TensorFlow version upgrade, files generated by the native build can then be pushed back to TensorFlow Java GitHub
          repository.
      -->
      <id>native-build</id>
      <properties>
        <native.download.skip>true</native.download.skip>
      </properties>
      <build>
        <plugins>
          <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>exec-maven-plugin</artifactId>
            <version>3.1.0</version>
            <executions>
              <execution>
                <!--
                  Run the full native build with Bazel
                    This will compile TensorFlow from sources to generate various artifacts, including the Java protos and
                    the list of operators available for parsing.
                    Executed in the initialize phase so that all resources issued from that build are available to subsequent
                    build phases
                -->
                <id>run-native-build</id>
                <goals>
                  <goal>exec</goal>
                </goals>
                <phase>initialize</phase>
                <configuration>
                  <executable>/bin/bash</executable>
                  <arguments>
                    <argument>scripts/native_build.sh</argument>
                  </arguments>
                  <environmentVariables>
                    <BAZEL_RUN>${native.build.bazel}</BAZEL_RUN>
                    <PLATFORM>${javacpp.platform}</PLATFORM>
                    <EXTENSION>${javacpp.platform.extension}</EXTENSION>
                    <BUILD_USER_FLAGS>${native.build.flags}</BUILD_USER_FLAGS>
                  </environmentVariables>
                </configuration>
              </execution>
              <execution>
                <!--
                  Execute the op class generator to generate the operators (which lives in tensorflow-core-generator).
                    Must be ran after native_build.sh, which generates the ops.pb file it reads.
                    Will be ran during the generate-sources phase.
                -->
                <id>generate-ops</id>
                <goals>
                  <goal>java</goal>
                </goals>
                <phase>generate-sources</phase>
                <configuration>
                  <includeProjectDependencies>false</includeProjectDependencies>
                  <includePluginDependencies>true</includePluginDependencies>
                  <mainClass>org.tensorflow.op.generator.OpGenerator</mainClass>
                  <arguments>
                    <argument>${project.basedir}/src/gen/java</argument>
                    <argument>${project.basedir}/src/gen/resources/ops.pb</argument>
                  </arguments>
                </configuration>
              </execution>
              <execution>
                <!--
                  Clean the native build
                -->
                <id>clean-native-build</id>
                <goals>
                  <goal>exec</goal>
                </goals>
                <phase>clean</phase>
                <configuration>
                  <executable>/bin/bash</executable>
                  <arguments>
                    <argument>scripts/native_clean.sh</argument>
                  </arguments>
                  <environmentVariables>
                    <BAZEL_RUN>${native.build.bazel}</BAZEL_RUN>
                  </environmentVariables>
                </configuration>
              </execution>
            </executions>
            <dependencies>
              <dependency>
                <groupId>org.tensorflow</groupId>
                <artifactId>tensorflow-core-generator</artifactId>
                <version>${project.version}</version>
              </dependency>
            </dependencies>
          </plugin>

          <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <executions>
              <execution>
                <!--
                  Generate Ops classes
                    All classes found in the source path that are annotated with `@Operator` are processed
                    to be added as an endpoint to one of the generated Ops class
                -->
                <id>default-compile</id>
                <configuration>
                  <annotationProcessors>
                    <annotationProcessor>org.tensorflow.processor.operator.OperatorProcessor</annotationProcessor>
                  </annotationProcessors>
                  <annotationProcessorPaths>
                    <annotationProcessorPath>
                      <groupId>org.tensorflow</groupId>
                      <artifactId>tensorflow-core-generator</artifactId>
                      <version>${project.version}</version>
                    </annotationProcessorPath>
                  </annotationProcessorPaths>
                  <!-- Important: Cannot be ${project.basedir}/src/gen/java or wherever the ops are -->
                  <generatedSourcesDirectory>${project.basedir}/src/gen/annotations</generatedSourcesDirectory>
                </configuration>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
    </profile>

    <profile>
      <!--
        Deploying Profile
          Avoid deploying snapshots since all artifacts must have the same timestamp to avoid
          issues when using Gradle.
      -->
      <id>deploying</id>
      <properties>
        <maven.deploy.skip>true</maven.deploy.skip>
      </properties>
    </profile>
  </profiles>

  <build>
    <plugins>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>build-helper-maven-plugin</artifactId>
        <version>3.4.0</version>
        <executions>
          <execution>
            <!--
              Add generated classes to the source path
                These are classes generated by the javacpp-plugin and the native build. They include TensorFlow operations
                wrappers, C API Java bindings and TensorFlow protos.
            -->
            <id>add-gen-sources</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>add-source</goal>
            </goals>
            <configuration>
              <sources>
                <source>${project.basedir}/src/gen/java</source>
                <source>${project.basedir}/src/gen/annotations</source>
              </sources>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <artifactId>maven-resources-plugin</artifactId>
        <version>3.3.1</version>
        <executions>
          <execution>
            <!--
              Copies main resources straight to the main outputs
                Important: Use a phase before "generate-sources" like "initialize" or Maven may move
                its execution after JavaCPP when profiles override its configuration
            -->
            <id>copy-resources</id>
            <phase>initialize</phase>
            <goals>
              <goal>resources</goal>
            </goals>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.11.0</version>
        <executions>
          <execution>
            <!--
              Compile JavaCPP presets
                This must be done prematurely, before the generate-sources phase, since the javacpp-plugin
                will parse the compiled presets for generating Java bindings to the native APIs
                Important: Use a phase before "generate-sources" like "initialize" or Maven may move
                its execution after JavaCPP when profiles override its configuration
            -->
            <id>javacpp-compiler</id>
            <phase>initialize</phase>
            <goals>
              <goal>compile</goal>
            </goals>
            <configuration>
              <includes>
                <include>org/tensorflow/internal/c_api/presets/*.java</include>
              </includes>
              <!-- Build on Java8 to prevent the plugin to automatically include module-info.java (excluding it won't work) -->
              <release>8</release>
              <compilerArgs combine.self="override"></compilerArgs>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>3.1.0</version>
        <executions>
          <execution>
            <!--
              Download TensorFlow native libraries
                This will download the official Python wheel distribution for the active platform, and extract the `tensorflow_cc` library
                from it so that we can generate the JavaCPP API bindings and distribute it as a JAR. This will be executed only
                when not building a full native build.
            -->
            <id>native-download</id>
            <phase>initialize</phase>
            <goals>
              <goal>exec</goal>
            </goals>
            <configuration>
              <skip>${native.download.skip}</skip> <!-- skipped when full native build is enabled -->
              <executable>/bin/bash</executable>
              <arguments>
                <argument>scripts/native_download.sh</argument>
                <argument>${native.wheel.url}</argument>
                <argument>${native.download.folder}</argument>
                <argument>${os.name}</argument>
              </arguments>
              <workingDirectory>${project.basedir}</workingDirectory>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <groupId>org.bytedeco</groupId>
        <artifactId>javacpp</artifactId>
        <version>${javacpp.version}</version>
        <configuration>
          <properties>${javacpp.platform.properties}</properties>
          <propertyKeysAndValues>
            <property>
              <name>platform.root</name>
              <value>${javacpp.platform.root}</value>
            </property>
            <property>
              <name>platform.compiler</name>
              <value>${javacpp.platform.compiler}</value>
            </property>
            <property>
              <name>platform.extension</name>
              <value>${javacpp.platform.extension}</value>
            </property>
          </propertyKeysAndValues>
          <classPath>${project.build.outputDirectory}</classPath>
          <includePaths>
            <includePath>${project.basedir}/</includePath>
            <includePath>${project.basedir}/target/native-download/tensorflow/include/</includePath>
            <includePath>${project.basedir}/target/classes/org/tensorflow/internal/c_api/include/</includePath>
            <!-- additional include paths in case of a full native build -->
            <includePath>${project.basedir}/bazel-${project.artifactId}/external/org_tensorflow/</includePath>
            <includePath>${project.basedir}/bazel-bin/external/org_tensorflow/</includePath>
            <includePath>${project.basedir}/bazel-${project.artifactId}/external/com_google_absl/</includePath>
            <includePath>${project.basedir}/bazel-${project.artifactId}/external/eigen_archive/</includePath>
            <includePath>${project.basedir}/bazel-${project.artifactId}/external/com_google_protobuf/src/</includePath>
          </includePaths>
          <linkPaths>
            <!-- additional link paths in case of a full native build -->
            <linkPath>${project.basedir}/bazel-bin/external/llvm_openmp/</linkPath>
            <linkPath>${project.basedir}/bazel-bin/external/org_tensorflow/tensorflow/</linkPath>
          </linkPaths>
          <resourcePaths>
            <resourcePath>${project.basedir}/../../</resourcePath>
          </resourcePaths>
        </configuration>
        <executions>
          <!--
            Validates the configuration of the JavaCPP plugin
          -->
          <execution>
            <id>javacpp-validate</id>
            <phase>validate</phase>
            <goals>
              <goal>build</goal>
            </goals>
          </execution>
          <execution>
            <!--
              Generate TensorFlow C API binding sources
                The plugin will parse the pre-compiled TensorFlow C API presets and generate
                source classes for calling this API directly in Java.
            -->
            <id>javacpp-parser</id>
            <phase>generate-sources</phase>
            <goals>
              <goal>parse</goal>
            </goals>
            <configuration>
              <skip>${javacpp.parser.skip}</skip>
              <outputDirectory>${project.basedir}/src/gen/java</outputDirectory>
              <classOrPackageName>org.tensorflow.internal.c_api.presets.*</classOrPackageName>
            </configuration>
          </execution>
          <execution>
            <!--
            Compile JNI native code from this project
              This code is used to call the TensorFlow C API right now but should be eventually
              replaced by the usage of JavaCPP generated bindings
            -->
            <id>javacpp-compiler</id>
            <phase>process-classes</phase>
            <goals>
              <goal>build</goal>
            </goals>
            <configuration>
              <outputDirectory>${native.target.folder}/</outputDirectory>
              <skip>${javacpp.compiler.skip}</skip>
              <classOrPackageName>org.tensorflow.internal.c_api.**</classOrPackageName>
              <copyLibs>true</copyLibs>
              <copyResources>true</copyResources>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>com.google.protobuf</groupId>
            <artifactId>protobuf-java</artifactId>
            <version>${protobuf.version}</version>
          </dependency>
        </dependencies>
      </plugin>

      <plugin>
        <artifactId>maven-jar-plugin</artifactId>
        <version>3.3.0</version>
        <configuration>
          <archive>
            <manifestEntries>
              <Automatic-Module-Name>org.tensorflow.core</Automatic-Module-Name>
            </manifestEntries>
          </archive>
        </configuration>
        <executions>
          <execution>
            <!--
              Create the native artifact
                This artifact will contain only native libraries compiled by the javacpp-plugin,
                and will be classified under the active platform (OS, arch, extension...)
            -->
            <id>native-jar</id>
            <phase>package</phase>
            <goals>
              <goal>jar</goal>
            </goals>
            <configuration>
              <classifier>${native.classifier}</classifier>
              <skipIfEmpty>true</skipIfEmpty>
              <includes>
                <!-- In case of successive builds for multiple platforms without cleaning, ensures
                     we only include files for this platform. -->
                <include>org/tensorflow/internal/c_api/${native.classifier}/</include>
              </includes>
              <classesDirectory>${project.build.directory}/native</classesDirectory>
              <excludes>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.exp</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.lib</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*.obj</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*mklml*</exclude>
                <exclude>org/tensorflow/internal/c_api/${native.classifier}/*msvcr120*</exclude>
              </excludes>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <artifactId>maven-surefire-plugin</artifactId>
        <executions>
          <execution>
            <!--
              Run the tests after packaging the artifacts
                This is required as most of our unit tests are in fact integration tests that should
                be executed in a TensorFlow runtime environment.
            -->
            <id>default-test</id>
            <phase>integration-test</phase>
            <goals>
              <goal>test</goal>
            </goals>
            <configuration>
              <additionalClasspathElements>
                <additionalClasspathElement>${project.build.directory}/${project.artifactId}-${project.version}-${native.classifier}.jar</additionalClasspathElement>
                <additionalClasspathElement>${project.build.directory}/native/</additionalClasspathElement>
              </additionalClasspathElements>
            </configuration>
          </execution>
        </executions>
      </plugin>

      <plugin>
        <artifactId>maven-source-plugin</artifactId>
        <version>3.3.0</version>
        <executions>
          <execution>
            <id>attach-sources</id>
            <phase>leave-disabled-to-not-generate-sources-twice-on-release</phase>
          </execution>
          <execution>
            <id>attach-source</id>
            <goals>
              <goal>jar-no-fork</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-javadoc-plugin</artifactId>
        <version>3.6.0</version>
        <executions>
          <execution>
            <id>attach-javadocs</id>
            <goals>
              <goal>jar</goal>
            </goals>
            <configuration>
              <failOnError>false</failOnError>
              <minmemory>256m</minmemory>
              <maxmemory>2048m</maxmemory>
              <links>
                <link>http://bytedeco.org/javacpp/apidocs</link>
              </links>
            </configuration>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <version>3.6.0</version>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
