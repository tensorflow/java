// Targeted by JavaCPP version 1.5.10: DO NOT EDIT THIS FILE

package org.tensorflow.internal.c_api.global;

import org.tensorflow.internal.c_api.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

public class tensorflow extends org.tensorflow.internal.c_api.presets.tensorflow {
    static { Loader.load(); }

// Parsed from tsl/platform/ctstring_internal.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_TSL_PLATFORM_CTSTRING_INTERNAL_H_
// #define TENSORFLOW_TSL_PLATFORM_CTSTRING_INTERNAL_H_

// #include <limits.h>
// #include <stdint.h>
// #include <stdlib.h>
// #include <string.h>

// #if (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) &&
//      __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) ||
//     defined(_WIN32)
public static final int TF_TSTRING_LITTLE_ENDIAN = 1;
// #elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) &&
//     __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
// #else
// #error "Unable to detect endianness."
// #endif

// #if defined(__clang__) ||
//     (defined(__GNUC__) &&
//      ((__GNUC__ == 4 && __GNUC_MINOR__ >= 8) || __GNUC__ >= 5))
public static native @Cast("uint32_t") int TF_swap32(@Cast("uint32_t") int host_int);

// #elif defined(_MSC_VER)

// #elif defined(__APPLE__)

// #else
// #endif

// #if TF_TSTRING_LITTLE_ENDIAN
// #define TF_le32toh(x) x
// #else  // TF_TSTRING_LITTLE_ENDIAN
// #endif  // TF_TSTRING_LITTLE_ENDIAN

public static native @Cast("size_t") long TF_align16(@Cast("size_t") long i);

public static native @Cast("size_t") long TF_max(@Cast("size_t") long a, @Cast("size_t") long b);
public static native @Cast("size_t") long TF_min(@Cast("size_t") long a, @Cast("size_t") long b);

/** enum TF_TString_Type */
public static final int  // NOLINT
  TF_TSTR_SMALL = 0x00,
  TF_TSTR_LARGE = 0x01,
  TF_TSTR_OFFSET = 0x02,
  TF_TSTR_VIEW = 0x03,
  TF_TSTR_TYPE_MASK = 0x03;
// Targeting ../TF_TString_Large.java


// Targeting ../TF_TString_Offset.java


// Targeting ../TF_TString_View.java


// Targeting ../TF_TString_Raw.java


// Targeting ../TF_TString_Union.java



/** enum  */

public static native @MemberGetter int TF_TString_SmallCapacity();
public static final int
  TF_TString_SmallCapacity = TF_TString_SmallCapacity();
// Targeting ../TF_TString_Small.java


// Targeting ../TF_TString.java



// TODO(dero): Fix for OSS, and add C only build test.
// _Static_assert(CHAR_BIT == 8);
// _Static_assert(sizeof(TF_TString) == 24);

public static native @Cast("TF_TString_Type") int TF_TString_GetType(@Const TF_TString str);

// XXX(dero): For the big-endian case, this function could potentially be more
// performant and readable by always storing the string size as little-endian
// and always byte-swapping on big endian, resulting in a simple 'bswap'+'shr'
// (for architectures that have a bswap op).
public static native @Cast("size_t") long TF_TString_ToActualSizeT(@Cast("size_t") long size);

public static native @Cast("size_t") long TF_TString_ToInternalSizeT(@Cast("size_t") long size,
                                                @Cast("TF_TString_Type") int type);

public static native void TF_TString_Init(TF_TString str);

public static native void TF_TString_Dealloc(TF_TString str);

public static native @Cast("size_t") long TF_TString_GetSize(@Const TF_TString str);

public static native @Cast("size_t") long TF_TString_GetCapacity(@Const TF_TString str);

public static native @Cast("const char*") BytePointer TF_TString_GetDataPointer(@Const TF_TString str);

public static native @Cast("char*") BytePointer TF_TString_ResizeUninitialized(TF_TString str,
                                                   @Cast("size_t") long new_size);

public static native @Cast("char*") BytePointer TF_TString_GetMutableDataPointer(TF_TString str);

public static native void TF_TString_Reserve(TF_TString str, @Cast("size_t") long new_cap);

public static native void TF_TString_ReserveAmortized(TF_TString str,
                                               @Cast("size_t") long new_cap);

public static native @Cast("char*") BytePointer TF_TString_Resize(TF_TString str, @Cast("size_t") long new_size,
                                      @Cast("char") byte c);

public static native void TF_TString_AssignView(TF_TString dst, @Cast("const char*") BytePointer src,
                                         @Cast("size_t") long size);
public static native void TF_TString_AssignView(TF_TString dst, String src,
                                         @Cast("size_t") long size);

public static native void TF_TString_AppendN(TF_TString dst, @Cast("const char*") BytePointer src,
                                      @Cast("size_t") long src_size);
public static native void TF_TString_AppendN(TF_TString dst, String src,
                                      @Cast("size_t") long src_size);

public static native void TF_TString_Append(TF_TString dst, @Const TF_TString src);

public static native void TF_TString_Copy(TF_TString dst, @Cast("const char*") BytePointer src,
                                   @Cast("size_t") long size);
public static native void TF_TString_Copy(TF_TString dst, String src,
                                   @Cast("size_t") long size);

public static native void TF_TString_Assign(TF_TString dst, @Const TF_TString src);

public static native void TF_TString_Move(TF_TString dst, TF_TString src);

// #endif  // TENSORFLOW_TSL_PLATFORM_CTSTRING_INTERNAL_H_


// Parsed from tsl/platform/ctstring.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_TSL_PLATFORM_CTSTRING_H_
// #define TENSORFLOW_TSL_PLATFORM_CTSTRING_H_

// #include <stdint.h>
// #include <stdlib.h>

// #include "tsl/platform/ctstring_internal.h"

// Initialize a new tstring.  This must be called before using any function
// below.
// Deallocate a tstring.

// Resizes `str' to `new_size'.  This function will appropriately grow or shrink
// the string buffer to fit a `new_size' string.  Grown regions of the string
// will be initialized with `c'.
// Similar to TF_TString_Resize, except the newly allocated regions will remain
// uninitialized.  This is useful if you plan on overwriting the newly grown
// regions immediately after allocation; doing so will elide a superfluous
// initialization of the new buffer.
// Reserves a string buffer with a capacity of at least `new_cap'.
// Reserve will not change the size, or the contents of the existing
// string.  This is useful if you have a rough idea of `str's upperbound in
// size, and want to avoid allocations as you append to `str'. It should not be
// considered safe to write in the region between size and capacity; explicitly
// resize before doing so.
// Similar to TF_TString_Reserve, except that we ensure amortized growth, i.e.
// that we grow the capacity by at least a constant factor >1.

// Returns the size of the string.
// Returns the capacity of the string buffer.  It should not be considered safe
// to write in the region between size and capacity---call Resize or
// ResizeUninitialized before doing so.
// Returns the underlying type of the tstring:
// TF_TSTR_SMALL:
//    Small string optimization; the contents of strings
//    less than 22-bytes are stored in the TF_TString struct. This avoids any
//    heap allocations.
// TF_TSTR_LARGE:
//    Heap allocated string.
// TF_TSTR_OFFSET: (currently unused)
//    An offset defined string.  The string buffer begins at an internally
//    defined little-endian offset from `str'; i.e. GetDataPointer() = str +
//    offset.  This type is useful for memory mapping or reading string tensors
//    directly from file, without the need to deserialize the data.  For
//    security reasons, it is imperative that OFFSET based string tensors are
//    validated before use, or are from a trusted source.
// TF_TSTR_VIEW:
//    A view into an unowned character string.
//
// NOTE:
//    VIEW and OFFSET types are immutable, so any modifcation via Append,
//    AppendN, or GetMutableDataPointer of a VIEW/OFFSET based tstring will
//    result in a conversion to an owned type (SMALL/LARGE).

// Returns a const char pointer to the start of the underlying string. The
// underlying character buffer may not be null-terminated.
// Returns a char pointer to a mutable representation of the underlying string.
// In the case of VIEW and OFFSET types, `src' is converted to an owned type
// (SMALL/LARGE).  The underlying character buffer may not be null-terminated.

// Sets `dst' as a VIEW type to `src'.  `dst' will not take ownership of `src'.
// It is the user's responsibility to ensure that the lifetime of `src' exceeds
// `dst'.  Any mutations to `dst' via Append, AppendN, or GetMutableDataPointer,
// will result in a copy into an owned SMALL or LARGE type, and will not modify
// `src'.

// Appends `src' onto `dst'.  If `dst' is a VIEW or OFFSET type, it will first
// be converted to an owned LARGE or SMALL type.  `dst' should not point to
// memory owned by `src'.

// Copy/Move/Assign semantics
//
//        | src     | dst          | complexity
// Copy   | *       |  SMALL/LARGE | fixed/O(size)
// Assign | SMALL   |  SMALL       | fixed
// Assign | OFFSET  |  VIEW        | fixed
// Assign | VIEW    |  VIEW        | fixed
// Assign | LARGE   |  LARGE       | O(size)
// Move   | *       |  same as src | fixed

// Copies `src' to `dst'. `dst' will be an owned type (SMALL/LARGE). `src'
// should not point to memory owned by `dst'.
// Assigns a `src' tstring to `dst'.  An OFFSET `src' type will yield a `VIEW'
// `dst'.  LARGE `src' types will be copied to a new buffer; all other `src'
// types will incur a fixed cost.
// Moves a `src' tstring to `dst'.  Moving a LARGE `src' to `dst' will result in
// a valid but unspecified `src'.  This function incurs a fixed cost for all
// inputs.

// #endif  // TENSORFLOW_TSL_PLATFORM_CTSTRING_H_


// Parsed from tsl/c/tsl_status.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_TSL_C_TSL_STATUS_H_
// #define TENSORFLOW_TSL_C_TSL_STATUS_H_

// #ifdef __cplusplus
// #endif

// --------------------------------------------------------------------------
// TSL_Code holds an error code.  The enum values here are identical to
// corresponding values in error_codes.proto.
/** enum TSL_Code */
public static final int
  TSL_OK = 0,
  TSL_CANCELLED = 1,
  TSL_UNKNOWN = 2,
  TSL_INVALID_ARGUMENT = 3,
  TSL_DEADLINE_EXCEEDED = 4,
  TSL_NOT_FOUND = 5,
  TSL_ALREADY_EXISTS = 6,
  TSL_PERMISSION_DENIED = 7,
  TSL_UNAUTHENTICATED = 16,
  TSL_RESOURCE_EXHAUSTED = 8,
  TSL_FAILED_PRECONDITION = 9,
  TSL_ABORTED = 10,
  TSL_OUT_OF_RANGE = 11,
  TSL_UNIMPLEMENTED = 12,
  TSL_INTERNAL = 13,
  TSL_UNAVAILABLE = 14,
  TSL_DATA_LOSS = 15;

// --------------------------------------------------------------------------

// Return a new status object.

// Delete a previously created status object.

// Record <code, msg> in *s.  Any previous information is lost.
// A common use is to clear a status: TSL_SetStatus(s, TSL_OK, "");

// Record <key, value> as a payload in *s. The previous payload having the
// same key (if any) is overwritten. Payload will not be added if the Status
// is OK.

// Iterates over the stored payloads and calls the `visitor(key, value)`
// callable for each one. `key` and `value` is only usable during the callback.
// `capture` will be passed to the callback without modification.

// Convert from an I/O error code (e.g., errno) to a TSL_Status value.
// Any previous information is lost. Prefer to use this instead of TSL_SetStatus
// when the error comes from I/O operations.

// Return the code record in *s.

// Return a pointer to the (null-terminated) error message in *s.  The
// return value points to memory that is only usable until the next
// mutation to *s.  Always returns an empty string if TSL_GetCode(s) is
// TSL_OK.

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_TSL_C_TSL_STATUS_H_


// Parsed from tensorflow/c/c_api_macros.h

/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_C_API_MACROS_H_
// #define TENSORFLOW_C_C_API_MACROS_H_

// #ifdef SWIG
// #define TF_CAPI_EXPORT
// #else
// #if defined(_WIN32)
// #ifdef TF_COMPILE_LIBRARY
// #define TF_CAPI_EXPORT __declspec(dllexport)
// #else
// #define TF_CAPI_EXPORT __declspec(dllimport)
// #endif  // TF_COMPILE_LIBRARY
// #else
// #ifdef TF_CAPI_WEAK
// #define TF_CAPI_EXPORT
//   __attribute__((visibility("default"))) __attribute((weak))
// #else
// #define TF_CAPI_EXPORT __attribute__((visibility("default")))
// #endif  // TF_CAPI_WEAK
// #endif  // _WIN32
// #endif  // SWIG

// TF_Bool is the C API typedef for unsigned char, while TF_BOOL is
// the datatype for boolean tensors.
// #ifndef TF_Bool
// #define TF_Bool unsigned char
// #endif  // TF_Bool

// Macro used to calculate struct size for maintaining ABI stability across
// different struct implementations.
// #ifndef TF_OFFSET_OF_END
// #define TF_OFFSET_OF_END(TYPE, MEMBER)
//   (offsetof(TYPE, MEMBER) + sizeof(((TYPE *)0)->MEMBER))
// #endif  // TF_OFFSET_OF_END

// #endif  // TENSORFLOW_C_C_API_MACROS_H_


// Parsed from tensorflow/c/tf_datatype.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_TF_DATATYPE_H_
// #define TENSORFLOW_C_TF_DATATYPE_H_

// #include <stddef.h>

// #include "tensorflow/c/c_api_macros.h"

// #ifdef __cplusplus
// #endif

// --------------------------------------------------------------------------
// TF_DataType holds the type for a scalar value.  E.g., one slot in a tensor.
// The enum values here are identical to corresponding values in types.proto.
/** enum TF_DataType */
public static final int
  TF_FLOAT = 1,
  TF_DOUBLE = 2,
  TF_INT32 = 3,  // Int32 tensors are always in 'host' memory.
  TF_UINT8 = 4,
  TF_INT16 = 5,
  TF_INT8 = 6,
  TF_STRING = 7,
  TF_COMPLEX64 = 8,  // Single-precision complex
  TF_COMPLEX = 8,    // Old identifier kept for API backwards compatibility
  TF_INT64 = 9,
  TF_BOOL = 10,
  TF_QINT8 = 11,     // Quantized int8
  TF_QUINT8 = 12,    // Quantized uint8
  TF_QINT32 = 13,    // Quantized int32
  TF_BFLOAT16 = 14,  // Float32 truncated to 16 bits.
  TF_QINT16 = 15,    // Quantized int16
  TF_QUINT16 = 16,   // Quantized uint16
  TF_UINT16 = 17,
  TF_COMPLEX128 = 18,  // Double-precision complex
  TF_HALF = 19,
  TF_RESOURCE = 20,
  TF_VARIANT = 21,
  TF_UINT32 = 22,
  TF_UINT64 = 23,
  TF_FLOAT8_E5M2 = 24,    // 5 exponent bits, 2 mantissa bits.
  TF_FLOAT8_E4M3FN = 25,  // 4 exponent bits, 3 mantissa bits, finite-only, with
                          // 2 NaNs (0bS1111111).
  // TODO - b/299182407: Leaving room for remaining float8 types.
  // TF_FLOAT8_E4M3FNUZ = 26,
  // TF_FLOAT8_E4M3B11FNUZ = 27,
  // TF_FLOAT8_E5M2FNUZ = 28,
  TF_INT4 = 29,
  TF_UINT4 = 30;

// TF_DataTypeSize returns the sizeof() for the underlying type corresponding
// to the given TF_DataType enum value. Returns 0 for variable length types
// (eg. TF_STRING) or on failure.
public static native @Cast("size_t") long TF_DataTypeSize(@Cast("TF_DataType") int dt);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_DATATYPE_H_


// Parsed from tensorflow/c/tf_status.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_TF_STATUS_H_
// #define TENSORFLOW_C_TF_STATUS_H_

// #include "tensorflow/c/c_api_macros.h"
// #include "tsl/c/tsl_status.h"

// #ifdef __cplusplus
// Targeting ../TF_Status.java



// --------------------------------------------------------------------------
// TF_Code holds an error code.  The enum values here are identical to
// corresponding values in error_codes.proto.
// LINT.IfChange
public static final int TF_OK = TSL_OK;
public static final int TF_CANCELLED = TSL_CANCELLED;
public static final int TF_UNKNOWN = TSL_UNKNOWN;
public static final int TF_INVALID_ARGUMENT = TSL_INVALID_ARGUMENT;
public static final int TF_DEADLINE_EXCEEDED = TSL_DEADLINE_EXCEEDED;
public static final int TF_NOT_FOUND = TSL_NOT_FOUND;
public static final int TF_ALREADY_EXISTS = TSL_ALREADY_EXISTS;
public static final int TF_PERMISSION_DENIED = TSL_PERMISSION_DENIED;
public static final int TF_UNAUTHENTICATED = TSL_UNAUTHENTICATED;
public static final int TF_RESOURCE_EXHAUSTED = TSL_RESOURCE_EXHAUSTED;
public static final int TF_FAILED_PRECONDITION = TSL_FAILED_PRECONDITION;
public static final int TF_ABORTED = TSL_ABORTED;
public static final int TF_OUT_OF_RANGE = TSL_OUT_OF_RANGE;
public static final int TF_UNIMPLEMENTED = TSL_UNIMPLEMENTED;
public static final int TF_INTERNAL = TSL_INTERNAL;
public static final int TF_UNAVAILABLE = TSL_UNAVAILABLE;
public static final int TF_DATA_LOSS = TSL_DATA_LOSS;
// LINT.ThenChange(//tensorflow/python/py_exception_registry_wrapper.cc)

// --------------------------------------------------------------------------

// Return a new status object.
public static native TF_Status TF_NewStatus();

// Delete a previously created status object.
public static native void TF_DeleteStatus(TF_Status arg0);

// Record <code, msg> in *s.  Any previous information is lost.
// A common use is to clear a status: TF_SetStatus(s, TF_OK, "");
public static native void TF_SetStatus(TF_Status s, @Cast("TF_Code") int code,
                                        @Cast("const char*") BytePointer msg);
public static native void TF_SetStatus(TF_Status s, @Cast("TF_Code") int code,
                                        String msg);

// Record <key, value> as a payload in *s. The previous payload having the
// same key (if any) is overwritten. Payload will not be added if the Status
// is OK.
public static native void TF_SetPayload(TF_Status s, @Cast("const char*") BytePointer key,
                                  @Cast("const char*") BytePointer value);
public static native void TF_SetPayload(TF_Status s, String key,
                                  String value);

// Iterates over the stored payloads and calls the `visitor(key, value)`
// callable for each one. `key` and `value` is only usable during the callback.
// `capture` will be passed to the callback without modification.
// #define TF_PayloadVisitor TSL_PayloadVisitor


// Convert from an I/O error code (e.g., errno) to a TF_Status value.
// Any previous information is lost. Prefer to use this instead of TF_SetStatus
// when the error comes from I/O operations.
public static native void TF_SetStatusFromIOError(TF_Status s, int error_code,
                                                   @Cast("const char*") BytePointer context);
public static native void TF_SetStatusFromIOError(TF_Status s, int error_code,
                                                   String context);

// Return the code record in *s.
public static native @Cast("TF_Code") int TF_GetCode(@Const TF_Status s);

// Return a pointer to the (null-terminated) error message in *s.  The
// return value points to memory that is only usable until the next
// mutation to *s.  Always returns an empty string if TF_GetCode(s) is
// TF_OK.
public static native @Cast("const char*") BytePointer TF_Message(@Const TF_Status s);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_STATUS_H_


// Parsed from tensorflow/c/tf_buffer.h

/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_TF_BUFFER_H_
// #define TENSORFLOW_C_TF_BUFFER_H_

// #include <stddef.h>

// #include "tensorflow/c/c_api_macros.h"

// #ifdef __cplusplus
// Targeting ../TF_Buffer.java



// Makes a copy of the input and sets an appropriate deallocator.  Useful for
// passing in read-only, input protobufs.
public static native TF_Buffer TF_NewBufferFromString(@Const Pointer proto,
                                                        @Cast("size_t") long proto_len);

// Useful for passing *out* a protobuf.
public static native TF_Buffer TF_NewBuffer();

public static native void TF_DeleteBuffer(TF_Buffer arg0);

public static native @ByVal TF_Buffer TF_GetBuffer(TF_Buffer buffer);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_BUFFER_H_


// Parsed from tensorflow/c/tf_tensor.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_TF_TENSOR_H_
// #define TENSORFLOW_C_TF_TENSOR_H_

// #include <stdbool.h>
// #include <stdint.h>

// #include "tensorflow/c/c_api_macros.h"
// #include "tensorflow/c/tf_datatype.h"
// #include "tensorflow/c/tf_status.h"

// #ifdef __cplusplus
// Targeting ../TF_AllocatorAttributes.java



public static native @MemberGetter int TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE();
public static final int TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE = TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE();
// Targeting ../TF_Tensor.java


// Targeting ../Deallocator_Pointer_long_Pointer.java


public static native TF_Tensor TF_NewTensor(
    @Cast("TF_DataType") int arg0, @Cast("const int64_t*") LongPointer dims, int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg);
public static native TF_Tensor TF_NewTensor(
    @Cast("TF_DataType") int arg0, @Cast("const int64_t*") LongBuffer dims, int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg);
public static native TF_Tensor TF_NewTensor(
    @Cast("TF_DataType") int arg0, @Cast("const int64_t*") long[] dims, int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg);

// Allocate and return a new Tensor.
//
// This function is an alternative to TF_NewTensor and should be used when
// memory is allocated to pass the Tensor to the C API. The allocated memory
// satisfies TensorFlow's memory alignment preferences and should be preferred
// over calling malloc and free.
//
// The caller must set the Tensor values by writing them to the pointer returned
// by TF_TensorData with length TF_TensorByteSize.
public static native TF_Tensor TF_AllocateTensor(@Cast("TF_DataType") int arg0,
                                                   @Cast("const int64_t*") LongPointer dims,
                                                   int num_dims, @Cast("size_t") long len);
public static native TF_Tensor TF_AllocateTensor(@Cast("TF_DataType") int arg0,
                                                   @Cast("const int64_t*") LongBuffer dims,
                                                   int num_dims, @Cast("size_t") long len);
public static native TF_Tensor TF_AllocateTensor(@Cast("TF_DataType") int arg0,
                                                   @Cast("const int64_t*") long[] dims,
                                                   int num_dims, @Cast("size_t") long len);

// Deletes `tensor` and returns a new TF_Tensor with the same content if
// possible. Returns nullptr and leaves `tensor` untouched if not.
public static native TF_Tensor TF_TensorMaybeMove(TF_Tensor tensor);

// Destroy a tensor.
public static native void TF_DeleteTensor(TF_Tensor arg0);

// Return the type of a tensor element.
public static native @Cast("TF_DataType") int TF_TensorType(@Const TF_Tensor arg0);

// Set a new shape for the Tensor.
public static native void TF_SetShape(TF_Tensor tensor, @Cast("const int64_t*") LongPointer dims,
                                       int num_dims);
public static native void TF_SetShape(TF_Tensor tensor, @Cast("const int64_t*") LongBuffer dims,
                                       int num_dims);
public static native void TF_SetShape(TF_Tensor tensor, @Cast("const int64_t*") long[] dims,
                                       int num_dims);

// Return the number of dimensions that the tensor has.
public static native int TF_NumDims(@Const TF_Tensor arg0);

// Return the length of the tensor in the "dim_index" dimension.
// REQUIRES: 0 <= dim_index < TF_NumDims(tensor)
public static native @Cast("int64_t") long TF_Dim(@Const TF_Tensor tensor, int dim_index);

// Return the size of the underlying data in bytes.
public static native @Cast("size_t") long TF_TensorByteSize(@Const TF_Tensor arg0);

// Return a pointer to the underlying data buffer.
public static native Pointer TF_TensorData(@Const TF_Tensor arg0);

// Returns the number of elements in the tensor.
public static native @Cast("int64_t") long TF_TensorElementCount(@Const TF_Tensor tensor);

// Copy the internal data representation of `from` to `to`. `new_dims` and
// `num_new_dims` specify the new shape of the `to` tensor, `type` specifies its
// data type. On success, *status is set to TF_OK and the two tensors share the
// same data buffer.
//
// This call requires that the `from` tensor and the given type and shape (dims
// and num_dims) are "compatible" (i.e. they occupy the same number of bytes).
// Specifically, given from_type_size = TF_DataTypeSize(TF_TensorType(from)):
//
// ShapeElementCount(dims, num_dims) * TF_DataTypeSize(type)
//
// must equal
//
// TF_TensorElementCount(from) * from_type_size
//
// where TF_ShapeElementCount would be the number of elements in a tensor with
// the given shape.
//
// In addition, this function requires:
//   * TF_DataTypeSize(TF_TensorType(from)) != 0
//   * TF_DataTypeSize(type) != 0
//
// If any of the requirements are not met, *status is set to
// TF_INVALID_ARGUMENT.
public static native void TF_TensorBitcastFrom(@Const TF_Tensor from,
                                                @Cast("TF_DataType") int type, TF_Tensor to,
                                                @Cast("const int64_t*") LongPointer new_dims,
                                                int num_new_dims,
                                                TF_Status status);
public static native void TF_TensorBitcastFrom(@Const TF_Tensor from,
                                                @Cast("TF_DataType") int type, TF_Tensor to,
                                                @Cast("const int64_t*") LongBuffer new_dims,
                                                int num_new_dims,
                                                TF_Status status);
public static native void TF_TensorBitcastFrom(@Const TF_Tensor from,
                                                @Cast("TF_DataType") int type, TF_Tensor to,
                                                @Cast("const int64_t*") long[] new_dims,
                                                int num_new_dims,
                                                TF_Status status);

// Returns bool iff this tensor is aligned.
public static native @Cast("bool") boolean TF_TensorIsAligned(@Const TF_Tensor arg0);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_TENSOR_H_


// Parsed from tensorflow/c/tf_attrtype.h

/* Copyright 2019 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// #ifndef TENSORFLOW_C_TF_ATTRTYPE_H_
// #define TENSORFLOW_C_TF_ATTRTYPE_H_

// #ifdef __cplusplus
// #endif

// TF_AttrType describes the type of the value of an attribute on an operation.
/** enum TF_AttrType */
public static final int
  TF_ATTR_STRING = 0,
  TF_ATTR_INT = 1,
  TF_ATTR_FLOAT = 2,
  TF_ATTR_BOOL = 3,
  TF_ATTR_TYPE = 4,
  TF_ATTR_SHAPE = 5,
  TF_ATTR_TENSOR = 6,
  TF_ATTR_PLACEHOLDER = 7,
  TF_ATTR_FUNC = 8;

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_ATTRTYPE_H_


// Parsed from tensorflow/c/c_api.h

/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_C_API_H_
// #define TENSORFLOW_C_C_API_H_

// #include <stddef.h>
// #include <stdint.h>

// #include "tensorflow/c/c_api_macros.h"
// #include "tensorflow/c/tf_attrtype.h"
// #include "tensorflow/c/tf_buffer.h"
// #include "tensorflow/c/tf_datatype.h"
// #include "tensorflow/c/tf_status.h"
// #include "tensorflow/c/tf_tensor.h"
// #include "tensorflow/c/tf_tstring.h"

// --------------------------------------------------------------------------
// C API for TensorFlow.
//
// The API leans towards simplicity and uniformity instead of convenience
// since most usage will be by language specific wrappers.
//
// Conventions:
// * We use the prefix TF_ for everything in the API.
// * Objects are always passed around as pointers to opaque structs
//   and these structs are allocated/deallocated via the API.
// * TF_Status holds error information.  It is an object type
//   and therefore is passed around as a pointer to an opaque
//   struct as mentioned above.
// * Every call that has a TF_Status* argument clears it on success
//   and fills it with error info on failure.
// * unsigned char is used for booleans (instead of the 'bool' type).
//   In C++ bool is a keyword while in C99 bool is a macro defined
//   in stdbool.h. It is possible for the two to be inconsistent.
//   For example, neither the C99 nor the C++11 standard force a byte
//   size on the bool type, so the macro defined in stdbool.h could
//   be inconsistent with the bool keyword in C++. Thus, the use
//   of stdbool.h is avoided and unsigned char is used instead.
// * size_t is used to represent byte sizes of objects that are
//   materialized in the address space of the calling process.
// * int is used as an index into arrays.
// * Deletion functions are safe to call on nullptr.
//
// Questions left to address:
// * Might at some point need a way for callers to provide their own Env.
// * Maybe add TF_TensorShape that encapsulates dimension info.
//
// Design decisions made:
// * Backing store for tensor memory has an associated deallocation
//   function.  This deallocation function will point to client code
//   for tensors populated by the client.  So the client can do things
//   like shadowing a numpy array.
// * We do not provide TF_OK since it is not strictly necessary and we
//   are not optimizing for convenience.
// * We make assumption that one session has one graph.  This should be
//   fine since we have the ability to run sub-graphs.
// * We could allow NULL for some arguments (e.g., NULL options arg).
//   However since convenience is not a primary goal, we don't do this.
// * Devices are not in this API.  Instead, they are created/used internally
//   and the API just provides high level controls over the number of
//   devices of each type.

// #ifdef __cplusplus
// #endif

// --------------------------------------------------------------------------
// TF_Version returns a string describing version information of the
// TensorFlow library. TensorFlow uses semantic versioning.
public static native @Cast("const char*") BytePointer TF_Version();

// Parsing a serialized TensorProto into a TF_Tensor.
public static native void TF_TensorFromProto(@Const TF_Buffer from,
                                              TF_Tensor to, TF_Status status);
// Targeting ../TF_StringView.java


// Targeting ../TF_SessionOptions.java



// Return a new options object.
public static native TF_SessionOptions TF_NewSessionOptions();

// Set the target in TF_SessionOptions.options.
// target can be empty, a single entry, or a comma separated list of entries.
// Each entry is in one of the following formats :
// "local"
// ip:port
// host:port
public static native void TF_SetTarget(TF_SessionOptions options,
                                        @Cast("const char*") BytePointer target);
public static native void TF_SetTarget(TF_SessionOptions options,
                                        String target);

// Set the config in TF_SessionOptions.options.
// config should be a serialized tensorflow.ConfigProto proto.
// If config was not parsed successfully as a ConfigProto, record the
// error information in *status.
public static native void TF_SetConfig(TF_SessionOptions options,
                                        @Const Pointer proto, @Cast("size_t") long proto_len,
                                        TF_Status status);

// Destroy an options object.
public static native void TF_DeleteSessionOptions(TF_SessionOptions arg0);
// Targeting ../TF_Graph.java



// Return a new graph object.
public static native TF_Graph TF_NewGraph();

// Destroy an options object. Graph will be deleted once no more
// TFSession's are referencing it.
public static native void TF_DeleteGraph(TF_Graph arg0);
// Targeting ../TF_OperationDescription.java


// Targeting ../TF_Operation.java


// Targeting ../TF_Input.java


// Targeting ../TF_Output.java


// Targeting ../TF_Function.java


// Targeting ../TF_FunctionOptions.java



// Sets the shape of the Tensor referenced by `output` in `graph` to
// the shape described by `dims` and `num_dims`.
//
// If the number of dimensions is unknown, `num_dims` must be set to
// -1 and `dims` can be null. If a dimension is unknown, the
// corresponding entry in the `dims` array must be -1.
//
// This does not overwrite the existing shape associated with `output`,
// but merges the input shape with the existing shape.  For example,
// setting a shape of [-1, 2] with an existing shape [2, -1] would set
// a final shape of [2, 2] based on shape merging semantics.
//
// Returns an error into `status` if:
//   * `output` is not in `graph`.
//   * An invalid shape is being set (e.g., the shape being set
//     is incompatible with the existing shape).
public static native void TF_GraphSetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("const int64_t*") LongPointer dims,
                                                  int num_dims,
                                                  TF_Status status);
public static native void TF_GraphSetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("const int64_t*") LongBuffer dims,
                                                  int num_dims,
                                                  TF_Status status);
public static native void TF_GraphSetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("const int64_t*") long[] dims,
                                                  int num_dims,
                                                  TF_Status status);

// Returns the number of dimensions of the Tensor referenced by `output`
// in `graph`.
//
// If the number of dimensions in the shape is unknown, returns -1.
//
// Returns an error into `status` if:
//   * `output` is not in `graph`.
public static native int TF_GraphGetTensorNumDims(TF_Graph graph,
                                                   @ByVal TF_Output output,
                                                   TF_Status status);

// Returns the shape of the Tensor referenced by `output` in `graph`
// into `dims`. `dims` must be an array large enough to hold `num_dims`
// entries (e.g., the return value of TF_GraphGetTensorNumDims).
//
// If the number of dimensions in the shape is unknown or the shape is
// a scalar, `dims` will remain untouched. Otherwise, each element of
// `dims` will be set corresponding to the size of the dimension. An
// unknown dimension is represented by `-1`.
//
// Returns an error into `status` if:
//   * `output` is not in `graph`.
//   * `num_dims` does not match the actual number of dimensions.
public static native void TF_GraphGetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("int64_t*") LongPointer dims, int num_dims,
                                                  TF_Status status);
public static native void TF_GraphGetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("int64_t*") LongBuffer dims, int num_dims,
                                                  TF_Status status);
public static native void TF_GraphGetTensorShape(TF_Graph graph,
                                                  @ByVal TF_Output output,
                                                  @Cast("int64_t*") long[] dims, int num_dims,
                                                  TF_Status status);

// Creates a new operation - see `TF_NewOperation` for more details.
//
// The lock for `graph` must be held when calling this function.
//
// Unless implementing advanced behavior, like custom gradient functions, you
// most likely need to call `TF_NewOperation` instead.
public static native TF_OperationDescription TF_NewOperationLocked(
    TF_Graph graph, @Cast("const char*") BytePointer op_type, @Cast("const char*") BytePointer oper_name);
public static native TF_OperationDescription TF_NewOperationLocked(
    TF_Graph graph, String op_type, String oper_name);

// Operation will only be added to *graph when TF_FinishOperation() is
// called (assuming TF_FinishOperation() does not return an error).
// *graph must not be deleted until after TF_FinishOperation() is
// called.
public static native TF_OperationDescription TF_NewOperation(
    TF_Graph graph, @Cast("const char*") BytePointer op_type, @Cast("const char*") BytePointer oper_name);
public static native TF_OperationDescription TF_NewOperation(
    TF_Graph graph, String op_type, String oper_name);

// Specify the device for `desc`.  Defaults to empty, meaning unconstrained.
public static native void TF_SetDevice(TF_OperationDescription desc,
                                        @Cast("const char*") BytePointer device);
public static native void TF_SetDevice(TF_OperationDescription desc,
                                        String device);

// The calls to TF_AddInput and TF_AddInputList must match (in number,
// order, and type) the op declaration.  For example, the "Concat" op
// has registration:
//   REGISTER_OP("Concat")
//       .Input("concat_dim: int32")
//       .Input("values: N * T")
//       .Output("output: T")
//       .Attr("N: int >= 2")
//       .Attr("T: type");
// that defines two inputs, "concat_dim" and "values" (in that order).
// You must use TF_AddInput() for the first input (since it takes a
// single tensor), and TF_AddInputList() for the second input (since
// it takes a list, even if you were to pass a list with a single
// tensor), as in:
//   TF_OperationDescription* desc = TF_NewOperation(graph, "Concat", "c");
//   TF_Output concat_dim_input = {...};
//   TF_AddInput(desc, concat_dim_input);
//   TF_Output values_inputs[5] = {{...}, ..., {...}};
//   TF_AddInputList(desc, values_inputs, 5);

// For inputs that take a single tensor.
public static native void TF_AddInput(TF_OperationDescription desc,
                                       @ByVal TF_Output input);

// For inputs that take a list of tensors.
// inputs must point to TF_Output[num_inputs].
public static native void TF_AddInputList(TF_OperationDescription desc,
                                           @Const TF_Output inputs,
                                           int num_inputs);

// Call once per control input to `desc`.
public static native void TF_AddControlInput(TF_OperationDescription desc,
                                              TF_Operation input);

// Request that `desc` be co-located on the device where `op`
// is placed.
//
// Use of this is discouraged since the implementation of device placement is
// subject to change. Primarily intended for internal libraries
public static native void TF_ColocateWith(TF_OperationDescription desc,
                                           TF_Operation op);

// Call some TF_SetAttr*() function for every attr that is not
// inferred from an input and doesn't have a default value you wish to
// keep.

// `value` must point to a string of length `length` bytes.
public static native void TF_SetAttrString(TF_OperationDescription desc,
                                            @Cast("const char*") BytePointer attr_name,
                                            @Const Pointer value, @Cast("size_t") long length);
public static native void TF_SetAttrString(TF_OperationDescription desc,
                                            String attr_name,
                                            @Const Pointer value, @Cast("size_t") long length);
// `values` and `lengths` each must have lengths `num_values`.
// `values[i]` must point to a string of length `lengths[i]` bytes.
public static native void TF_SetAttrStringList(TF_OperationDescription desc,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("const void*const*") PointerPointer values,
                                                @Cast("const size_t*") SizeTPointer lengths,
                                                int num_values);
public static native void TF_SetAttrStringList(TF_OperationDescription desc,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("const void*const*") @ByPtrPtr Pointer values,
                                                @Cast("const size_t*") SizeTPointer lengths,
                                                int num_values);
public static native void TF_SetAttrStringList(TF_OperationDescription desc,
                                                String attr_name,
                                                @Cast("const void*const*") @ByPtrPtr Pointer values,
                                                @Cast("const size_t*") SizeTPointer lengths,
                                                int num_values);
public static native void TF_SetAttrInt(TF_OperationDescription desc,
                                         @Cast("const char*") BytePointer attr_name, @Cast("int64_t") long value);
public static native void TF_SetAttrInt(TF_OperationDescription desc,
                                         String attr_name, @Cast("int64_t") long value);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             @Cast("const char*") BytePointer attr_name,
                                             @Cast("const int64_t*") LongPointer values,
                                             int num_values);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             String attr_name,
                                             @Cast("const int64_t*") LongBuffer values,
                                             int num_values);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             @Cast("const char*") BytePointer attr_name,
                                             @Cast("const int64_t*") long[] values,
                                             int num_values);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             String attr_name,
                                             @Cast("const int64_t*") LongPointer values,
                                             int num_values);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             @Cast("const char*") BytePointer attr_name,
                                             @Cast("const int64_t*") LongBuffer values,
                                             int num_values);
public static native void TF_SetAttrIntList(TF_OperationDescription desc,
                                             String attr_name,
                                             @Cast("const int64_t*") long[] values,
                                             int num_values);
public static native void TF_SetAttrFloat(TF_OperationDescription desc,
                                           @Cast("const char*") BytePointer attr_name, float value);
public static native void TF_SetAttrFloat(TF_OperationDescription desc,
                                           String attr_name, float value);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Const FloatPointer values,
                                               int num_values);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Const FloatBuffer values,
                                               int num_values);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Const float[] values,
                                               int num_values);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Const FloatPointer values,
                                               int num_values);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Const FloatBuffer values,
                                               int num_values);
public static native void TF_SetAttrFloatList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Const float[] values,
                                               int num_values);
public static native void TF_SetAttrBool(TF_OperationDescription desc,
                                          @Cast("const char*") BytePointer attr_name,
                                          @Cast("unsigned char") byte value);
public static native void TF_SetAttrBool(TF_OperationDescription desc,
                                          String attr_name,
                                          @Cast("unsigned char") byte value);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const unsigned char*") BytePointer values,
                                              int num_values);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const unsigned char*") ByteBuffer values,
                                              int num_values);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const unsigned char*") byte[] values,
                                              int num_values);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const unsigned char*") BytePointer values,
                                              int num_values);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const unsigned char*") ByteBuffer values,
                                              int num_values);
public static native void TF_SetAttrBoolList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const unsigned char*") byte[] values,
                                              int num_values);
public static native void TF_SetAttrType(TF_OperationDescription desc,
                                          @Cast("const char*") BytePointer attr_name,
                                          @Cast("TF_DataType") int value);
public static native void TF_SetAttrType(TF_OperationDescription desc,
                                          String attr_name,
                                          @Cast("TF_DataType") int value);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const TF_DataType*") IntPointer values,
                                              int num_values);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const TF_DataType*") IntBuffer values,
                                              int num_values);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const TF_DataType*") int[] values,
                                              int num_values);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const TF_DataType*") IntPointer values,
                                              int num_values);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const TF_DataType*") IntBuffer values,
                                              int num_values);
public static native void TF_SetAttrTypeList(TF_OperationDescription desc,
                                              String attr_name,
                                              @Cast("const TF_DataType*") int[] values,
                                              int num_values);
public static native void TF_SetAttrPlaceholder(TF_OperationDescription desc,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const char*") BytePointer placeholder);
public static native void TF_SetAttrPlaceholder(TF_OperationDescription desc,
                                                 String attr_name,
                                                 String placeholder);

// Set a 'func' attribute to the specified name.
// `value` must point to a string of length `length` bytes.
public static native void TF_SetAttrFuncName(TF_OperationDescription desc,
                                              @Cast("const char*") BytePointer attr_name,
                                              @Cast("const char*") BytePointer value, @Cast("size_t") long length);
public static native void TF_SetAttrFuncName(TF_OperationDescription desc,
                                              String attr_name,
                                              String value, @Cast("size_t") long length);

// Set `num_dims` to -1 to represent "unknown rank".  Otherwise,
// `dims` points to an array of length `num_dims`.  `dims[i]` must be
// >= -1, with -1 meaning "unknown dimension".
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           @Cast("const char*") BytePointer attr_name,
                                           @Cast("const int64_t*") LongPointer dims, int num_dims);
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           String attr_name,
                                           @Cast("const int64_t*") LongBuffer dims, int num_dims);
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           @Cast("const char*") BytePointer attr_name,
                                           @Cast("const int64_t*") long[] dims, int num_dims);
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           String attr_name,
                                           @Cast("const int64_t*") LongPointer dims, int num_dims);
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           @Cast("const char*") BytePointer attr_name,
                                           @Cast("const int64_t*") LongBuffer dims, int num_dims);
public static native void TF_SetAttrShape(TF_OperationDescription desc,
                                           String attr_name,
                                           @Cast("const int64_t*") long[] dims, int num_dims);
// `dims` and `num_dims` must point to arrays of length `num_shapes`.
// Set `num_dims[i]` to -1 to represent "unknown rank".  Otherwise,
// `dims[i]` points to an array of length `num_dims[i]`.  `dims[i][j]`
// must be >= -1, with -1 meaning "unknown dimension".
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Cast("const int64_t*const*") PointerPointer dims,
                                               @Const IntPointer num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr LongPointer dims,
                                               @Const IntPointer num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr LongBuffer dims,
                                               @Const IntBuffer num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr long[] dims,
                                               @Const int[] num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr LongPointer dims,
                                               @Const IntPointer num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr LongBuffer dims,
                                               @Const IntBuffer num_dims,
                                               int num_shapes);
public static native void TF_SetAttrShapeList(TF_OperationDescription desc,
                                               String attr_name,
                                               @Cast("const int64_t*const*") @ByPtrPtr long[] dims,
                                               @Const int[] num_dims,
                                               int num_shapes);
// `proto` must point to an array of `proto_len` bytes representing a
// binary-serialized TensorShapeProto.
public static native void TF_SetAttrTensorShapeProto(
    TF_OperationDescription desc, @Cast("const char*") BytePointer attr_name, @Const Pointer proto,
    @Cast("size_t") long proto_len, TF_Status status);
public static native void TF_SetAttrTensorShapeProto(
    TF_OperationDescription desc, String attr_name, @Const Pointer proto,
    @Cast("size_t") long proto_len, TF_Status status);
// `protos` and `proto_lens` must point to arrays of length `num_shapes`.
// `protos[i]` must point to an array of `proto_lens[i]` bytes
// representing a binary-serialized TensorShapeProto.
public static native void TF_SetAttrTensorShapeProtoList(
    TF_OperationDescription desc, @Cast("const char*") BytePointer attr_name,
    @Cast("const void*const*") PointerPointer protos, @Cast("const size_t*") SizeTPointer proto_lens, int num_shapes,
    TF_Status status);
public static native void TF_SetAttrTensorShapeProtoList(
    TF_OperationDescription desc, @Cast("const char*") BytePointer attr_name,
    @Cast("const void*const*") @ByPtrPtr Pointer protos, @Cast("const size_t*") SizeTPointer proto_lens, int num_shapes,
    TF_Status status);
public static native void TF_SetAttrTensorShapeProtoList(
    TF_OperationDescription desc, String attr_name,
    @Cast("const void*const*") @ByPtrPtr Pointer protos, @Cast("const size_t*") SizeTPointer proto_lens, int num_shapes,
    TF_Status status);

public static native void TF_SetAttrTensor(TF_OperationDescription desc,
                                            @Cast("const char*") BytePointer attr_name,
                                            TF_Tensor value,
                                            TF_Status status);
public static native void TF_SetAttrTensor(TF_OperationDescription desc,
                                            String attr_name,
                                            TF_Tensor value,
                                            TF_Status status);
public static native void TF_SetAttrTensorList(TF_OperationDescription desc,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("TF_Tensor*const*") PointerPointer values,
                                                int num_values,
                                                TF_Status status);
public static native void TF_SetAttrTensorList(TF_OperationDescription desc,
                                                @Cast("const char*") BytePointer attr_name,
                                                @ByPtrPtr TF_Tensor values,
                                                int num_values,
                                                TF_Status status);
public static native void TF_SetAttrTensorList(TF_OperationDescription desc,
                                                String attr_name,
                                                @ByPtrPtr TF_Tensor values,
                                                int num_values,
                                                TF_Status status);

// `proto` should point to a sequence of bytes of length `proto_len`
// representing a binary serialization of an AttrValue protocol
// buffer.
public static native void TF_SetAttrValueProto(TF_OperationDescription desc,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Const Pointer proto,
                                                @Cast("size_t") long proto_len,
                                                TF_Status status);
public static native void TF_SetAttrValueProto(TF_OperationDescription desc,
                                                String attr_name,
                                                @Const Pointer proto,
                                                @Cast("size_t") long proto_len,
                                                TF_Status status);

// Adds this operation to the graph - see `TF_FinishOperation` for more details.
//
// The lock for `graph` must be held when calling this function.
//
// Unless implementing advanced behavior, like custom gradient functions, you
// most likely need to call `TF_FinishOperation` instead.
public static native TF_Operation TF_FinishOperationLocked(
    TF_OperationDescription desc, TF_Status status);

// If this function succeeds:
//   * *status is set to an OK value,
//   * a TF_Operation is added to the graph,
//   * a non-null value pointing to the added operation is returned --
//     this value is valid until the underlying graph is deleted.
// Otherwise:
//   * *status is set to a non-OK value,
//   * the graph is not modified,
//   * a null value is returned.
// In either case, it deletes `desc`.
public static native TF_Operation TF_FinishOperation(
    TF_OperationDescription desc, TF_Status status);

// TF_Operation functions.  Operations are immutable once created, so
// these are all query functions.

public static native @Cast("const char*") BytePointer TF_OperationName(TF_Operation oper);
public static native @Cast("const char*") BytePointer TF_OperationOpType(TF_Operation oper);
public static native @Cast("const char*") BytePointer TF_OperationDevice(TF_Operation oper);

public static native int TF_OperationNumOutputs(TF_Operation oper);
public static native @Cast("TF_DataType") int TF_OperationOutputType(@ByVal TF_Output oper_out);
public static native int TF_OperationOutputListLength(TF_Operation oper,
                                                       @Cast("const char*") BytePointer arg_name,
                                                       TF_Status status);
public static native int TF_OperationOutputListLength(TF_Operation oper,
                                                       String arg_name,
                                                       TF_Status status);

public static native int TF_OperationNumInputs(TF_Operation oper);
public static native @Cast("TF_DataType") int TF_OperationInputType(@ByVal TF_Input oper_in);
public static native int TF_OperationInputListLength(TF_Operation oper,
                                                      @Cast("const char*") BytePointer arg_name,
                                                      TF_Status status);
public static native int TF_OperationInputListLength(TF_Operation oper,
                                                      String arg_name,
                                                      TF_Status status);

// In this code:
//   TF_Output producer = TF_OperationInput(consumer);
// There is an edge from producer.oper's output (given by
// producer.index) to consumer.oper's input (given by consumer.index).
public static native @ByVal TF_Output TF_OperationInput(@ByVal TF_Input oper_in);

// Get list of all inputs of a specific operation.  `inputs` must point to
// an array of length at least `max_inputs` (ideally set to
// TF_OperationNumInputs(oper)).  Beware that a concurrent
// modification of the graph can increase the number of inputs of
// an operation.
public static native void TF_OperationAllInputs(TF_Operation oper,
                                                 TF_Output inputs,
                                                 int max_inputs);

// Get the number of current consumers of a specific output of an
// operation.  Note that this number can change when new operations
// are added to the graph.
public static native int TF_OperationOutputNumConsumers(@ByVal TF_Output oper_out);

// Get list of all current consumers of a specific output of an
// operation.  `consumers` must point to an array of length at least
// `max_consumers` (ideally set to
// TF_OperationOutputNumConsumers(oper_out)).  Beware that a concurrent
// modification of the graph can increase the number of consumers of
// an operation.  Returns the number of output consumers (should match
// TF_OperationOutputNumConsumers(oper_out)).
public static native int TF_OperationOutputConsumers(@ByVal TF_Output oper_out,
                                                      TF_Input consumers,
                                                      int max_consumers);

// Get the number of control inputs to an operation.
public static native int TF_OperationNumControlInputs(TF_Operation oper);

// Get list of all control inputs to an operation.  `control_inputs` must
// point to an array of length `max_control_inputs` (ideally set to
// TF_OperationNumControlInputs(oper)).  Returns the number of control
// inputs (should match TF_OperationNumControlInputs(oper)).
public static native int TF_OperationGetControlInputs(
    TF_Operation oper, @Cast("TF_Operation**") PointerPointer control_inputs, int max_control_inputs);
public static native int TF_OperationGetControlInputs(
    TF_Operation oper, @ByPtrPtr TF_Operation control_inputs, int max_control_inputs);

// Get the number of operations that have `*oper` as a control input.
// Note that this number can change when new operations are added to
// the graph.
public static native int TF_OperationNumControlOutputs(TF_Operation oper);

// Get the list of operations that have `*oper` as a control input.
// `control_outputs` must point to an array of length at least
// `max_control_outputs` (ideally set to
// TF_OperationNumControlOutputs(oper)). Beware that a concurrent
// modification of the graph can increase the number of control
// outputs.  Returns the number of control outputs (should match
// TF_OperationNumControlOutputs(oper)).
public static native int TF_OperationGetControlOutputs(
    TF_Operation oper, @Cast("TF_Operation**") PointerPointer control_outputs,
    int max_control_outputs);
public static native int TF_OperationGetControlOutputs(
    TF_Operation oper, @ByPtrPtr TF_Operation control_outputs,
    int max_control_outputs);
// Targeting ../TF_AttrMetadata.java



// Returns metadata about the value of the attribute `attr_name` of `oper`.
public static native @ByVal TF_AttrMetadata TF_OperationGetAttrMetadata(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, TF_Status status);
public static native @ByVal TF_AttrMetadata TF_OperationGetAttrMetadata(
    TF_Operation oper, String attr_name, TF_Status status);

// Fills in `value` with the value of the attribute `attr_name`.  `value` must
// point to an array of length at least `max_length` (ideally set to
// TF_AttrMetadata.total_size from TF_OperationGetAttrMetadata(oper,
// attr_name)).
public static native void TF_OperationGetAttrString(TF_Operation oper,
                                                     @Cast("const char*") BytePointer attr_name,
                                                     Pointer value,
                                                     @Cast("size_t") long max_length,
                                                     TF_Status status);
public static native void TF_OperationGetAttrString(TF_Operation oper,
                                                     String attr_name,
                                                     Pointer value,
                                                     @Cast("size_t") long max_length,
                                                     TF_Status status);

// Get the list of strings in the value of the attribute `attr_name`.  Fills in
// `values` and `lengths`, each of which must point to an array of length at
// least `max_values`.
//
// The elements of values will point to addresses in `storage` which must be at
// least `storage_size` bytes in length.  Ideally, max_values would be set to
// TF_AttrMetadata.list_size and `storage` would be at least
// TF_AttrMetadata.total_size, obtained from TF_OperationGetAttrMetadata(oper,
// attr_name).
//
// Fails if storage_size is too small to hold the requested number of strings.
public static native void TF_OperationGetAttrStringList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("void**") PointerPointer values, @Cast("size_t*") SizeTPointer lengths,
    int max_values, Pointer storage, @Cast("size_t") long storage_size, TF_Status status);
public static native void TF_OperationGetAttrStringList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("void**") @ByPtrPtr Pointer values, @Cast("size_t*") SizeTPointer lengths,
    int max_values, Pointer storage, @Cast("size_t") long storage_size, TF_Status status);
public static native void TF_OperationGetAttrStringList(
    TF_Operation oper, String attr_name, @Cast("void**") @ByPtrPtr Pointer values, @Cast("size_t*") SizeTPointer lengths,
    int max_values, Pointer storage, @Cast("size_t") long storage_size, TF_Status status);

public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Cast("int64_t*") LongPointer value,
                                                  TF_Status status);
public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  String attr_name,
                                                  @Cast("int64_t*") LongBuffer value,
                                                  TF_Status status);
public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Cast("int64_t*") long[] value,
                                                  TF_Status status);
public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  String attr_name,
                                                  @Cast("int64_t*") LongPointer value,
                                                  TF_Status status);
public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Cast("int64_t*") LongBuffer value,
                                                  TF_Status status);
public static native void TF_OperationGetAttrInt(TF_Operation oper,
                                                  String attr_name,
                                                  @Cast("int64_t*") long[] value,
                                                  TF_Status status);

// Fills in `values` with the value of the attribute `attr_name` of `oper`.
// `values` must point to an array of length at least `max_values` (ideally set
// TF_AttrMetadata.list_size from TF_OperationGetAttrMetadata(oper,
// attr_name)).
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      @Cast("const char*") BytePointer attr_name,
                                                      @Cast("int64_t*") LongPointer values,
                                                      int max_values,
                                                      TF_Status status);
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      String attr_name,
                                                      @Cast("int64_t*") LongBuffer values,
                                                      int max_values,
                                                      TF_Status status);
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      @Cast("const char*") BytePointer attr_name,
                                                      @Cast("int64_t*") long[] values,
                                                      int max_values,
                                                      TF_Status status);
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      String attr_name,
                                                      @Cast("int64_t*") LongPointer values,
                                                      int max_values,
                                                      TF_Status status);
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      @Cast("const char*") BytePointer attr_name,
                                                      @Cast("int64_t*") LongBuffer values,
                                                      int max_values,
                                                      TF_Status status);
public static native void TF_OperationGetAttrIntList(TF_Operation oper,
                                                      String attr_name,
                                                      @Cast("int64_t*") long[] values,
                                                      int max_values,
                                                      TF_Status status);

public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    FloatPointer value,
                                                    TF_Status status);
public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    String attr_name,
                                                    FloatBuffer value,
                                                    TF_Status status);
public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    float[] value,
                                                    TF_Status status);
public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    String attr_name,
                                                    FloatPointer value,
                                                    TF_Status status);
public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    FloatBuffer value,
                                                    TF_Status status);
public static native void TF_OperationGetAttrFloat(TF_Operation oper,
                                                    String attr_name,
                                                    float[] value,
                                                    TF_Status status);

// Fills in `values` with the value of the attribute `attr_name` of `oper`.
// `values` must point to an array of length at least `max_values` (ideally set
// to TF_AttrMetadata.list_size from TF_OperationGetAttrMetadata(oper,
// attr_name)).
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        @Cast("const char*") BytePointer attr_name,
                                                        FloatPointer values,
                                                        int max_values,
                                                        TF_Status status);
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        String attr_name,
                                                        FloatBuffer values,
                                                        int max_values,
                                                        TF_Status status);
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        @Cast("const char*") BytePointer attr_name,
                                                        float[] values,
                                                        int max_values,
                                                        TF_Status status);
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        String attr_name,
                                                        FloatPointer values,
                                                        int max_values,
                                                        TF_Status status);
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        @Cast("const char*") BytePointer attr_name,
                                                        FloatBuffer values,
                                                        int max_values,
                                                        TF_Status status);
public static native void TF_OperationGetAttrFloatList(TF_Operation oper,
                                                        String attr_name,
                                                        float[] values,
                                                        int max_values,
                                                        TF_Status status);

public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("unsigned char*") BytePointer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("unsigned char*") ByteBuffer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("unsigned char*") byte[] value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("unsigned char*") BytePointer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("unsigned char*") ByteBuffer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrBool(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("unsigned char*") byte[] value,
                                                   TF_Status status);

// Fills in `values` with the value of the attribute `attr_name` of `oper`.
// `values` must point to an array of length at least `max_values` (ideally set
// to TF_AttrMetadata.list_size from TF_OperationGetAttrMetadata(oper,
// attr_name)).
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("unsigned char*") BytePointer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("unsigned char*") ByteBuffer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("unsigned char*") byte[] values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("unsigned char*") BytePointer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("unsigned char*") ByteBuffer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrBoolList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("unsigned char*") byte[] values,
                                                       int max_values,
                                                       TF_Status status);

public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("TF_DataType*") IntPointer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("TF_DataType*") IntBuffer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("TF_DataType*") int[] value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("TF_DataType*") IntPointer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("TF_DataType*") IntBuffer value,
                                                   TF_Status status);
public static native void TF_OperationGetAttrType(TF_Operation oper,
                                                   String attr_name,
                                                   @Cast("TF_DataType*") int[] value,
                                                   TF_Status status);

// Fills in `values` with the value of the attribute `attr_name` of `oper`.
// `values` must point to an array of length at least `max_values` (ideally set
// to TF_AttrMetadata.list_size from TF_OperationGetAttrMetadata(oper,
// attr_name)).
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("TF_DataType*") IntPointer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("TF_DataType*") IntBuffer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("TF_DataType*") int[] values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("TF_DataType*") IntPointer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       @Cast("const char*") BytePointer attr_name,
                                                       @Cast("TF_DataType*") IntBuffer values,
                                                       int max_values,
                                                       TF_Status status);
public static native void TF_OperationGetAttrTypeList(TF_Operation oper,
                                                       String attr_name,
                                                       @Cast("TF_DataType*") int[] values,
                                                       int max_values,
                                                       TF_Status status);

// Fills in `value` with the value of the attribute `attr_name` of `oper`.
// `values` must point to an array of length at least `num_dims` (ideally set to
// TF_Attr_Meta.size from TF_OperationGetAttrMetadata(oper, attr_name)).
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("int64_t*") LongPointer value,
                                                    int num_dims,
                                                    TF_Status status);
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    String attr_name,
                                                    @Cast("int64_t*") LongBuffer value,
                                                    int num_dims,
                                                    TF_Status status);
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("int64_t*") long[] value,
                                                    int num_dims,
                                                    TF_Status status);
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    String attr_name,
                                                    @Cast("int64_t*") LongPointer value,
                                                    int num_dims,
                                                    TF_Status status);
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("int64_t*") LongBuffer value,
                                                    int num_dims,
                                                    TF_Status status);
public static native void TF_OperationGetAttrShape(TF_Operation oper,
                                                    String attr_name,
                                                    @Cast("int64_t*") long[] value,
                                                    int num_dims,
                                                    TF_Status status);

// Fills in `dims` with the list of shapes in the attribute `attr_name` of
// `oper` and `num_dims` with the corresponding number of dimensions. On return,
// for every i where `num_dims[i]` > 0, `dims[i]` will be an array of
// `num_dims[i]` elements. A value of -1 for `num_dims[i]` indicates that the
// i-th shape in the list is unknown.
//
// The elements of `dims` will point to addresses in `storage` which must be
// large enough to hold at least `storage_size` int64_ts.  Ideally, `num_shapes`
// would be set to TF_AttrMetadata.list_size and `storage_size` would be set to
// TF_AttrMetadata.total_size from TF_OperationGetAttrMetadata(oper,
// attr_name).
//
// Fails if storage_size is insufficient to hold the requested shapes.
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("int64_t**") PointerPointer dims, IntPointer num_dims,
    int num_shapes, @Cast("int64_t*") LongPointer storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("int64_t**") @ByPtrPtr LongPointer dims, IntPointer num_dims,
    int num_shapes, @Cast("int64_t*") LongPointer storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, String attr_name, @Cast("int64_t**") @ByPtrPtr LongBuffer dims, IntBuffer num_dims,
    int num_shapes, @Cast("int64_t*") LongBuffer storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("int64_t**") @ByPtrPtr long[] dims, int[] num_dims,
    int num_shapes, @Cast("int64_t*") long[] storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, String attr_name, @Cast("int64_t**") @ByPtrPtr LongPointer dims, IntPointer num_dims,
    int num_shapes, @Cast("int64_t*") LongPointer storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("int64_t**") @ByPtrPtr LongBuffer dims, IntBuffer num_dims,
    int num_shapes, @Cast("int64_t*") LongBuffer storage, int storage_size, TF_Status status);
public static native void TF_OperationGetAttrShapeList(
    TF_Operation oper, String attr_name, @Cast("int64_t**") @ByPtrPtr long[] dims, int[] num_dims,
    int num_shapes, @Cast("int64_t*") long[] storage, int storage_size, TF_Status status);

// Sets `value` to the binary-serialized TensorShapeProto of the value of
// `attr_name` attribute of `oper`.
public static native void TF_OperationGetAttrTensorShapeProto(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, TF_Buffer value,
    TF_Status status);
public static native void TF_OperationGetAttrTensorShapeProto(
    TF_Operation oper, String attr_name, TF_Buffer value,
    TF_Status status);

// Fills in `values` with binary-serialized TensorShapeProto values of the
// attribute `attr_name` of `oper`. `values` must point to an array of length at
// least `num_values` (ideally set to TF_AttrMetadata.list_size from
// TF_OperationGetAttrMetadata(oper, attr_name)).
public static native void TF_OperationGetAttrTensorShapeProtoList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @Cast("TF_Buffer**") PointerPointer values,
    int max_values, TF_Status status);
public static native void TF_OperationGetAttrTensorShapeProtoList(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, @ByPtrPtr TF_Buffer values,
    int max_values, TF_Status status);
public static native void TF_OperationGetAttrTensorShapeProtoList(
    TF_Operation oper, String attr_name, @ByPtrPtr TF_Buffer values,
    int max_values, TF_Status status);

// Gets the TF_Tensor valued attribute of `attr_name` of `oper`.
//
// Allocates a new TF_Tensor which the caller is expected to take
// ownership of (and can deallocate using TF_DeleteTensor).
public static native void TF_OperationGetAttrTensor(TF_Operation oper,
                                                     @Cast("const char*") BytePointer attr_name,
                                                     @Cast("TF_Tensor**") PointerPointer value,
                                                     TF_Status status);
public static native void TF_OperationGetAttrTensor(TF_Operation oper,
                                                     @Cast("const char*") BytePointer attr_name,
                                                     @ByPtrPtr TF_Tensor value,
                                                     TF_Status status);
public static native void TF_OperationGetAttrTensor(TF_Operation oper,
                                                     String attr_name,
                                                     @ByPtrPtr TF_Tensor value,
                                                     TF_Status status);

// Fills in `values` with the TF_Tensor values of the attribute `attr_name` of
// `oper`. `values` must point to an array of TF_Tensor* of length at least
// `max_values` (ideally set to TF_AttrMetadata.list_size from
// TF_OperationGetAttrMetadata(oper, attr_name)).
//
// The caller takes ownership of all the non-null TF_Tensor* entries in `values`
// (which can be deleted using TF_DeleteTensor(values[i])).
public static native void TF_OperationGetAttrTensorList(TF_Operation oper,
                                                         @Cast("const char*") BytePointer attr_name,
                                                         @Cast("TF_Tensor**") PointerPointer values,
                                                         int max_values,
                                                         TF_Status status);
public static native void TF_OperationGetAttrTensorList(TF_Operation oper,
                                                         @Cast("const char*") BytePointer attr_name,
                                                         @ByPtrPtr TF_Tensor values,
                                                         int max_values,
                                                         TF_Status status);
public static native void TF_OperationGetAttrTensorList(TF_Operation oper,
                                                         String attr_name,
                                                         @ByPtrPtr TF_Tensor values,
                                                         int max_values,
                                                         TF_Status status);

// Sets `output_attr_value` to the binary-serialized AttrValue proto
// representation of the value of the `attr_name` attr of `oper`.
public static native void TF_OperationGetAttrValueProto(
    TF_Operation oper, @Cast("const char*") BytePointer attr_name, TF_Buffer output_attr_value,
    TF_Status status);
public static native void TF_OperationGetAttrValueProto(
    TF_Operation oper, String attr_name, TF_Buffer output_attr_value,
    TF_Status status);

// Get the number of attributes the operation has.
public static native int TF_OperationGetNumAttrs(TF_Operation oper);

// Get the length of the name of the ith attribute, or -1 if there is not an
// ith attribute.
public static native int TF_OperationGetAttrNameLength(TF_Operation oper,
                                                        int i);

// Get the name of the ith attribute.  output should have the size of
// TF_OperationGetAttrNameLength(oper, i).
public static native void TF_OperationGetAttrName(TF_Operation oper, int i,
                                                   @Cast("char*") BytePointer output,
                                                   TF_Status status);
public static native void TF_OperationGetAttrName(TF_Operation oper, int i,
                                                   @Cast("char*") ByteBuffer output,
                                                   TF_Status status);
public static native void TF_OperationGetAttrName(TF_Operation oper, int i,
                                                   @Cast("char*") byte[] output,
                                                   TF_Status status);

// Returns the operation in the graph with `oper_name`. Returns nullptr if
// no operation found.
public static native TF_Operation TF_GraphOperationByName(
    TF_Graph graph, @Cast("const char*") BytePointer oper_name);
public static native TF_Operation TF_GraphOperationByName(
    TF_Graph graph, String oper_name);

// Iterate through the operations of a graph.  To use:
// size_t pos = 0;
// TF_Operation* oper;
// while ((oper = TF_GraphNextOperation(graph, &pos)) != nullptr) {
//   DoSomethingWithOperation(oper);
// }
public static native TF_Operation TF_GraphNextOperation(TF_Graph graph,
                                                          @Cast("size_t*") SizeTPointer pos);

// Write out a serialized representation of `graph` (as a GraphDef protocol
// message) to `output_graph_def` (allocated by TF_NewBuffer()).
// `output_graph_def`'s underlying buffer will be freed when TF_DeleteBuffer()
// is called.
//
// May fail on very large graphs in the future.
public static native void TF_GraphToGraphDef(TF_Graph graph,
                                              TF_Buffer output_graph_def,
                                              TF_Status status);

// Returns the serialized OpDef proto with name `op_name`, or a bad status if no
// such op exists. This can return OpDefs of functions copied into the graph.
public static native void TF_GraphGetOpDef(TF_Graph graph,
                                            @Cast("const char*") BytePointer op_name,
                                            TF_Buffer output_op_def,
                                            TF_Status status);
public static native void TF_GraphGetOpDef(TF_Graph graph,
                                            String op_name,
                                            TF_Buffer output_op_def,
                                            TF_Status status);

// Returns the serialized VersionDef proto for this graph.
public static native void TF_GraphVersions(TF_Graph graph,
                                            TF_Buffer output_version_def,
                                            TF_Status status);
// Targeting ../TF_ImportGraphDefOptions.java



public static native TF_ImportGraphDefOptions TF_NewImportGraphDefOptions();
public static native void TF_DeleteImportGraphDefOptions(
    TF_ImportGraphDefOptions opts);

// Set the prefix to be prepended to the names of nodes in `graph_def` that will
// be imported into `graph`. `prefix` is copied and has no lifetime
// requirements.
public static native void TF_ImportGraphDefOptionsSetPrefix(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer prefix);
public static native void TF_ImportGraphDefOptionsSetPrefix(
    TF_ImportGraphDefOptions opts, String prefix);

// Set the execution device for nodes in `graph_def`.
// Only applies to nodes where a device was not already explicitly specified.
// `device` is copied and has no lifetime requirements.
public static native void TF_ImportGraphDefOptionsSetDefaultDevice(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer device);
public static native void TF_ImportGraphDefOptionsSetDefaultDevice(
    TF_ImportGraphDefOptions opts, String device);

// Set whether to uniquify imported operation names. If true, imported operation
// names will be modified if their name already exists in the graph. If false,
// conflicting names will be treated as an error. Note that this option has no
// effect if a prefix is set, since the prefix will guarantee all names are
// unique. Defaults to false.
public static native void TF_ImportGraphDefOptionsSetUniquifyNames(
    TF_ImportGraphDefOptions opts, @Cast("unsigned char") byte uniquify_names);

// If true, the specified prefix will be modified if it already exists as an
// operation name or prefix in the graph. If false, a conflicting prefix will be
// treated as an error. This option has no effect if no prefix is specified.
public static native void TF_ImportGraphDefOptionsSetUniquifyPrefix(
    TF_ImportGraphDefOptions opts, @Cast("unsigned char") byte uniquify_prefix);

// Set any imported nodes with input `src_name:src_index` to have that input
// replaced with `dst`. `src_name` refers to a node in the graph to be imported,
// `dst` references a node already existing in the graph being imported into.
// `src_name` is copied and has no lifetime requirements.
public static native void TF_ImportGraphDefOptionsAddInputMapping(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer src_name, int src_index,
    @ByVal TF_Output dst);
public static native void TF_ImportGraphDefOptionsAddInputMapping(
    TF_ImportGraphDefOptions opts, String src_name, int src_index,
    @ByVal TF_Output dst);

// Set any imported nodes with control input `src_name` to have that input
// replaced with `dst`. `src_name` refers to a node in the graph to be imported,
// `dst` references an operation already existing in the graph being imported
// into. `src_name` is copied and has no lifetime requirements.
public static native void TF_ImportGraphDefOptionsRemapControlDependency(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer src_name, TF_Operation dst);
public static native void TF_ImportGraphDefOptionsRemapControlDependency(
    TF_ImportGraphDefOptions opts, String src_name, TF_Operation dst);

// Cause the imported graph to have a control dependency on `oper`. `oper`
// should exist in the graph being imported into.
public static native void TF_ImportGraphDefOptionsAddControlDependency(
    TF_ImportGraphDefOptions opts, TF_Operation oper);

// Add an output in `graph_def` to be returned via the `return_outputs` output
// parameter of TF_GraphImportGraphDef(). If the output is remapped via an input
// mapping, the corresponding existing tensor in `graph` will be returned.
// `oper_name` is copied and has no lifetime requirements.
public static native void TF_ImportGraphDefOptionsAddReturnOutput(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer oper_name, int index);
public static native void TF_ImportGraphDefOptionsAddReturnOutput(
    TF_ImportGraphDefOptions opts, String oper_name, int index);

// Returns the number of return outputs added via
// TF_ImportGraphDefOptionsAddReturnOutput().
public static native int TF_ImportGraphDefOptionsNumReturnOutputs(
    @Const TF_ImportGraphDefOptions opts);

// Add an operation in `graph_def` to be returned via the `return_opers` output
// parameter of TF_GraphImportGraphDef(). `oper_name` is copied and has no
// lifetime requirements.
public static native void TF_ImportGraphDefOptionsAddReturnOperation(
    TF_ImportGraphDefOptions opts, @Cast("const char*") BytePointer oper_name);
public static native void TF_ImportGraphDefOptionsAddReturnOperation(
    TF_ImportGraphDefOptions opts, String oper_name);

// Returns the number of return operations added via
// TF_ImportGraphDefOptionsAddReturnOperation().
public static native int TF_ImportGraphDefOptionsNumReturnOperations(
    @Const TF_ImportGraphDefOptions opts);
// Targeting ../TF_ImportGraphDefResults.java



// Fetches the return outputs requested via
// TF_ImportGraphDefOptionsAddReturnOutput(). The number of fetched outputs is
// returned in `num_outputs`. The array of return outputs is returned in
// `outputs`. `*outputs` is owned by and has the lifetime of `results`.
public static native void TF_ImportGraphDefResultsReturnOutputs(
    TF_ImportGraphDefResults results, IntPointer num_outputs, @Cast("TF_Output**") PointerPointer outputs);
public static native void TF_ImportGraphDefResultsReturnOutputs(
    TF_ImportGraphDefResults results, IntPointer num_outputs, @ByPtrPtr TF_Output outputs);
public static native void TF_ImportGraphDefResultsReturnOutputs(
    TF_ImportGraphDefResults results, IntBuffer num_outputs, @ByPtrPtr TF_Output outputs);
public static native void TF_ImportGraphDefResultsReturnOutputs(
    TF_ImportGraphDefResults results, int[] num_outputs, @ByPtrPtr TF_Output outputs);

// Fetches the return operations requested via
// TF_ImportGraphDefOptionsAddReturnOperation(). The number of fetched
// operations is returned in `num_opers`. The array of return operations is
// returned in `opers`. `*opers` is owned by and has the lifetime of `results`.
public static native void TF_ImportGraphDefResultsReturnOperations(
    TF_ImportGraphDefResults results, IntPointer num_opers, @Cast("TF_Operation***") @ByPtrPtr PointerPointer opers);
public static native void TF_ImportGraphDefResultsReturnOperations(
    TF_ImportGraphDefResults results, IntBuffer num_opers, @Cast("TF_Operation***") @ByPtrPtr PointerPointer opers);
public static native void TF_ImportGraphDefResultsReturnOperations(
    TF_ImportGraphDefResults results, int[] num_opers, @Cast("TF_Operation***") @ByPtrPtr PointerPointer opers);

// Fetches any input mappings requested via
// TF_ImportGraphDefOptionsAddInputMapping() that didn't appear in the GraphDef
// and weren't used as input to any node in the imported graph def. The number
// of fetched mappings is returned in `num_missing_unused_input_mappings`. The
// array of each mapping's source node name is returned in `src_names`, and the
// array of each mapping's source index is returned in `src_indexes`.
//
// `*src_names`, `*src_indexes`, and the memory backing each string in
// `src_names` are owned by and have the lifetime of `results`.
public static native void TF_ImportGraphDefResultsMissingUnusedInputMappings(
    TF_ImportGraphDefResults results, IntPointer num_missing_unused_input_mappings,
    @Cast("const char***") @ByPtrPtr PointerPointer src_names, @Cast("int**") PointerPointer src_indexes);
public static native void TF_ImportGraphDefResultsMissingUnusedInputMappings(
    TF_ImportGraphDefResults results, IntPointer num_missing_unused_input_mappings,
    @Cast("const char***") @ByPtrPtr PointerPointer src_names, @ByPtrPtr IntPointer src_indexes);
public static native void TF_ImportGraphDefResultsMissingUnusedInputMappings(
    TF_ImportGraphDefResults results, IntBuffer num_missing_unused_input_mappings,
    @Cast("const char***") @ByPtrPtr PointerPointer src_names, @ByPtrPtr IntBuffer src_indexes);
public static native void TF_ImportGraphDefResultsMissingUnusedInputMappings(
    TF_ImportGraphDefResults results, int[] num_missing_unused_input_mappings,
    @Cast("const char***") @ByPtrPtr PointerPointer src_names, @ByPtrPtr int[] src_indexes);

// Deletes a results object returned by TF_GraphImportGraphDefWithResults().
public static native void TF_DeleteImportGraphDefResults(
    TF_ImportGraphDefResults results);

// Import the graph serialized in `graph_def` into `graph`.  Returns nullptr and
// a bad status on error. Otherwise, returns a populated
// TF_ImportGraphDefResults instance. The returned instance must be deleted via
// TF_DeleteImportGraphDefResults().
public static native TF_ImportGraphDefResults TF_GraphImportGraphDefWithResults(TF_Graph graph, @Const TF_Buffer graph_def,
                                  @Const TF_ImportGraphDefOptions options,
                                  TF_Status status);

// Has the same behavior as TF_GraphImportGraphDefWithResults, but instead of
// taking in a serialized tensorflow::GraphDef, it takes in a *pointer* to the
// C++ *in memory representation* of the GraphDef, stored in `graph_def->data`
public static native TF_ImportGraphDefResults TF_GraphImportGraphDefWithResultsNoSerialization(
    TF_Graph graph, @Const TF_Buffer graph_def,
    @Const TF_ImportGraphDefOptions options, TF_Status status);

// Import the graph serialized in `graph_def` into `graph`.
// Convenience function for when only return outputs are needed.
//
// `num_return_outputs` must be the number of return outputs added (i.e. the
// result of TF_ImportGraphDefOptionsNumReturnOutputs()).  If
// `num_return_outputs` is non-zero, `return_outputs` must be of length
// `num_return_outputs`. Otherwise it can be null.
public static native void TF_GraphImportGraphDefWithReturnOutputs(
    TF_Graph graph, @Const TF_Buffer graph_def,
    @Const TF_ImportGraphDefOptions options, TF_Output return_outputs,
    int num_return_outputs, TF_Status status);

// Import the graph serialized in `graph_def` into `graph`.
// Convenience function for when no results are needed.
public static native void TF_GraphImportGraphDef(
    TF_Graph graph, @Const TF_Buffer graph_def,
    @Const TF_ImportGraphDefOptions options, TF_Status status);

// Adds a copy of function `func` and optionally its gradient function `grad`
// to `g`. Once `func`/`grad` is added to `g`, it can be called by creating
// an operation using the function's name.
// Any changes to `func`/`grad` (including deleting it) done after this method
// returns, won't affect the copy of `func`/`grad` in `g`.
// If `func` or `grad` are already in `g`, TF_GraphCopyFunction has no
// effect on them, but can establish the function->gradient relationship
// between them if `func` does not already have a gradient. If `func` already
// has a gradient different from `grad`, an error is returned.
//
// `func` must not be null.
// If `grad` is null and `func` is not in `g`, `func` is added without a
// gradient.
// If `grad` is null and `func` is in `g`, TF_GraphCopyFunction is a noop.
// `grad` must have appropriate signature as described in the doc of
// GradientDef in tensorflow/core/framework/function.proto.
//
// If successful, status is set to OK and `func` and `grad` are added to `g`.
// Otherwise, status is set to the encountered error and `g` is unmodified.
public static native void TF_GraphCopyFunction(TF_Graph g,
                                                @Const TF_Function func,
                                                @Const TF_Function grad,
                                                TF_Status status);

// Returns the number of TF_Functions registered in `g`.
public static native int TF_GraphNumFunctions(TF_Graph g);

// Fills in `funcs` with the TF_Function* registered in `g`.
// `funcs` must point to an array of TF_Function* of length at least
// `max_func`. In usual usage, max_func should be set to the result of
// TF_GraphNumFunctions(g). In this case, all the functions registered in
// `g` will be returned. Else, an unspecified subset.
//
// If successful, returns the number of TF_Function* successfully set in
// `funcs` and sets status to OK. The caller takes ownership of
// all the returned TF_Functions. They must be deleted with TF_DeleteFunction.
// On error, returns 0, sets status to the encountered error, and the contents
// of funcs will be undefined.
public static native int TF_GraphGetFunctions(TF_Graph g, @Cast("TF_Function**") PointerPointer funcs,
                                               int max_func, TF_Status status);
public static native int TF_GraphGetFunctions(TF_Graph g, @ByPtrPtr TF_Function funcs,
                                               int max_func, TF_Status status);

// Note: The following function may fail on very large protos in the future.

public static native void TF_OperationToNodeDef(TF_Operation oper,
                                                 TF_Buffer output_node_def,
                                                 TF_Status status);
// Targeting ../TF_WhileParams.java



// Creates a TF_WhileParams for creating a while loop in `g`. `inputs` are
// outputs that already exist in `g` used as initial values for the loop
// variables.
//
// The returned TF_WhileParams will have all fields initialized except
// `cond_output`, `body_outputs`, and `name`. The `body_outputs` buffer will be
// allocated to size `ninputs`. The caller should build `cond_graph` and
// `body_graph` starting from the inputs, and store the final outputs in
// `cond_output` and `body_outputs`.
//
// If `status` is OK, the caller must call either TF_FinishWhile or
// TF_AbortWhile on the returned TF_WhileParams. If `status` isn't OK, the
// returned TF_WhileParams is not valid, and the caller should not call
// TF_FinishWhile() or TF_AbortWhile().
//
// Missing functionality (TODO):
// - Gradients
// - Reference-type inputs
// - Directly referencing external tensors from the cond/body graphs (this is
//   possible in the Python API)
public static native @ByVal TF_WhileParams TF_NewWhile(TF_Graph g, TF_Output inputs,
                                                 int ninputs,
                                                 TF_Status status);

// Builds the while loop specified by `params` and returns the output tensors of
// the while loop in `outputs`. `outputs` should be allocated to size
// `params.ninputs`.
//
// `params` is no longer valid once this returns.
//
// Either this or TF_AbortWhile() must be called after a successful
// TF_NewWhile() call.
public static native void TF_FinishWhile(@Const TF_WhileParams params,
                                          TF_Status status,
                                          TF_Output outputs);

// Frees `params`s resources without building a while loop. `params` is no
// longer valid after this returns. Either this or TF_FinishWhile() must be
// called after a successful TF_NewWhile() call.
public static native void TF_AbortWhile(@Const TF_WhileParams params);

// Adds operations to compute the partial derivatives of sum of `y`s w.r.t `x`s,
// i.e., d(y_1 + y_2 + ...)/dx_1, d(y_1 + y_2 + ...)/dx_2...
//
// `dx` are used as initial gradients (which represent the symbolic partial
// derivatives of some loss function `L` w.r.t. `y`).
// `dx` must be nullptr or have size `ny`.
// If `dx` is nullptr, the implementation will use dx of `OnesLike` for all
// shapes in `y`.
// The partial derivatives are returned in `dy`. `dy` should be allocated to
// size `nx`.
//
// Gradient nodes are automatically named under the "gradients/" prefix. To
// guarantee name uniqueness, subsequent calls to the same graph will
// append an incremental tag to the prefix: "gradients_1/", "gradients_2/", ...
// See TF_AddGradientsWithPrefix, which provides a means to specify a custom
// name prefix for operations added to a graph to compute the gradients.
//
// WARNING: This function does not yet support all the gradients that python
// supports. See
// https://www.tensorflow.org/code/tensorflow/cc/gradients/README.md
// for instructions on how to add C++ more gradients.
public static native void TF_AddGradients(TF_Graph g, TF_Output y, int ny,
                                    TF_Output x, int nx, TF_Output dx,
                                    TF_Status status, TF_Output dy);

// Adds operations to compute the partial derivatives of sum of `y`s w.r.t `x`s,
// i.e., d(y_1 + y_2 + ...)/dx_1, d(y_1 + y_2 + ...)/dx_2...
// This is a variant of TF_AddGradients that allows to caller to pass a custom
// name prefix to the operations added to a graph to compute the gradients.
//
// `dx` are used as initial gradients (which represent the symbolic partial
// derivatives of some loss function `L` w.r.t. `y`).
// `dx` must be nullptr or have size `ny`.
// If `dx` is nullptr, the implementation will use dx of `OnesLike` for all
// shapes in `y`.
// The partial derivatives are returned in `dy`. `dy` should be allocated to
// size `nx`.
// `prefix` names the scope into which all gradients operations are being added.
// `prefix` must be unique within the provided graph otherwise this operation
// will fail. If `prefix` is nullptr, the default prefixing behaviour takes
// place, see TF_AddGradients for more details.
//
// WARNING: This function does not yet support all the gradients that python
// supports. See
// https://www.tensorflow.org/code/tensorflow/cc/gradients/README.md
// for instructions on how to add C++ more gradients.
public static native void TF_AddGradientsWithPrefix(TF_Graph g, @Cast("const char*") BytePointer prefix,
                                              TF_Output y, int ny,
                                              TF_Output x, int nx,
                                              TF_Output dx, TF_Status status,
                                              TF_Output dy);
public static native void TF_AddGradientsWithPrefix(TF_Graph g, String prefix,
                                              TF_Output y, int ny,
                                              TF_Output x, int nx,
                                              TF_Output dx, TF_Status status,
                                              TF_Output dy);

// Create a TF_Function from a TF_Graph
//
// Params:
//  fn_body - the graph whose operations (or subset of whose operations) will be
//            converted to TF_Function.
//  fn_name - the name of the new TF_Function. Should match the operation
//            name (OpDef.name) regexp [A-Z][A-Za-z0-9_.\\-/]*.
//            If `append_hash_to_fn_name` is false, `fn_name` must be distinct
//            from other function and operation names (at least those
//            registered in graphs where this function will be used).
//  append_hash_to_fn_name - Must be 0 or 1. If set to 1, the actual name
//                           of the function will be `fn_name` appended with
//                           '_<hash_of_this_function's_definition>'.
//                           If set to 0, the function's name will be `fn_name`.
//  num_opers - `num_opers` contains the number of elements in the `opers` array
//              or a special value of -1 meaning that no array is given.
//              The distinction between an empty array of operations and no
//              array of operations is necessary to distinguish the case of
//              creating a function with no body (e.g. identity or permutation)
//              and the case of creating a function whose body contains all
//              the nodes in the graph (except for the automatic skipping, see
//              below).
//  opers - Array of operations to become the body of the function or null.
//          - If no array is given (`num_opers` = -1), all the
//          operations in `fn_body` will become part of the function
//          except operations referenced in `inputs`. These operations
//          must have a single output (these operations are typically
//          placeholders created for the sole purpose of representing
//          an input. We can relax this constraint if there are
//          compelling use cases).
//          - If an array is given (`num_opers` >= 0), all operations
//          in it will become part of the function. In particular, no
//          automatic skipping of dummy input operations is performed.
//  ninputs - number of elements in `inputs` array
//  inputs - array of TF_Outputs that specify the inputs to the function.
//           If `ninputs` is zero (the function takes no inputs), `inputs`
//           can be null. The names used for function inputs are normalized
//           names of the operations (usually placeholders) pointed to by
//           `inputs`. These operation names should start with a letter.
//           Normalization will convert all letters to lowercase and
//           non-alphanumeric characters to '_' to make resulting names match
//           the "[a-z][a-z0-9_]*" pattern for operation argument names.
//           `inputs` cannot contain the same tensor twice.
//  noutputs - number of elements in `outputs` array
//  outputs - array of TF_Outputs that specify the outputs of the function.
//            If `noutputs` is zero (the function returns no outputs), `outputs`
//            can be null. `outputs` can contain the same tensor more than once.
//  output_names - The names of the function's outputs. `output_names` array
//                 must either have the same length as `outputs`
//                 (i.e. `noutputs`) or be null. In the former case,
//                 the names should match the regular expression for ArgDef
//                 names - "[a-z][a-z0-9_]*". In the latter case,
//                 names for outputs will be generated automatically.
//  opts - various options for the function, e.g. XLA's inlining control.
//  description - optional human-readable description of this function.
//  status - Set to OK on success and an appropriate error on failure.
//
// Note that when the same TF_Output is listed as both an input and an output,
// the corresponding function's output will equal to this input,
// instead of the original node's output.
//
// Callers must also satisfy the following constraints:
// - `inputs` cannot refer to TF_Outputs within a control flow context. For
//   example, one cannot use the output of "switch" node as input.
// - `inputs` and `outputs` cannot have reference types. Reference types are
//   not exposed through C API and are being replaced with Resources. We support
//   reference types inside function's body to support legacy code. Do not
//   use them in new code.
// - Every node in the function's body must have all of its inputs (including
//   control inputs). In other words, for every node in the body, each input
//   must be either listed in `inputs` or must come from another node in
//   the body. In particular, it is an error to have a control edge going from
//   a node outside of the body into a node in the body. This applies to control
//   edges going from nodes referenced in `inputs` to nodes in the body when
//   the former nodes are not in the body (automatically skipped or not
//   included in explicitly specified body).
//
// Returns:
//  On success, a newly created TF_Function instance. It must be deleted by
//  calling TF_DeleteFunction.
//
//  On failure, null.
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Cast("const TF_Operation*const*") PointerPointer opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") PointerPointer output_names,
    @Const TF_FunctionOptions opts, @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr BytePointer output_names,
    @Const TF_FunctionOptions opts, @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names,
    @Const TF_FunctionOptions opts, String description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr byte[] output_names,
    @Const TF_FunctionOptions opts, @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr BytePointer output_names,
    @Const TF_FunctionOptions opts, String description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names,
    @Const TF_FunctionOptions opts, @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunction(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr byte[] output_names,
    @Const TF_FunctionOptions opts, String description, TF_Status status);

// Similar to TF_GraphToFunction but allows specifying control outputs of the
// function.
//
//  The arguments of TF_GraphToFunction have the same meaning, but the new
//  arguments are as follows:
//
//    ncontrol_outputs: Number of control outputs of the function.
//    control_outputs: vector of TF_Operation objects to be marked as control
//      outputs of the function. Operations marked as control outputs are
//      guaranteed to execute.
//    control_output_names: Optional. If not nullptr, vector of strings, one
//      per control output, with their names to be added to the function's
//      OpDef.
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Cast("const TF_Operation*const*") PointerPointer opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") PointerPointer output_names,
    int ncontrol_outputs, @Cast("const TF_Operation*const*") PointerPointer control_outputs,
    @Cast("const char*const*") PointerPointer control_output_names, @Const TF_FunctionOptions opts,
    @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr BytePointer output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr BytePointer control_output_names, @Const TF_FunctionOptions opts,
    @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr ByteBuffer control_output_names, @Const TF_FunctionOptions opts,
    String description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr byte[] output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr byte[] control_output_names, @Const TF_FunctionOptions opts,
    @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr BytePointer output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr BytePointer control_output_names, @Const TF_FunctionOptions opts,
    String description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, @Cast("const char*") BytePointer fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr ByteBuffer output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr ByteBuffer control_output_names, @Const TF_FunctionOptions opts,
    @Cast("const char*") BytePointer description, TF_Status status);
public static native TF_Function TF_GraphToFunctionWithControlOutputs(
    @Const TF_Graph fn_body, String fn_name,
    @Cast("unsigned char") byte append_hash_to_fn_name, int num_opers,
    @Const @ByPtrPtr TF_Operation opers, int ninputs, @Const TF_Output inputs,
    int noutputs, @Const TF_Output outputs, @Cast("const char*const*") @ByPtrPtr byte[] output_names,
    int ncontrol_outputs, @Const @ByPtrPtr TF_Operation control_outputs,
    @Cast("const char*const*") @ByPtrPtr byte[] control_output_names, @Const TF_FunctionOptions opts,
    String description, TF_Status status);

// Returns the name of the graph function.
// The return value points to memory that is only usable until the next
// mutation to *func.
public static native @Cast("const char*") BytePointer TF_FunctionName(TF_Function func);

// Write out a serialized representation of `func` (as a FunctionDef protocol
// message) to `output_func_def` (allocated by TF_NewBuffer()).
// `output_func_def`'s underlying buffer will be freed when TF_DeleteBuffer()
// is called.
//
// May fail on very large graphs in the future.
public static native void TF_FunctionToFunctionDef(TF_Function func,
                                                    TF_Buffer output_func_def,
                                                    TF_Status status);

// Construct and return the function whose FunctionDef representation is
// serialized in `proto`. `proto_len` must equal the number of bytes
// pointed to by `proto`.
// Returns:
//  On success, a newly created TF_Function instance. It must be deleted by
//  calling TF_DeleteFunction.
//
//  On failure, null.
public static native TF_Function TF_FunctionImportFunctionDef(
    @Const Pointer proto, @Cast("size_t") long proto_len, TF_Status status);

// Sets function attribute named `attr_name` to value stored in `proto`.
// If this attribute is already set to another value, it is overridden.
// `proto` should point to a sequence of bytes of length `proto_len`
// representing a binary serialization of an AttrValue protocol
// buffer.
public static native void TF_FunctionSetAttrValueProto(TF_Function func,
                                                        @Cast("const char*") BytePointer attr_name,
                                                        @Const Pointer proto,
                                                        @Cast("size_t") long proto_len,
                                                        TF_Status status);
public static native void TF_FunctionSetAttrValueProto(TF_Function func,
                                                        String attr_name,
                                                        @Const Pointer proto,
                                                        @Cast("size_t") long proto_len,
                                                        TF_Status status);

// Sets `output_attr_value` to the binary-serialized AttrValue proto
// representation of the value of the `attr_name` attr of `func`.
// If `attr_name` attribute is not present, status is set to an error.
public static native void TF_FunctionGetAttrValueProto(
    TF_Function func, @Cast("const char*") BytePointer attr_name, TF_Buffer output_attr_value,
    TF_Status status);
public static native void TF_FunctionGetAttrValueProto(
    TF_Function func, String attr_name, TF_Buffer output_attr_value,
    TF_Status status);

// Frees the memory used by the `func` struct.
// TF_DeleteFunction is a noop if `func` is null.
// Deleting a function does not remove it from any graphs it was copied to.
public static native void TF_DeleteFunction(TF_Function func);

// Attempts to evaluate `output`. This will only be possible if `output` doesn't
// depend on any graph inputs (this function is safe to call if this isn't the
// case though).
//
// If the evaluation is successful, this function returns true and `output`s
// value is returned in `result`. Otherwise returns false. An error status is
// returned if something is wrong with the graph or input. Note that this may
// return false even if no error status is set.
public static native @Cast("unsigned char") byte TF_TryEvaluateConstant(TF_Graph graph,
                                                           @ByVal TF_Output output,
                                                           @Cast("TF_Tensor**") PointerPointer result,
                                                           TF_Status status);
public static native @Cast("unsigned char") byte TF_TryEvaluateConstant(TF_Graph graph,
                                                           @ByVal TF_Output output,
                                                           @ByPtrPtr TF_Tensor result,
                                                           TF_Status status);
// Targeting ../TF_Session.java



// Return a new execution session with the associated graph, or NULL on
// error. Does not take ownership of any input parameters.
//
// *`graph` must be a valid graph (not deleted or nullptr). `graph` will be
// kept alive for the lifetime of the returned TF_Session. New nodes can still
// be added to `graph` after this call.
public static native TF_Session TF_NewSession(TF_Graph graph,
                                                @Const TF_SessionOptions opts,
                                                TF_Status status);

// This function creates a new TF_Session (which is created on success) using
// `session_options`, and then initializes state (restoring tensors and other
// assets) using `run_options`.
//
// Any NULL and non-NULL value combinations for (`run_options, `meta_graph_def`)
// are valid.
//
// - `export_dir` must be set to the path of the exported SavedModel.
// - `tags` must include the set of tags used to identify one MetaGraphDef in
//    the SavedModel.
// - `graph` must be a graph newly allocated with TF_NewGraph().
//
// If successful, populates `graph` with the contents of the Graph and
// `meta_graph_def` with the MetaGraphDef of the loaded model.
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    @Cast("const char*") BytePointer export_dir, @Cast("const char*const*") PointerPointer tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    @Cast("const char*") BytePointer export_dir, @Cast("const char*const*") @ByPtrPtr BytePointer tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    String export_dir, @Cast("const char*const*") @ByPtrPtr ByteBuffer tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    @Cast("const char*") BytePointer export_dir, @Cast("const char*const*") @ByPtrPtr byte[] tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    String export_dir, @Cast("const char*const*") @ByPtrPtr BytePointer tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    @Cast("const char*") BytePointer export_dir, @Cast("const char*const*") @ByPtrPtr ByteBuffer tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);
public static native TF_Session TF_LoadSessionFromSavedModel(
    @Const TF_SessionOptions session_options, @Const TF_Buffer run_options,
    String export_dir, @Cast("const char*const*") @ByPtrPtr byte[] tags, int tags_len,
    TF_Graph graph, TF_Buffer meta_graph_def, TF_Status status);

// Close a session.
//
// Contacts any other processes associated with the session, if applicable.
// May not be called after TF_DeleteSession().
public static native void TF_CloseSession(TF_Session arg0, TF_Status status);

// Destroy a session object.
//
// Even if error information is recorded in *status, this call discards all
// local resources associated with the session.  The session may not be used
// during or after this call (and the session drops its reference to the
// corresponding graph).
public static native void TF_DeleteSession(TF_Session arg0, TF_Status status);

// Run the graph associated with the session starting with the supplied inputs
// (inputs[0,ninputs-1] with corresponding values in input_values[0,ninputs-1]).
//
// Any NULL and non-NULL value combinations for (`run_options`,
// `run_metadata`) are valid.
//
//    - `run_options` may be NULL, in which case it will be ignored; or
//      non-NULL, in which case it must point to a `TF_Buffer` containing the
//      serialized representation of a `RunOptions` protocol buffer.
//    - `run_metadata` may be NULL, in which case it will be ignored; or
//      non-NULL, in which case it must point to an empty, freshly allocated
//      `TF_Buffer` that may be updated to contain the serialized representation
//      of a `RunMetadata` protocol buffer.
//
// The caller retains ownership of `input_values` (which can be deleted using
// TF_DeleteTensor). The caller also retains ownership of `run_options` and/or
// `run_metadata` (when not NULL) and should manually call TF_DeleteBuffer on
// them.
//
// On success, the tensors corresponding to outputs[0,noutputs-1] are placed in
// output_values[]. Ownership of the elements of output_values[] is transferred
// to the caller, which must eventually call TF_DeleteTensor on them.
//
// On failure, output_values[] contains NULLs.
public static native void TF_SessionRun(
    TF_Session session,
    @Const TF_Buffer run_options,
    @Const TF_Output inputs, @Cast("TF_Tensor*const*") PointerPointer input_values, int ninputs,
    @Const TF_Output outputs, @Cast("TF_Tensor**") PointerPointer output_values, int noutputs,
    @Cast("const TF_Operation*const*") PointerPointer target_opers, int ntargets,
    TF_Buffer run_metadata,
    TF_Status arg11);
public static native void TF_SessionRun(
    TF_Session session,
    @Const TF_Buffer run_options,
    @Const TF_Output inputs, @ByPtrPtr TF_Tensor input_values, int ninputs,
    @Const TF_Output outputs, @ByPtrPtr TF_Tensor output_values, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    TF_Buffer run_metadata,
    TF_Status arg11);

// Set up the graph with the intended feeds (inputs) and fetches (outputs) for a
// sequence of partial run calls.
//
// On success, returns a handle that is used for subsequent PRun calls. The
// handle should be deleted with TF_DeletePRunHandle when it is no longer
// needed.
//
// On failure, out_status contains a tensorflow::Status with an error
// message. *handle is set to nullptr.
public static native void TF_SessionPRunSetup(
    TF_Session arg0,
    @Const TF_Output inputs, int ninputs,
    @Const TF_Output outputs, int noutputs,
    @Cast("const TF_Operation*const*") PointerPointer target_opers, int ntargets,
    @Cast("const char**") PointerPointer handle,
    TF_Status arg8);
public static native void TF_SessionPRunSetup(
    TF_Session arg0,
    @Const TF_Output inputs, int ninputs,
    @Const TF_Output outputs, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    @Cast("const char**") @ByPtrPtr BytePointer handle,
    TF_Status arg8);
public static native void TF_SessionPRunSetup(
    TF_Session arg0,
    @Const TF_Output inputs, int ninputs,
    @Const TF_Output outputs, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    @Cast("const char**") @ByPtrPtr ByteBuffer handle,
    TF_Status arg8);
public static native void TF_SessionPRunSetup(
    TF_Session arg0,
    @Const TF_Output inputs, int ninputs,
    @Const TF_Output outputs, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    @Cast("const char**") @ByPtrPtr byte[] handle,
    TF_Status arg8);

// Continue to run the graph with additional feeds and fetches. The
// execution state is uniquely identified by the handle.
public static native void TF_SessionPRun(
    TF_Session arg0, @Cast("const char*") BytePointer handle,
    @Const TF_Output inputs, @Cast("TF_Tensor*const*") PointerPointer input_values, int ninputs,
    @Const TF_Output outputs, @Cast("TF_Tensor**") PointerPointer output_values, int noutputs,
    @Cast("const TF_Operation*const*") PointerPointer target_opers, int ntargets,
    TF_Status arg10);
public static native void TF_SessionPRun(
    TF_Session arg0, @Cast("const char*") BytePointer handle,
    @Const TF_Output inputs, @ByPtrPtr TF_Tensor input_values, int ninputs,
    @Const TF_Output outputs, @ByPtrPtr TF_Tensor output_values, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    TF_Status arg10);
public static native void TF_SessionPRun(
    TF_Session arg0, String handle,
    @Const TF_Output inputs, @ByPtrPtr TF_Tensor input_values, int ninputs,
    @Const TF_Output outputs, @ByPtrPtr TF_Tensor output_values, int noutputs,
    @Const @ByPtrPtr TF_Operation target_opers, int ntargets,
    TF_Status arg10);

// Deletes a handle allocated by TF_SessionPRunSetup.
// Once called, no more calls to TF_SessionPRun should be made.
public static native void TF_DeletePRunHandle(@Cast("const char*") BytePointer handle);
public static native void TF_DeletePRunHandle(String handle);
// Targeting ../TF_DeprecatedSession.java



public static native TF_DeprecatedSession TF_NewDeprecatedSession(
    @Const TF_SessionOptions arg0, TF_Status status);
public static native void TF_CloseDeprecatedSession(TF_DeprecatedSession arg0,
                                                     TF_Status status);
public static native void TF_DeleteDeprecatedSession(TF_DeprecatedSession arg0,
                                                      TF_Status status);
public static native void TF_Reset(@Const TF_SessionOptions opt,
                                    @Cast("const char**") PointerPointer containers, int ncontainers,
                                    TF_Status status);
public static native void TF_Reset(@Const TF_SessionOptions opt,
                                    @Cast("const char**") @ByPtrPtr BytePointer containers, int ncontainers,
                                    TF_Status status);
public static native void TF_Reset(@Const TF_SessionOptions opt,
                                    @Cast("const char**") @ByPtrPtr ByteBuffer containers, int ncontainers,
                                    TF_Status status);
public static native void TF_Reset(@Const TF_SessionOptions opt,
                                    @Cast("const char**") @ByPtrPtr byte[] containers, int ncontainers,
                                    TF_Status status);
// Treat the bytes proto[0,proto_len-1] as a serialized GraphDef and
// add the nodes in that GraphDef to the graph for the session.
//
// Prefer use of TF_Session and TF_GraphImportGraphDef over this.
public static native void TF_ExtendGraph(TF_DeprecatedSession arg0,
                                          @Const Pointer proto, @Cast("size_t") long proto_len,
                                          TF_Status arg3);

// See TF_SessionRun() above.
public static native void TF_Run(TF_DeprecatedSession arg0,
                                  @Const TF_Buffer run_options,
                                  @Cast("const char**") PointerPointer input_names, @Cast("TF_Tensor**") PointerPointer inputs,
                                  int ninputs, @Cast("const char**") PointerPointer output_names,
                                  @Cast("TF_Tensor**") PointerPointer outputs, int noutputs,
                                  @Cast("const char**") PointerPointer target_oper_names, int ntargets,
                                  TF_Buffer run_metadata, TF_Status arg11);
public static native void TF_Run(TF_DeprecatedSession arg0,
                                  @Const TF_Buffer run_options,
                                  @Cast("const char**") @ByPtrPtr BytePointer input_names, @ByPtrPtr TF_Tensor inputs,
                                  int ninputs, @Cast("const char**") @ByPtrPtr BytePointer output_names,
                                  @ByPtrPtr TF_Tensor outputs, int noutputs,
                                  @Cast("const char**") @ByPtrPtr BytePointer target_oper_names, int ntargets,
                                  TF_Buffer run_metadata, TF_Status arg11);
public static native void TF_Run(TF_DeprecatedSession arg0,
                                  @Const TF_Buffer run_options,
                                  @Cast("const char**") @ByPtrPtr ByteBuffer input_names, @ByPtrPtr TF_Tensor inputs,
                                  int ninputs, @Cast("const char**") @ByPtrPtr ByteBuffer output_names,
                                  @ByPtrPtr TF_Tensor outputs, int noutputs,
                                  @Cast("const char**") @ByPtrPtr ByteBuffer target_oper_names, int ntargets,
                                  TF_Buffer run_metadata, TF_Status arg11);
public static native void TF_Run(TF_DeprecatedSession arg0,
                                  @Const TF_Buffer run_options,
                                  @Cast("const char**") @ByPtrPtr byte[] input_names, @ByPtrPtr TF_Tensor inputs,
                                  int ninputs, @Cast("const char**") @ByPtrPtr byte[] output_names,
                                  @ByPtrPtr TF_Tensor outputs, int noutputs,
                                  @Cast("const char**") @ByPtrPtr byte[] target_oper_names, int ntargets,
                                  TF_Buffer run_metadata, TF_Status arg11);

// See TF_SessionPRunSetup() above.
public static native void TF_PRunSetup(TF_DeprecatedSession arg0,
                                        @Cast("const char**") PointerPointer input_names, int ninputs,
                                        @Cast("const char**") PointerPointer output_names, int noutputs,
                                        @Cast("const char**") PointerPointer target_oper_names,
                                        int ntargets, @Cast("const char**") PointerPointer handle,
                                        TF_Status arg8);
public static native void TF_PRunSetup(TF_DeprecatedSession arg0,
                                        @Cast("const char**") @ByPtrPtr BytePointer input_names, int ninputs,
                                        @Cast("const char**") @ByPtrPtr BytePointer output_names, int noutputs,
                                        @Cast("const char**") @ByPtrPtr BytePointer target_oper_names,
                                        int ntargets, @Cast("const char**") @ByPtrPtr BytePointer handle,
                                        TF_Status arg8);
public static native void TF_PRunSetup(TF_DeprecatedSession arg0,
                                        @Cast("const char**") @ByPtrPtr ByteBuffer input_names, int ninputs,
                                        @Cast("const char**") @ByPtrPtr ByteBuffer output_names, int noutputs,
                                        @Cast("const char**") @ByPtrPtr ByteBuffer target_oper_names,
                                        int ntargets, @Cast("const char**") @ByPtrPtr ByteBuffer handle,
                                        TF_Status arg8);
public static native void TF_PRunSetup(TF_DeprecatedSession arg0,
                                        @Cast("const char**") @ByPtrPtr byte[] input_names, int ninputs,
                                        @Cast("const char**") @ByPtrPtr byte[] output_names, int noutputs,
                                        @Cast("const char**") @ByPtrPtr byte[] target_oper_names,
                                        int ntargets, @Cast("const char**") @ByPtrPtr byte[] handle,
                                        TF_Status arg8);

// See TF_SessionPRun above.
public static native void TF_PRun(TF_DeprecatedSession arg0, @Cast("const char*") BytePointer handle,
                                   @Cast("const char**") PointerPointer input_names, @Cast("TF_Tensor**") PointerPointer inputs,
                                   int ninputs, @Cast("const char**") PointerPointer output_names,
                                   @Cast("TF_Tensor**") PointerPointer outputs, int noutputs,
                                   @Cast("const char**") PointerPointer target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, @Cast("const char*") BytePointer handle,
                                   @Cast("const char**") @ByPtrPtr BytePointer input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr BytePointer output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr BytePointer target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, String handle,
                                   @Cast("const char**") @ByPtrPtr ByteBuffer input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr ByteBuffer output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr ByteBuffer target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, @Cast("const char*") BytePointer handle,
                                   @Cast("const char**") @ByPtrPtr byte[] input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr byte[] output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr byte[] target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, String handle,
                                   @Cast("const char**") @ByPtrPtr BytePointer input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr BytePointer output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr BytePointer target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, @Cast("const char*") BytePointer handle,
                                   @Cast("const char**") @ByPtrPtr ByteBuffer input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr ByteBuffer output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr ByteBuffer target_oper_names, int ntargets,
                                   TF_Status arg10);
public static native void TF_PRun(TF_DeprecatedSession arg0, String handle,
                                   @Cast("const char**") @ByPtrPtr byte[] input_names, @ByPtrPtr TF_Tensor inputs,
                                   int ninputs, @Cast("const char**") @ByPtrPtr byte[] output_names,
                                   @ByPtrPtr TF_Tensor outputs, int noutputs,
                                   @Cast("const char**") @ByPtrPtr byte[] target_oper_names, int ntargets,
                                   TF_Status arg10);
// Targeting ../TF_DeviceList.java



// Lists all devices in a TF_Session.
//
// Caller takes ownership of the returned TF_DeviceList* which must eventually
// be freed with a call to TF_DeleteDeviceList.
public static native TF_DeviceList TF_SessionListDevices(TF_Session session,
                                                           TF_Status status);

// Lists all devices in a TF_Session.
//
// Caller takes ownership of the returned TF_DeviceList* which must eventually
// be freed with a call to TF_DeleteDeviceList.
public static native TF_DeviceList TF_DeprecatedSessionListDevices(
    TF_DeprecatedSession session, TF_Status status);

// Deallocates the device list.
public static native void TF_DeleteDeviceList(TF_DeviceList list);

// Counts the number of elements in the device list.
public static native int TF_DeviceListCount(@Const TF_DeviceList list);

// Retrieves the full name of the device (e.g. /job:worker/replica:0/...)
// The return value will be a pointer to a null terminated string. The caller
// must not modify or delete the string. It will be deallocated upon a call to
// TF_DeleteDeviceList.
//
// If index is out of bounds, an error code will be set in the status object,
// and a null pointer will be returned.
public static native @Cast("const char*") BytePointer TF_DeviceListName(@Const TF_DeviceList list,
                                                    int index,
                                                    TF_Status status);

// Retrieves the type of the device at the given index.
//
// The caller must not modify or delete the string. It will be deallocated upon
// a call to TF_DeleteDeviceList.
//
// If index is out of bounds, an error code will be set in the status object,
// and a null pointer will be returned.
public static native @Cast("const char*") BytePointer TF_DeviceListType(@Const TF_DeviceList list,
                                                    int index,
                                                    TF_Status status);

// Retrieve the amount of memory associated with a given device.
//
// If index is out of bounds, an error code will be set in the status object,
// and -1 will be returned.
public static native @Cast("int64_t") long TF_DeviceListMemoryBytes(
    @Const TF_DeviceList list, int index, TF_Status status);

// Retrieve the incarnation number of a given device.
//
// If index is out of bounds, an error code will be set in the status object,
// and 0 will be returned.
public static native @Cast("uint64_t") long TF_DeviceListIncarnation(
    @Const TF_DeviceList list, int index, TF_Status status);
// Targeting ../TF_Library.java



// Load the library specified by library_filename and register the ops and
// kernels present in that library.
//
// Pass "library_filename" to a platform-specific mechanism for dynamically
// loading a library. The rules for determining the exact location of the
// library are platform-specific and are not documented here.
//
// On success, place OK in status and return the newly created library handle.
// The caller owns the library handle.
//
// On failure, place an error status in status and return NULL.
public static native TF_Library TF_LoadLibrary(@Cast("const char*") BytePointer library_filename,
                                                 TF_Status status);
public static native TF_Library TF_LoadLibrary(String library_filename,
                                                 TF_Status status);

// Get the OpList of OpDefs defined in the library pointed by lib_handle.
//
// Returns a TF_Buffer. The memory pointed to by the result is owned by
// lib_handle. The data in the buffer will be the serialized OpList proto for
// ops defined in the library.
public static native @ByVal TF_Buffer TF_GetOpList(TF_Library lib_handle);

// Frees the memory associated with the library handle.
// Does NOT unload the library.
public static native void TF_DeleteLibraryHandle(TF_Library lib_handle);

// Get the OpList of all OpDefs defined in this address space.
// Returns a TF_Buffer, ownership of which is transferred to the caller
// (and can be freed using TF_DeleteBuffer).
//
// The data in the buffer will be the serialized OpList proto for ops registered
// in this address space.
public static native TF_Buffer TF_GetAllOpList();
// Targeting ../TF_ApiDefMap.java



// Creates a new TF_ApiDefMap instance.
//
// Params:
//  op_list_buffer - TF_Buffer instance containing serialized OpList
//    protocol buffer. (See
//    https://www.tensorflow.org/code/tensorflow/core/framework/op_def.proto
//    for the OpList proto definition).
//  status - Set to OK on success and an appropriate error on failure.
public static native TF_ApiDefMap TF_NewApiDefMap(TF_Buffer op_list_buffer,
                                                    TF_Status status);

// Deallocates a TF_ApiDefMap.
public static native void TF_DeleteApiDefMap(TF_ApiDefMap apimap);

// Add ApiDefs to the map.
//
// `text` corresponds to a text representation of an ApiDefs protocol message.
// (https://www.tensorflow.org/code/tensorflow/core/framework/api_def.proto).
//
// The provided ApiDefs will be merged with existing ones in the map, with
// precedence given to the newly added version in case of conflicts with
// previous calls to TF_ApiDefMapPut.
public static native void TF_ApiDefMapPut(TF_ApiDefMap api_def_map,
                                           @Cast("const char*") BytePointer text, @Cast("size_t") long text_len,
                                           TF_Status status);
public static native void TF_ApiDefMapPut(TF_ApiDefMap api_def_map,
                                           String text, @Cast("size_t") long text_len,
                                           TF_Status status);

// Returns a serialized ApiDef protocol buffer for the TensorFlow operation
// named `name`.
public static native TF_Buffer TF_ApiDefMapGet(TF_ApiDefMap api_def_map,
                                                 @Cast("const char*") BytePointer name,
                                                 @Cast("size_t") long name_len,
                                                 TF_Status status);
public static native TF_Buffer TF_ApiDefMapGet(TF_ApiDefMap api_def_map,
                                                 String name,
                                                 @Cast("size_t") long name_len,
                                                 TF_Status status);

// --------------------------------------------------------------------------
// Kernel definition information.

// Returns a serialized KernelList protocol buffer containing KernelDefs for all
// registered kernels.
public static native TF_Buffer TF_GetAllRegisteredKernels(TF_Status status);

// Returns a serialized KernelList protocol buffer containing KernelDefs for all
// kernels registered for the operation named `name`.
public static native TF_Buffer TF_GetRegisteredKernelsForOp(
    @Cast("const char*") BytePointer name, TF_Status status);
public static native TF_Buffer TF_GetRegisteredKernelsForOp(
    String name, TF_Status status);

// Update edge, switch input/ output in a node
public static native void TF_UpdateEdge(TF_Graph graph, @ByVal TF_Output new_src,
                                         @ByVal TF_Input dst, TF_Status status);
// Targeting ../TF_Server.java



// Creates a new in-process TensorFlow server configured using a serialized
// ServerDef protocol buffer provided via `proto` and `proto_len`.
//
// The server will not serve any requests until TF_ServerStart is invoked.
// The server will stop serving requests once TF_ServerStop or
// TF_DeleteServer is invoked.
public static native TF_Server TF_NewServer(@Const Pointer proto,
                                              @Cast("size_t") long proto_len,
                                              TF_Status status);

// Starts an in-process TensorFlow server.
public static native void TF_ServerStart(TF_Server server, TF_Status status);

// Stops an in-process TensorFlow server.
public static native void TF_ServerStop(TF_Server server, TF_Status status);

// Blocks until the server has been successfully stopped (via TF_ServerStop or
// TF_ServerClose).
public static native void TF_ServerJoin(TF_Server server, TF_Status status);

// Returns the target string that can be provided to TF_SetTarget() to connect
// a TF_Session to `server`.
//
// The returned string is valid only until TF_DeleteServer is invoked.
public static native @Cast("const char*") BytePointer TF_ServerTarget(TF_Server server);

// Destroy an in-process TensorFlow server, frees memory. If server is running
// it will be stopped and joined.
public static native void TF_DeleteServer(TF_Server server);
// Targeting ../Listener_BytePointer.java


public static native void TF_RegisterLogListener(
    Listener_BytePointer listener);
// Targeting ../Listener_String.java


public static native void TF_RegisterLogListener(
    Listener_String listener);

// Register a FileSystem plugin from filename `plugin_filename`.
//
// On success, place OK in status.
// On failure, place an error status in status.
public static native void TF_RegisterFilesystemPlugin(
    @Cast("const char*") BytePointer plugin_filename, TF_Status status);
public static native void TF_RegisterFilesystemPlugin(
    String plugin_filename, TF_Status status);

// Apis that are corresponding to python c api. --------------------

// Add control input to `op`.
public static native void TF_AddOperationControlInput(TF_Graph graph,
                                                       TF_Operation op,
                                                       TF_Operation input);

// Changes an attr value in the node_def Protocol Buffer and sets a status upon
// completion.
public static native void TF_SetAttr(TF_Graph graph, TF_Operation op,
                                      @Cast("const char*") BytePointer attr_name,
                                      TF_Buffer attr_value_proto,
                                      TF_Status status);
public static native void TF_SetAttr(TF_Graph graph, TF_Operation op,
                                      String attr_name,
                                      TF_Buffer attr_value_proto,
                                      TF_Status status);

// Clears the attr in the node_def Protocol Buffer and sets a status upon
// completion.
public static native void TF_ClearAttr(TF_Graph graph, TF_Operation op,
                                        @Cast("const char*") BytePointer attr_name,
                                        TF_Status status);
public static native void TF_ClearAttr(TF_Graph graph, TF_Operation op,
                                        String attr_name,
                                        TF_Status status);

// Sets the experimental_type` field in the node_def Protocol Buffer.
public static native void TF_SetFullType(TF_Graph graph, TF_Operation op,
                                          @Const TF_Buffer full_type_proto);

// Set the requested device for `graph`.
public static native void TF_SetRequestedDevice(TF_Graph graph,
                                                 TF_Operation op,
                                                 @Cast("const char*") BytePointer device);
public static native void TF_SetRequestedDevice(TF_Graph graph,
                                                 TF_Operation op,
                                                 String device);

// Remove all the control inputs from `op` in `graph`.
public static native void TF_RemoveAllControlInputs(TF_Graph graph,
                                                     TF_Operation op);

// Set if `graph` requires shape inference functions.
public static native void TF_SetRequireShapeInferenceFns(TF_Graph graph,
                                                          @Cast("bool") boolean require);

// Extends `session` with any new operations added to its associated graph.
// Usually this happens automatically in TF_SessionRun. After this is called,
// TF_SessionRun will no longer extend the session on every call.
//
// We expose this here to allow fine-grained synchronization in multi-threaded
// workloads, which is required since the Python implementation depends on the
// above mutation methods. This allows us to prevent modifications to nodes in
// the graph after the session has been made aware of them.
public static native void TF_ExtendSession(TF_Session session,
                                            TF_Status status);

// Returns the serialized CppShapeInferenceResult::HandleData proto for
// `output` if its a resource or variant tensor, or otherwise returns the empty
// string.
public static native TF_Buffer TF_GetHandleShapeAndType(TF_Graph graph,
                                                          @ByVal TF_Output output);

// Sets `output` based on `proto`, which should be a serialized
// CppShapeInferenceResult::HandleData proto. `output` should be a resource
// or variant tensor.
// NOTE(skyewm): `proto` is passed a void*/size_t pair instead of a std::string
// because I couldn't get SWIG to work otherwise.
public static native void TF_SetHandleShapeAndType(TF_Graph graph,
                                                    @ByVal TF_Output output,
                                                    @Const Pointer proto,
                                                    @Cast("size_t") long proto_len,
                                                    TF_Status status);

// This method is used to add a new input edge to 'dst', which must be a While
// op. The While op's "T" attribute must have already been updated to include
// the new edge. This is used to construct tf.while_loop gradients.
public static native void TF_AddWhileInputHack(TF_Graph graph,
                                                @ByVal TF_Output new_src,
                                                TF_Operation dst,
                                                TF_Status status);

// ----------------------------------------------------------------

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_C_API_H_


// Parsed from tensorflow/c/tf_tstring.h

/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// #ifndef TENSORFLOW_C_TF_TSTRING_H_
// #define TENSORFLOW_C_TF_TSTRING_H_

// #include "tensorflow/c/c_api_macros.h"
// #include "tensorflow/c/tf_tensor.h"
// #include "tensorflow/core/platform/ctstring.h"

// #ifdef __cplusplus
// #endif

public static native void TF_StringInit(TF_TString t);

public static native void TF_StringCopy(TF_TString dst, @Cast("const char*") BytePointer src,
                                         @Cast("size_t") long size);
public static native void TF_StringCopy(TF_TString dst, String src,
                                         @Cast("size_t") long size);

public static native void TF_StringAssignView(TF_TString dst, @Cast("const char*") BytePointer src,
                                               @Cast("size_t") long size);
public static native void TF_StringAssignView(TF_TString dst, String src,
                                               @Cast("size_t") long size);

public static native @Cast("const char*") BytePointer TF_StringGetDataPointer(
    @Const TF_TString tstr);

public static native @Cast("TF_TString_Type") int TF_StringGetType(@Const TF_TString str);

public static native @Cast("size_t") long TF_StringGetSize(@Const TF_TString tstr);

public static native @Cast("size_t") long TF_StringGetCapacity(@Const TF_TString str);

public static native void TF_StringDealloc(TF_TString tstr);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_TF_TSTRING_H_


// Parsed from tensorflow/c/eager/c_api.h

/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_C_EAGER_C_API_H_
// #define TENSORFLOW_C_EAGER_C_API_H_

// C API extensions to experiment with eager execution of kernels.
// WARNING: Unlike tensorflow/c/c_api.h, the API here is not guaranteed to be
// stable and can change without notice.

// #include "tensorflow/c/c_api.h"
// #include "tensorflow/c/c_api_macros.h"

// #ifdef __cplusplus
// Targeting ../TFE_ContextOptions.java



// Return a new options object.
public static native TFE_ContextOptions TFE_NewContextOptions();

// Set the config in TF_ContextOptions.options.
// config should be a serialized tensorflow.ConfigProto proto.
// If config was not parsed successfully as a ConfigProto, record the
// error information in *status.
public static native void TFE_ContextOptionsSetConfig(
    TFE_ContextOptions options, @Const Pointer proto, @Cast("size_t") long proto_len,
    TF_Status status);

// Controls how to act when we try to run an operation on a given device but
// some input tensors are not on that device.
// LINT.IfChange
// Note: Keep in sync with internal copy of enum in eager/context.h.
/** enum TFE_ContextDevicePlacementPolicy */
public static final int
  // Running operations with input tensors on the wrong device will fail.
  TFE_DEVICE_PLACEMENT_EXPLICIT = 0,
  // Copy the tensor to the right device but log a warning.
  TFE_DEVICE_PLACEMENT_WARN = 1,
  // Silently copy the tensor, which has a performance cost since the operation
  // will be blocked till the copy completes. This is the default placement
  // policy.
  TFE_DEVICE_PLACEMENT_SILENT = 2,
  // Placement policy which silently copies int32 tensors but not other dtypes.
  TFE_DEVICE_PLACEMENT_SILENT_FOR_INT32 = 3;
// LINT.ThenChange(//tensorflow/c/eager/immediate_execution_context.h)

// Sets the default execution mode (sync/async). Note that this can be
// overridden per thread using TFE_ContextSetExecutorForThread.
public static native void TFE_ContextOptionsSetAsync(TFE_ContextOptions arg0,
                                                      @Cast("unsigned char") byte enable);

public static native void TFE_ContextOptionsSetDevicePlacementPolicy(
    TFE_ContextOptions arg0, @Cast("TFE_ContextDevicePlacementPolicy") int arg1);

// Destroy an options object.
public static native void TFE_DeleteContextOptions(TFE_ContextOptions arg0);
// Targeting ../TFE_Context.java



public static native TFE_Context TFE_NewContext(
    @Const TFE_ContextOptions opts, TF_Status status);
public static native void TFE_DeleteContext(TFE_Context ctx);
public static native TF_DeviceList TFE_ContextListDevices(TFE_Context ctx,
                                                            TF_Status status);

// Clears the internal caches in the TFE context. Useful when reseeding random
// ops.
public static native void TFE_ContextClearCaches(TFE_Context ctx);

// Sets a thread-local device placement policy. After this call, other calls to
// TFE_Execute in the same thread will use the device policy specified here
// instead of the device policy used to construct the context. This has no
// effect on the device policy used by other program threads.
public static native void TFE_ContextSetThreadLocalDevicePlacementPolicy(
    TFE_Context ctx, @Cast("TFE_ContextDevicePlacementPolicy") int policy);

// Returns the device placement policy to be used by this context in the current
// thread.
public static native @Cast("TFE_ContextDevicePlacementPolicy") int TFE_ContextGetDevicePlacementPolicy(TFE_Context ctx);

// A tensorflow.ServerDef specifies remote workers (in addition to the current
// workers name). Operations created in this context can then be executed on
// any of these remote workers by setting an appropriate device.
//
// If the following is set, all servers identified by the
// ServerDef must be up when the context is created.
public static native void TFE_ContextSetServerDef(TFE_Context ctx,
                                                   int keep_alive_secs,
                                                   @Const Pointer proto,
                                                   @Cast("size_t") long proto_len,
                                                   TF_Status status);
// Targeting ../TFE_TensorHandle.java



public static native TFE_TensorHandle TFE_NewTensorHandle(@Const TF_Tensor t,
                                                            TF_Status status);
// Indicates that the caller will not be using `h` any more.
public static native void TFE_DeleteTensorHandle(TFE_TensorHandle h);
public static native @Cast("TF_DataType") int TFE_TensorHandleDataType(TFE_TensorHandle h);
// This function will block till the operation that produces `h` has completed.
public static native int TFE_TensorHandleNumDims(TFE_TensorHandle h,
                                                  TF_Status status);
public static native @Cast("int64_t") long TFE_TensorHandleNumElements(TFE_TensorHandle h,
                                                          TF_Status status);
// This function will block till the operation that produces `h` has completed.
public static native @Cast("int64_t") long TFE_TensorHandleDim(TFE_TensorHandle h,
                                                  int dim_index,
                                                  TF_Status status);

// Returns the device of the operation that produced `h`. If `h` was produced by
// a copy, returns the destination device of the copy. Note that the returned
// device name is not always the device holding the tensor handle's memory. If
// you want the latter, use TFE_TensorHandleBackingDeviceName. This function
// will block till the operation that produces `h` has completed.
public static native @Cast("const char*") BytePointer TFE_TensorHandleDeviceName(
    TFE_TensorHandle h, TF_Status status);

// Returns the name of the device in whose memory `h` resides.
//
// This function will block till the operation that produces `h` has completed.
public static native @Cast("const char*") BytePointer TFE_TensorHandleBackingDeviceName(
    TFE_TensorHandle h, TF_Status status);

// Return a pointer to a new TFE_TensorHandle that shares the underlying tensor
// with `h`. On success, `status` is set to OK. On failure, `status` reflects
// the error and a nullptr is returned.
public static native TFE_TensorHandle TFE_TensorHandleCopySharingTensor(
    TFE_TensorHandle h, TF_Status status);

// This function will block till the operation that produces `h` has
// completed. The memory returned might alias the internal memory used by
// TensorFlow. Hence, callers should not mutate this memory (for example by
// modifying the memory region pointed to by TF_TensorData() on the returned
// TF_Tensor).
public static native TF_Tensor TFE_TensorHandleResolve(TFE_TensorHandle h,
                                                         TF_Status status);

// Create a new TFE_TensorHandle with the same contents as 'h' but placed
// in the memory of the device name 'device_name'.
// If source and destination are the same device, then this creates a new handle
// that shares the underlying buffer. Otherwise, it currently requires at least
// one of the source or destination devices to be CPU (i.e., for the source or
// destination tensor to be placed in host memory).
// If async execution is enabled, the copy may be enqueued and the call will
// return "non-ready" handle. Else, this function returns after the copy has
// been done.
public static native TFE_TensorHandle TFE_TensorHandleCopyToDevice(
    TFE_TensorHandle h, TFE_Context ctx, @Cast("const char*") BytePointer device_name,
    TF_Status status);
public static native TFE_TensorHandle TFE_TensorHandleCopyToDevice(
    TFE_TensorHandle h, TFE_Context ctx, String device_name,
    TF_Status status);
// Targeting ../TFE_TensorDebugInfo.java



// Retrieves TFE_TensorDebugInfo for `handle`.
// If TFE_TensorHandleTensorDebugInfo succeeds, `status` is set to OK and caller
// is responsible for deleting returned TFE_TensorDebugInfo.
// If TFE_TensorHandleTensorDebugInfo fails, `status` is set to appropriate
// error and nullptr is returned. This function can block till the operation
// that produces `handle` has completed.
public static native TFE_TensorDebugInfo TFE_TensorHandleTensorDebugInfo(
    TFE_TensorHandle h, TF_Status status);

// Deletes `debug_info`.
public static native void TFE_DeleteTensorDebugInfo(
    TFE_TensorDebugInfo debug_info);

// Returns the number of dimensions used to represent the tensor on its device.
// The number of dimensions used to represent the tensor on device can be
// different from the number returned by TFE_TensorHandleNumDims.
// The return value was current at the time of TFE_TensorDebugInfo creation.
public static native int TFE_TensorDebugInfoOnDeviceNumDims(
    TFE_TensorDebugInfo debug_info);

// Returns the number of elements in dimension `dim_index`.
// Tensor representation on device can be transposed from its representation
// on host. The data contained in dimension `dim_index` on device
// can correspond to the data contained in another dimension in on-host
// representation. The dimensions are indexed using the standard TensorFlow
// major-to-minor order (slowest varying dimension first),
// not the XLA's minor-to-major order.
// On-device dimensions can be padded. TFE_TensorDebugInfoOnDeviceDim returns
// the number of elements in a dimension after padding.
// The return value was current at the time of TFE_TensorDebugInfo creation.
public static native @Cast("int64_t") long TFE_TensorDebugInfoOnDeviceDim(
    TFE_TensorDebugInfo debug_info, int dim_index);
// Targeting ../TFE_Op.java



public static native TFE_Op TFE_NewOp(TFE_Context ctx,
                                        @Cast("const char*") BytePointer op_or_function_name,
                                        TF_Status status);
public static native TFE_Op TFE_NewOp(TFE_Context ctx,
                                        String op_or_function_name,
                                        TF_Status status);
public static native void TFE_DeleteOp(TFE_Op op);

// Returns the op or function name `op` will execute.
//
// The returned string remains valid throughout the lifetime of 'op'.
public static native @Cast("const char*") BytePointer TFE_OpGetName(@Const TFE_Op op,
                                                TF_Status status);
public static native TFE_Context TFE_OpGetContext(@Const TFE_Op op,
                                                    TF_Status status);

public static native void TFE_OpSetDevice(TFE_Op op, @Cast("const char*") BytePointer device_name,
                                           TF_Status status);
public static native void TFE_OpSetDevice(TFE_Op op, String device_name,
                                           TF_Status status);
// The returned string remains valid throughout the lifetime of 'op'.
public static native @Cast("const char*") BytePointer TFE_OpGetDevice(@Const TFE_Op op,
                                                  TF_Status status);

public static native void TFE_OpAddInput(TFE_Op op, TFE_TensorHandle input,
                                          TF_Status status);

public static native void TFE_OpAddInputList(TFE_Op op,
                                              @Cast("TFE_TensorHandle**") PointerPointer inputs,
                                              int num_inputs,
                                              TF_Status status);
public static native void TFE_OpAddInputList(TFE_Op op,
                                              @ByPtrPtr TFE_TensorHandle inputs,
                                              int num_inputs,
                                              TF_Status status);

// Fetches the current number of inputs attached to `op`.
//
// Does not use the operation's definition to determine how many inputs should
// be attached. It is intended for use with TFE_OpGetFlatInput to inspect an
// already-finalized operation.
//
// Note that TFE_OpGetFlatInputCount and TFE_OpGetFlatInput operate on a flat
// sequence of inputs, unlike TFE_OpGetInputLength (for getting the length of a
// particular named input list, which may only be part of the op's inputs).
public static native int TFE_OpGetFlatInputCount(@Const TFE_Op op,
                                                  TF_Status status);
// Returns a borrowed reference to one of `op`'s inputs. Use
// `TFE_TensorHandleCopySharingTensor` to make a new reference.
public static native TFE_TensorHandle TFE_OpGetFlatInput(@Const TFE_Op op,
                                                           int index,
                                                           TF_Status status);

public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("unsigned char*") BytePointer is_list,
                                                    TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    String attr_name,
                                                    @Cast("unsigned char*") ByteBuffer is_list,
                                                    TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("unsigned char*") byte[] is_list,
                                                    TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    String attr_name,
                                                    @Cast("unsigned char*") BytePointer is_list,
                                                    TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    @Cast("const char*") BytePointer attr_name,
                                                    @Cast("unsigned char*") ByteBuffer is_list,
                                                    TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpGetAttrType(TFE_Op op,
                                                    String attr_name,
                                                    @Cast("unsigned char*") byte[] is_list,
                                                    TF_Status status);
// Get an attribute type given an op name; a fusion of TFE_NewOp and
// TFE_OpGetAttrType for use from Python without the overhead of the individual
// calls and memory management of TFE_Op.
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, @Cast("const char*") BytePointer op_or_function_name, @Cast("const char*") BytePointer attr_name,
    @Cast("unsigned char*") BytePointer is_list, TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, String op_or_function_name, String attr_name,
    @Cast("unsigned char*") ByteBuffer is_list, TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, @Cast("const char*") BytePointer op_or_function_name, @Cast("const char*") BytePointer attr_name,
    @Cast("unsigned char*") byte[] is_list, TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, String op_or_function_name, String attr_name,
    @Cast("unsigned char*") BytePointer is_list, TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, @Cast("const char*") BytePointer op_or_function_name, @Cast("const char*") BytePointer attr_name,
    @Cast("unsigned char*") ByteBuffer is_list, TF_Status status);
public static native @Cast("TF_AttrType") int TFE_OpNameGetAttrType(
    TFE_Context ctx, String op_or_function_name, String attr_name,
    @Cast("unsigned char*") byte[] is_list, TF_Status status);

public static native void TFE_OpSetAttrString(TFE_Op op,
                                               @Cast("const char*") BytePointer attr_name,
                                               @Const Pointer value,
                                               @Cast("size_t") long length);
public static native void TFE_OpSetAttrString(TFE_Op op,
                                               String attr_name,
                                               @Const Pointer value,
                                               @Cast("size_t") long length);
public static native void TFE_OpSetAttrInt(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                            @Cast("int64_t") long value);
public static native void TFE_OpSetAttrInt(TFE_Op op, String attr_name,
                                            @Cast("int64_t") long value);
public static native void TFE_OpSetAttrFloat(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                              float value);
public static native void TFE_OpSetAttrFloat(TFE_Op op, String attr_name,
                                              float value);
public static native void TFE_OpSetAttrBool(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                             @Cast("unsigned char") byte value);
public static native void TFE_OpSetAttrBool(TFE_Op op, String attr_name,
                                             @Cast("unsigned char") byte value);
public static native void TFE_OpSetAttrType(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                             @Cast("TF_DataType") int value);
public static native void TFE_OpSetAttrType(TFE_Op op, String attr_name,
                                             @Cast("TF_DataType") int value);
// If the number of dimensions is unknown, `num_dims` must be set to
// -1 and `dims` can be null.  If a dimension is unknown, the
// corresponding entry in the `dims` array must be -1.
public static native void TFE_OpSetAttrShape(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                              @Cast("const int64_t*") LongPointer dims,
                                              int num_dims,
                                              TF_Status out_status);
public static native void TFE_OpSetAttrShape(TFE_Op op, String attr_name,
                                              @Cast("const int64_t*") LongBuffer dims,
                                              int num_dims,
                                              TF_Status out_status);
public static native void TFE_OpSetAttrShape(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                              @Cast("const int64_t*") long[] dims,
                                              int num_dims,
                                              TF_Status out_status);
public static native void TFE_OpSetAttrShape(TFE_Op op, String attr_name,
                                              @Cast("const int64_t*") LongPointer dims,
                                              int num_dims,
                                              TF_Status out_status);
public static native void TFE_OpSetAttrShape(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                              @Cast("const int64_t*") LongBuffer dims,
                                              int num_dims,
                                              TF_Status out_status);
public static native void TFE_OpSetAttrShape(TFE_Op op, String attr_name,
                                              @Cast("const int64_t*") long[] dims,
                                              int num_dims,
                                              TF_Status out_status);

// Sets the attribute attr_name to be a function specified by 'function'.
//
// TODO(ashankar,iga): Add this functionality to the C API for graph
// construction. Perhaps we want an AttrValueMap equivalent in the C API?
public static native void TFE_OpSetAttrFunction(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Const TFE_Op value);
public static native void TFE_OpSetAttrFunction(TFE_Op op,
                                                 String attr_name,
                                                 @Const TFE_Op value);

public static native void TFE_OpSetAttrFunctionName(TFE_Op op, @Cast("const char*") BytePointer attr_name,
                                              @Cast("const char*") BytePointer data, @Cast("size_t") long length);
public static native void TFE_OpSetAttrFunctionName(TFE_Op op, String attr_name,
                                              String data, @Cast("size_t") long length);

public static native void TFE_OpSetAttrTensor(TFE_Op op,
                                               @Cast("const char*") BytePointer attr_name,
                                               TF_Tensor tensor,
                                               TF_Status status);
public static native void TFE_OpSetAttrTensor(TFE_Op op,
                                               String attr_name,
                                               TF_Tensor tensor,
                                               TF_Status status);

public static native void TFE_OpSetAttrStringList(TFE_Op op,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("const void*const*") PointerPointer values,
                                                   @Cast("const size_t*") SizeTPointer lengths,
                                                   int num_values);
public static native void TFE_OpSetAttrStringList(TFE_Op op,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Cast("const void*const*") @ByPtrPtr Pointer values,
                                                   @Cast("const size_t*") SizeTPointer lengths,
                                                   int num_values);
public static native void TFE_OpSetAttrStringList(TFE_Op op,
                                                   String attr_name,
                                                   @Cast("const void*const*") @ByPtrPtr Pointer values,
                                                   @Cast("const size_t*") SizeTPointer lengths,
                                                   int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("const int64_t*") LongPointer values,
                                                int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                String attr_name,
                                                @Cast("const int64_t*") LongBuffer values,
                                                int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("const int64_t*") long[] values,
                                                int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                String attr_name,
                                                @Cast("const int64_t*") LongPointer values,
                                                int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                @Cast("const char*") BytePointer attr_name,
                                                @Cast("const int64_t*") LongBuffer values,
                                                int num_values);
public static native void TFE_OpSetAttrIntList(TFE_Op op,
                                                String attr_name,
                                                @Cast("const int64_t*") long[] values,
                                                int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Const FloatPointer values,
                                                  int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  String attr_name,
                                                  @Const FloatBuffer values,
                                                  int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Const float[] values,
                                                  int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  String attr_name,
                                                  @Const FloatPointer values,
                                                  int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  @Cast("const char*") BytePointer attr_name,
                                                  @Const FloatBuffer values,
                                                  int num_values);
public static native void TFE_OpSetAttrFloatList(TFE_Op op,
                                                  String attr_name,
                                                  @Const float[] values,
                                                  int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const unsigned char*") BytePointer values,
                                                 int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const unsigned char*") ByteBuffer values,
                                                 int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const unsigned char*") byte[] values,
                                                 int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const unsigned char*") BytePointer values,
                                                 int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const unsigned char*") ByteBuffer values,
                                                 int num_values);
public static native void TFE_OpSetAttrBoolList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const unsigned char*") byte[] values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const TF_DataType*") IntPointer values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const TF_DataType*") IntBuffer values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const TF_DataType*") int[] values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const TF_DataType*") IntPointer values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 @Cast("const char*") BytePointer attr_name,
                                                 @Cast("const TF_DataType*") IntBuffer values,
                                                 int num_values);
public static native void TFE_OpSetAttrTypeList(TFE_Op op,
                                                 String attr_name,
                                                 @Cast("const TF_DataType*") int[] values,
                                                 int num_values);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, @Cast("const char*") BytePointer attr_name, @Cast("const int64_t**") PointerPointer dims,
    @Const IntPointer num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, @Cast("const char*") BytePointer attr_name, @Cast("const int64_t**") @ByPtrPtr LongPointer dims,
    @Const IntPointer num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, String attr_name, @Cast("const int64_t**") @ByPtrPtr LongBuffer dims,
    @Const IntBuffer num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, @Cast("const char*") BytePointer attr_name, @Cast("const int64_t**") @ByPtrPtr long[] dims,
    @Const int[] num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, String attr_name, @Cast("const int64_t**") @ByPtrPtr LongPointer dims,
    @Const IntPointer num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, @Cast("const char*") BytePointer attr_name, @Cast("const int64_t**") @ByPtrPtr LongBuffer dims,
    @Const IntBuffer num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrShapeList(
    TFE_Op op, String attr_name, @Cast("const int64_t**") @ByPtrPtr long[] dims,
    @Const int[] num_dims, int num_values, TF_Status out_status);
public static native void TFE_OpSetAttrFunctionList(TFE_Op op,
                                                     @Cast("const char*") BytePointer attr_name,
                                                     @Cast("const TFE_Op**") PointerPointer value,
                                                     int num_values);
public static native void TFE_OpSetAttrFunctionList(TFE_Op op,
                                                     @Cast("const char*") BytePointer attr_name,
                                                     @Const @ByPtrPtr TFE_Op value,
                                                     int num_values);
public static native void TFE_OpSetAttrFunctionList(TFE_Op op,
                                                     String attr_name,
                                                     @Const @ByPtrPtr TFE_Op value,
                                                     int num_values);

// Returns the length (number of tensors) of the input argument `input_name`
// found in the provided `op`.
public static native int TFE_OpGetInputLength(TFE_Op op,
                                               @Cast("const char*") BytePointer input_name,
                                               TF_Status status);
public static native int TFE_OpGetInputLength(TFE_Op op,
                                               String input_name,
                                               TF_Status status);

// Returns the length (number of tensors) of the output argument `output_name`
// found in the provided `op`.
public static native int TFE_OpGetOutputLength(TFE_Op op,
                                                @Cast("const char*") BytePointer output_name,
                                                TF_Status status);
public static native int TFE_OpGetOutputLength(TFE_Op op,
                                                String output_name,
                                                TF_Status status);

// Execute the operation defined by 'op' and return handles to computed
// tensors in `retvals`.
//
// 'retvals' must point to a pre-allocated array of TFE_TensorHandle* and
// '*num_retvals' should be set to the size of this array. It is an error if
// the size of 'retvals' is less than the number of outputs. This call sets
// *num_retvals to the number of outputs.
//
// If async execution is enabled, the call may simply enqueue the execution
// and return "non-ready" handles in `retvals`. Note that any handles contained
// in 'op' should not be mutated till the kernel execution actually finishes.
//
// For sync execution, if any of the inputs to `op` are not ready, this call
// will block till they become ready and then return when the kernel execution
// is done.
// TODO(agarwal): change num_retvals to int from int*.
public static native void TFE_Execute(TFE_Op op, @Cast("TFE_TensorHandle**") PointerPointer retvals,
                                       IntPointer num_retvals, TF_Status status);
public static native void TFE_Execute(TFE_Op op, @ByPtrPtr TFE_TensorHandle retvals,
                                       IntPointer num_retvals, TF_Status status);
public static native void TFE_Execute(TFE_Op op, @ByPtrPtr TFE_TensorHandle retvals,
                                       IntBuffer num_retvals, TF_Status status);
public static native void TFE_Execute(TFE_Op op, @ByPtrPtr TFE_TensorHandle retvals,
                                       int[] num_retvals, TF_Status status);

// Add a function (serialized FunctionDef protocol buffer) to ctx so
// that it can be invoked using TFE_Execute.
public static native void TFE_ContextAddFunctionDef(
    TFE_Context ctx, @Cast("const char*") BytePointer serialized_function_def, @Cast("size_t") long size,
    TF_Status status);
public static native void TFE_ContextAddFunctionDef(
    TFE_Context ctx, String serialized_function_def, @Cast("size_t") long size,
    TF_Status status);

// Adds a function (created from TF_GraphToFunction or
// TF_FunctionImportFunctionDef) to the context, allowing it to be executed with
// TFE_Execute by creating an op with the same name as the function.
public static native void TFE_ContextAddFunction(TFE_Context ctx,
                                                  TF_Function function,
                                                  TF_Status status);

// Removes a function from the context. Once removed, you can no longer
// TFE_Execute it or TFE_Execute any TFE_Op which has it as an attribute or any
// other function which calls it as an attribute.
public static native void TFE_ContextRemoveFunction(TFE_Context ctx,
                                                     @Cast("const char*") BytePointer name,
                                                     TF_Status status);
public static native void TFE_ContextRemoveFunction(TFE_Context ctx,
                                                     String name,
                                                     TF_Status status);

// Checks whether a function is registered under `name`.
public static native @Cast("unsigned char") byte TFE_ContextHasFunction(TFE_Context ctx,
                                                    @Cast("const char*") BytePointer name);
public static native @Cast("unsigned char") byte TFE_ContextHasFunction(TFE_Context ctx,
                                                    String name);

// Enables tracing of RunMetadata on the ops executed from this context.
public static native void TFE_ContextEnableRunMetadata(TFE_Context ctx);

// Disables tracing of RunMetadata on the ops executed from this context.
public static native void TFE_ContextDisableRunMetadata(TFE_Context ctx);

// Populates the passed-in buffer with a serialized RunMetadata protocol buffer
// containing any run metadata information accumulated so far and clears this
// information.
// If async mode is enabled, this call blocks till all currently pending ops are
// done.
public static native void TFE_ContextExportRunMetadata(TFE_Context ctx,
                                                        TF_Buffer buf,
                                                        TF_Status status);

// Some TF ops need a step container to be set to limit the lifetime of some
// resources (mostly TensorArray and Stack, used in while loop gradients in
// graph mode). Calling this on a context tells it to start a step.
public static native void TFE_ContextStartStep(TFE_Context ctx);

// Ends a step. When there is no active step (that is, every started step has
// been ended) step containers will be cleared. Note: it is not safe to call
// TFE_ContextEndStep while ops that rely on the step container may be running.
public static native void TFE_ContextEndStep(TFE_Context ctx);

// #ifdef __cplusplus
// Targeting ../Tensor.java


  // namespace tensorflow


// #endif

// #endif  // TENSORFLOW_C_EAGER_C_API_H_


// Parsed from tensorflow/c/eager/c_api_experimental.h

/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/
// #ifndef TENSORFLOW_C_EAGER_C_API_EXPERIMENTAL_H_
// #define TENSORFLOW_C_EAGER_C_API_EXPERIMENTAL_H_

// #include "tensorflow/c/c_api.h"
// #include "tensorflow/c/c_api_macros.h"
// #include "tensorflow/c/eager/c_api.h"

// #ifdef __cplusplus
// #endif

// Resets `op_to_reset` with `op_or_function_name` and `raw_device_name`. This
// is for performance optimization by reusing an exiting unused op rather than
// creating a new op every time. If `raw_device_name` is `NULL` or empty, it
// does not set the device name. If it's not `NULL`, then it attempts to parse
// and set the device name. It's effectively `TFE_OpSetDevice`, but it is faster
// than separately calling it because if the existing op has the same
// `raw_device_name`, it skips parsing and just leave as it is.
public static native void TFE_OpReset(TFE_Op op_to_reset,
                                       @Cast("const char*") BytePointer op_or_function_name,
                                       @Cast("const char*") BytePointer raw_device_name,
                                       TF_Status status);
public static native void TFE_OpReset(TFE_Op op_to_reset,
                                       String op_or_function_name,
                                       String raw_device_name,
                                       TF_Status status);

// Enables only graph collection in RunMetadata on the functions executed from
// this context.
public static native void TFE_ContextEnableGraphCollection(TFE_Context ctx);

// Disables only graph collection in RunMetadata on the functions executed from
// this context.
public static native void TFE_ContextDisableGraphCollection(TFE_Context ctx);
// Targeting ../TFE_MonitoringCounterCell.java



// Atomically increments the value of the cell. The value must be non-negative.
public static native void TFE_MonitoringCounterCellIncrementBy(
    TFE_MonitoringCounterCell cell, @Cast("int64_t") long value);

// Retrieves the current value of the cell.
public static native @Cast("int64_t") long TFE_MonitoringCounterCellValue(
    TFE_MonitoringCounterCell cell);
// Targeting ../TFE_MonitoringCounter0.java


// Returns a new Counter metric object. The caller should manage lifetime of
// the object. Using duplicate metric name will crash the program with fatal
// error.
public static native TFE_MonitoringCounter0 TFE_MonitoringNewCounter0(
    @Cast("const char*") BytePointer name, TF_Status status, @Cast("const char*") BytePointer description);
public static native TFE_MonitoringCounter0 TFE_MonitoringNewCounter0(
    String name, TF_Status status, String description);
// Deletes the Counter object.
public static native void TFE_MonitoringDeleteCounter0(
    TFE_MonitoringCounter0 counter);
// Retrieves the cell from the Counter object. The Counter object will manage
// lifetime of the cell.
public static native TFE_MonitoringCounterCell TFE_MonitoringGetCellCounter0(
    TFE_MonitoringCounter0 counter);
// Targeting ../TFE_MonitoringCounter1.java


public static native TFE_MonitoringCounter1 TFE_MonitoringNewCounter1(
    @Cast("const char*") BytePointer name, TF_Status status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringCounter1 TFE_MonitoringNewCounter1(
    String name, TF_Status status, String description,
    String label1);
public static native void TFE_MonitoringDeleteCounter1(
    TFE_MonitoringCounter1 counter);
public static native TFE_MonitoringCounterCell TFE_MonitoringGetCellCounter1(
    TFE_MonitoringCounter1 counter, @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringCounterCell TFE_MonitoringGetCellCounter1(
    TFE_MonitoringCounter1 counter, String label1);
// Targeting ../TFE_MonitoringCounter2.java


public static native TFE_MonitoringCounter2 TFE_MonitoringNewCounter2(
    @Cast("const char*") BytePointer name, TF_Status status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringCounter2 TFE_MonitoringNewCounter2(
    String name, TF_Status status, String description,
    String label1, String label2);
public static native void TFE_MonitoringDeleteCounter2(
    TFE_MonitoringCounter2 counter);
public static native TFE_MonitoringCounterCell TFE_MonitoringGetCellCounter2(
    TFE_MonitoringCounter2 counter, @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringCounterCell TFE_MonitoringGetCellCounter2(
    TFE_MonitoringCounter2 counter, String label1, String label2);
// Targeting ../TFE_MonitoringIntGaugeCell.java



// Atomically set the value of the cell.
public static native void TFE_MonitoringIntGaugeCellSet(
    TFE_MonitoringIntGaugeCell cell, @Cast("int64_t") long value);

// Retrieves the current value of the cell.
public static native @Cast("int64_t") long TFE_MonitoringIntGaugeCellValue(
    TFE_MonitoringIntGaugeCell cell);
// Targeting ../TFE_MonitoringIntGauge0.java


public static native TFE_MonitoringIntGauge0 TFE_MonitoringNewIntGauge0(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description);
public static native TFE_MonitoringIntGauge0 TFE_MonitoringNewIntGauge0(
    String name, TF_Status out_status, String description);
public static native void TFE_MonitoringDeleteIntGauge0(
    TFE_MonitoringIntGauge0 gauge);
public static native TFE_MonitoringIntGaugeCell TFE_MonitoringGetCellIntGauge0(TFE_MonitoringIntGauge0 gauge);
// Targeting ../TFE_MonitoringIntGauge1.java


public static native TFE_MonitoringIntGauge1 TFE_MonitoringNewIntGauge1(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringIntGauge1 TFE_MonitoringNewIntGauge1(
    String name, TF_Status out_status, String description,
    String label1);
public static native void TFE_MonitoringDeleteIntGauge1(
    TFE_MonitoringIntGauge1 gauge);
public static native TFE_MonitoringIntGaugeCell TFE_MonitoringGetCellIntGauge1(TFE_MonitoringIntGauge1 gauge,
                               @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringIntGaugeCell TFE_MonitoringGetCellIntGauge1(TFE_MonitoringIntGauge1 gauge,
                               String label1);
// Targeting ../TFE_MonitoringIntGauge2.java


public static native TFE_MonitoringIntGauge2 TFE_MonitoringNewIntGauge2(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringIntGauge2 TFE_MonitoringNewIntGauge2(
    String name, TF_Status out_status, String description,
    String label1, String label2);
public static native void TFE_MonitoringDeleteIntGauge2(
    TFE_MonitoringIntGauge2 gauge);
public static native TFE_MonitoringIntGaugeCell TFE_MonitoringGetCellIntGauge2(TFE_MonitoringIntGauge2 gauge,
                               @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringIntGaugeCell TFE_MonitoringGetCellIntGauge2(TFE_MonitoringIntGauge2 gauge,
                               String label1, String label2);
// Targeting ../TFE_MonitoringStringGaugeCell.java


public static native void TFE_MonitoringStringGaugeCellSet(
    TFE_MonitoringStringGaugeCell cell, @Cast("const char*") BytePointer value);
public static native void TFE_MonitoringStringGaugeCellSet(
    TFE_MonitoringStringGaugeCell cell, String value);
// Retrieves the string value and saves it in the buffer.
public static native void TFE_MonitoringStringGaugeCellValue(
    TFE_MonitoringStringGaugeCell cell, TF_Buffer buf);
// Targeting ../TFE_MonitoringStringGauge0.java


public static native TFE_MonitoringStringGauge0 TFE_MonitoringNewStringGauge0(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description);
public static native TFE_MonitoringStringGauge0 TFE_MonitoringNewStringGauge0(
    String name, TF_Status out_status, String description);
public static native void TFE_MonitoringDeleteStringGauge0(
    TFE_MonitoringStringGauge0 gauge);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge0(TFE_MonitoringStringGauge0 gauge);
// Targeting ../TFE_MonitoringStringGauge1.java


public static native TFE_MonitoringStringGauge1 TFE_MonitoringNewStringGauge1(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringStringGauge1 TFE_MonitoringNewStringGauge1(
    String name, TF_Status out_status, String description,
    String label1);
public static native void TFE_MonitoringDeleteStringGauge1(
    TFE_MonitoringStringGauge1 gauge);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge1(TFE_MonitoringStringGauge1 gauge,
                                  @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge1(TFE_MonitoringStringGauge1 gauge,
                                  String label1);
// Targeting ../TFE_MonitoringStringGauge2.java


public static native TFE_MonitoringStringGauge2 TFE_MonitoringNewStringGauge2(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringStringGauge2 TFE_MonitoringNewStringGauge2(
    String name, TF_Status out_status, String description,
    String label1, String label2);
public static native void TFE_MonitoringDeleteStringGauge2(
    TFE_MonitoringStringGauge2 gauge);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge2(TFE_MonitoringStringGauge2 gauge,
                                  @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge2(TFE_MonitoringStringGauge2 gauge,
                                  String label1, String label2);
// Targeting ../TFE_MonitoringStringGauge3.java


public static native TFE_MonitoringStringGauge3 TFE_MonitoringNewStringGauge3(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2, @Cast("const char*") BytePointer label3);
public static native TFE_MonitoringStringGauge3 TFE_MonitoringNewStringGauge3(
    String name, TF_Status out_status, String description,
    String label1, String label2, String label3);
public static native void TFE_MonitoringDeleteStringGauge3(
    TFE_MonitoringStringGauge3 gauge);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge3(TFE_MonitoringStringGauge3 gauge,
                                  @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2,
                                  @Cast("const char*") BytePointer label3);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge3(TFE_MonitoringStringGauge3 gauge,
                                  String label1, String label2,
                                  String label3);
// Targeting ../TFE_MonitoringStringGauge4.java


public static native TFE_MonitoringStringGauge4 TFE_MonitoringNewStringGauge4(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2, @Cast("const char*") BytePointer label3,
    @Cast("const char*") BytePointer label4);
public static native TFE_MonitoringStringGauge4 TFE_MonitoringNewStringGauge4(
    String name, TF_Status out_status, String description,
    String label1, String label2, String label3,
    String label4);
public static native void TFE_MonitoringDeleteStringGauge4(
    TFE_MonitoringStringGauge4 gauge);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge4(TFE_MonitoringStringGauge4 gauge,
                                  @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2,
                                  @Cast("const char*") BytePointer label3, @Cast("const char*") BytePointer label4);
public static native TFE_MonitoringStringGaugeCell TFE_MonitoringGetCellStringGauge4(TFE_MonitoringStringGauge4 gauge,
                                  String label1, String label2,
                                  String label3, String label4);
// Targeting ../TFE_MonitoringBoolGaugeCell.java


public static native void TFE_MonitoringBoolGaugeCellSet(
    TFE_MonitoringBoolGaugeCell cell, @Cast("bool") boolean value);
public static native @Cast("bool") boolean TFE_MonitoringBoolGaugeCellValue(
    TFE_MonitoringBoolGaugeCell cell);
// Targeting ../TFE_MonitoringBoolGauge0.java


public static native TFE_MonitoringBoolGauge0 TFE_MonitoringNewBoolGauge0(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description);
public static native TFE_MonitoringBoolGauge0 TFE_MonitoringNewBoolGauge0(
    String name, TF_Status out_status, String description);
public static native void TFE_MonitoringDeleteBoolGauge0(
    TFE_MonitoringBoolGauge0 gauge);
public static native TFE_MonitoringBoolGaugeCell TFE_MonitoringGetCellBoolGauge0(TFE_MonitoringBoolGauge0 gauge);
// Targeting ../TFE_MonitoringBoolGauge1.java


public static native TFE_MonitoringBoolGauge1 TFE_MonitoringNewBoolGauge1(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringBoolGauge1 TFE_MonitoringNewBoolGauge1(
    String name, TF_Status out_status, String description,
    String label1);
public static native void TFE_MonitoringDeleteBoolGauge1(
    TFE_MonitoringBoolGauge1 gauge);
public static native TFE_MonitoringBoolGaugeCell TFE_MonitoringGetCellBoolGauge1(TFE_MonitoringBoolGauge1 gauge,
                                @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringBoolGaugeCell TFE_MonitoringGetCellBoolGauge1(TFE_MonitoringBoolGauge1 gauge,
                                String label1);
// Targeting ../TFE_MonitoringBoolGauge2.java


public static native TFE_MonitoringBoolGauge2 TFE_MonitoringNewBoolGauge2(
    @Cast("const char*") BytePointer name, TF_Status out_status, @Cast("const char*") BytePointer description,
    @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringBoolGauge2 TFE_MonitoringNewBoolGauge2(
    String name, TF_Status out_status, String description,
    String label1, String label2);
public static native void TFE_MonitoringDeleteBoolGauge2(
    TFE_MonitoringBoolGauge2 gauge);
public static native TFE_MonitoringBoolGaugeCell TFE_MonitoringGetCellBoolGauge2(TFE_MonitoringBoolGauge2 gauge,
                                @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringBoolGaugeCell TFE_MonitoringGetCellBoolGauge2(TFE_MonitoringBoolGauge2 gauge,
                                String label1, String label2);
// Targeting ../TFE_MonitoringSamplerCell.java



// Atomically add the value of the cell.
public static native void TFE_MonitoringSamplerCellAdd(
    TFE_MonitoringSamplerCell cell, double value);

// Retrieves the current value of the cell. The return value is a HistogramProto
// saved in the buffer.
public static native void TFE_MonitoringSamplerCellValue(
    TFE_MonitoringSamplerCell cell, TF_Buffer buf);
// Targeting ../TFE_MonitoringBuckets.java


public static native TFE_MonitoringBuckets TFE_MonitoringNewExponentialBuckets(double scale, double growth_factor,
                                    int bucket_count);
public static native void TFE_MonitoringDeleteBuckets(
    TFE_MonitoringBuckets buckets);
// Targeting ../TFE_MonitoringSampler0.java


public static native TFE_MonitoringSampler0 TFE_MonitoringNewSampler0(
    @Cast("const char*") BytePointer name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    @Cast("const char*") BytePointer description);
public static native TFE_MonitoringSampler0 TFE_MonitoringNewSampler0(
    String name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    String description);
public static native void TFE_MonitoringDeleteSampler0(
    TFE_MonitoringSampler0 sampler);
public static native TFE_MonitoringSamplerCell TFE_MonitoringGetCellSampler0(
    TFE_MonitoringSampler0 sampler);
// Targeting ../TFE_MonitoringSampler1.java


public static native TFE_MonitoringSampler1 TFE_MonitoringNewSampler1(
    @Cast("const char*") BytePointer name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    @Cast("const char*") BytePointer description, @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringSampler1 TFE_MonitoringNewSampler1(
    String name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    String description, String label1);
public static native void TFE_MonitoringDeleteSampler1(
    TFE_MonitoringSampler1 sampler);
public static native TFE_MonitoringSamplerCell TFE_MonitoringGetCellSampler1(
    TFE_MonitoringSampler1 sampler, @Cast("const char*") BytePointer label1);
public static native TFE_MonitoringSamplerCell TFE_MonitoringGetCellSampler1(
    TFE_MonitoringSampler1 sampler, String label1);
// Targeting ../TFE_MonitoringSampler2.java


public static native TFE_MonitoringSampler2 TFE_MonitoringNewSampler2(
    @Cast("const char*") BytePointer name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    @Cast("const char*") BytePointer description, @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringSampler2 TFE_MonitoringNewSampler2(
    String name, TFE_MonitoringBuckets buckets, TF_Status out_status,
    String description, String label1, String label2);
public static native void TFE_MonitoringDeleteSampler2(
    TFE_MonitoringSampler2 sampler);
public static native TFE_MonitoringSamplerCell TFE_MonitoringGetCellSampler2(
    TFE_MonitoringSampler2 sampler, @Cast("const char*") BytePointer label1, @Cast("const char*") BytePointer label2);
public static native TFE_MonitoringSamplerCell TFE_MonitoringGetCellSampler2(
    TFE_MonitoringSampler2 sampler, String label1, String label2);

// Sets whether to use TFRT
public static native void TFE_ContextOptionsSetTfrt(TFE_ContextOptions arg0,
                                                     @Cast("bool") boolean use_tfrt);

// Returns the context_id from the EagerContext which is used by the
// EagerService to maintain consistency between client and worker. The
// context_id is initialized with a dummy value and is later set when the worker
// is initialized (either locally or remotely). The context_id can change during
// the process lifetime although this should cause the worker to be
// reinitialized (e.g. cleared caches) as well.
public static native @Cast("uint64_t") long TFE_GetContextId(TFE_Context ctx);
// Targeting ../TFE_CancellationManager.java


// Targeting ../TFE_CancelCallback.java


public static native TFE_CancellationManager TFE_NewCancellationManager();
public static native @Cast("bool") boolean TFE_CancellationManagerIsCancelled(
    TFE_CancellationManager arg0);
public static native @Cast("bool") boolean TFE_CancellationManagerIsCancelling(
    TFE_CancellationManager arg0);
public static native void TFE_CancellationManagerStartCancel(
    TFE_CancellationManager arg0);
public static native @Cast("TFE_CancellationToken") long TFE_CancellationManagerGetToken(
    TFE_CancellationManager arg0);
public static native @Cast("bool") boolean TFE_CancellationManagerRegisterCallback(
    TFE_CancellationManager arg0, @Cast("TFE_CancellationToken") long token,
    @Const TFE_CancelCallback c_callback, @Cast("const char*") BytePointer callback_name);
public static native @Cast("bool") boolean TFE_CancellationManagerRegisterCallback(
    TFE_CancellationManager arg0, @Cast("TFE_CancellationToken") long token,
    @Const TFE_CancelCallback c_callback, String callback_name);
public static native @Cast("bool") boolean TFE_CancellationManagerDeregisterCallback(
    TFE_CancellationManager arg0, @Cast("TFE_CancellationToken") long token);
public static native @Cast("bool") boolean TFE_CancellationManagerTryDeregisterCallback(
    TFE_CancellationManager arg0, @Cast("TFE_CancellationToken") long token);
public static native void TFE_DeleteCancellationManager(
    TFE_CancellationManager arg0);

// Associates the given `cancellation_manager` with `op`, so that invoking
// `TFE_CancellationManagerStartCancel(cancellation_manager)` will cancel the
// execution of `op`.
public static native void TFE_OpSetCancellationManager(
    TFE_Op op, TFE_CancellationManager cancellation_manager,
    TF_Status status);
// Targeting ../TFE_Executor.java



// Creates a new eager Executor. Nodes in one executor are guaranteed to be
// executed in sequence. Assigning nodes to different executors allows executing
// nodes in parallel.
// in_flight_nodes_limit: when is_async is true, this value controls the
// maximum number of in flight async nodes. Enqueuing of additional async ops
// after the limit is reached blocks until some inflight nodes finishes.
// The effect is bounding the memory held by inflight TensorHandles that are
// referenced by the inflight nodes.
// A recommended value has not been established.
// A value of 0 removes the limit, which is the behavior of TensorFlow 2.11.
// When is_async is false, the value is ignored.
public static native TFE_Executor TFE_NewExecutor(
    @Cast("bool") boolean is_async, @Cast("bool") boolean enable_streaming_enqueue, int in_flight_nodes_limit);

// Deletes the eager Executor without waiting for enqueued nodes. Please call
// TFE_ExecutorWaitForAllPendingNodes before calling this API if you want to
// make sure all nodes are finished.
public static native void TFE_DeleteExecutor(TFE_Executor arg0);

// Returns true if the executor is in async mode.
public static native @Cast("bool") boolean TFE_ExecutorIsAsync(TFE_Executor arg0);

// Causes the calling thread to block till all ops dispatched in this executor
// have been executed. Note that "execution" here refers to kernel execution /
// scheduling of copies, etc. Similar to sync execution, it doesn't guarantee
// that lower level device queues (like GPU streams) have been flushed.
//
// This call may not block for execution of ops enqueued concurrently with this
// call.
public static native void TFE_ExecutorWaitForAllPendingNodes(
    TFE_Executor arg0, TF_Status status);

// When an error happens, any pending operations are discarded, and newly issued
// ops return an error. This call clears the error state and re-enables
// execution of newly issued ops.
//
// Note that outputs of discarded ops remain in a corrupt state and should not
// be used for future calls.
// TODO(agarwal): mark the affected handles and raise errors if they are used.
public static native void TFE_ExecutorClearError(TFE_Executor arg0);

// Sets a custom Executor for the current thread. All nodes created by this
// thread will be added to this Executor. It will override the current executor.
public static native void TFE_ContextSetExecutorForThread(TFE_Context arg0,
                                                           TFE_Executor arg1);

// Returns the Executor for the current thread.
public static native TFE_Executor TFE_ContextGetExecutorForThread(
    TFE_Context arg0);

// -----------------------------------------------------------------------------
// Dynamic cluster API.

// Update an existing context with a new set of servers defined in a ServerDef
// proto. Servers can be added to and removed from the list of remote workers
// in the context. A New set of servers identified by the ServerDef must be up
// when the context is updated.
//
// This API is for experimental usage and may be subject to change.
public static native void TFE_ContextUpdateServerDef(TFE_Context ctx,
                                                      int keep_alive_secs,
                                                      @Const Pointer proto,
                                                      @Cast("size_t") long proto_len,
                                                      TF_Status status);

// This API is for experimental usage and may be subject to change.
public static native void TFE_ContextUpdateServerDefWithTimeout(
    TFE_Context ctx, int keep_alive_secs, @Const Pointer proto, @Cast("size_t") long proto_len,
    @Cast("int64_t") long init_timeout_in_ms, TF_Status status);

// This API is for experimental usage and may be subject to change.
public static native void TFE_ContextSetServerDefWithTimeout(
    TFE_Context ctx, int keep_alive_secs, @Const Pointer proto, @Cast("size_t") long proto_len,
    @Cast("int64_t") long init_timeout_in_ms, TF_Status status);

// Set server def with retries and timeout. This is helpful for fault-tolerant
// initial connection in high-preemption environments, such as
// ParameterServerStrategy training.
// This API is for experimental usage and may be subject to change.
public static native void TFE_ContextSetServerDefWithTimeoutAndRetries(
    TFE_Context ctx, int keep_alive_secs, @Const Pointer proto, @Cast("size_t") long proto_len,
    @Cast("int64_t") long init_timeout_in_ms, int retries, TF_Status status);

// Checks whether a remote worker is alive or not. This will return true even if
// the context doesn't exist on the remote worker.
public static native @Cast("bool") boolean TFE_ContextCheckAlive(TFE_Context ctx,
                                                 @Cast("const char*") BytePointer worker_name,
                                                 TF_Status status);
public static native @Cast("bool") boolean TFE_ContextCheckAlive(TFE_Context ctx,
                                                 String worker_name,
                                                 TF_Status status);

// Sync pending nodes in local executors (including the context default executor
// and thread executors) and streaming requests to remote executors, and get the
// combined status.
public static native void TFE_ContextAsyncWait(TFE_Context ctx,
                                                TF_Status status);

// This function will block till the operation that produces `h` has
// completed. This is only valid on local TFE_TensorHandles. The pointer
// returned will be on the device in which the TFE_TensorHandle resides (so e.g.
// for a GPU tensor this will return a pointer to GPU memory). The pointer is
// only guaranteed to be valid until TFE_DeleteTensorHandle is called on this
// TensorHandle. Only supports POD data types.
public static native Pointer TFE_TensorHandleDevicePointer(TFE_TensorHandle arg0,
                                                          TF_Status arg1);

// This function will block till the operation that produces `h` has
// completed. This is only valid on local TFE_TensorHandles. Returns the size in
// bytes of the memory pointed to by the device pointer returned above.
public static native @Cast("size_t") long TFE_TensorHandleDeviceMemorySize(TFE_TensorHandle arg0,
                                                              TF_Status arg1);

// Creates a new TensorHandle from memory residing in the physical device
// device_name. Takes ownership of the memory, and will call deleter to release
// it after TF no longer needs it or in case of error.
//
// Custom devices must use TFE_NewCustomDeviceTensorHandle instead.
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, @Cast("const char*") BytePointer device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") LongPointer dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, String device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") LongBuffer dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, @Cast("const char*") BytePointer device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") long[] dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, String device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") LongPointer dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, @Cast("const char*") BytePointer device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") LongBuffer dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);
public static native TFE_TensorHandle TFE_NewTensorHandleFromDeviceMemory(
    TFE_Context ctx, String device_name, @Cast("TF_DataType") int arg2, @Cast("const int64_t*") long[] dims,
    int num_dims, Pointer data, @Cast("size_t") long len,
    Deallocator_Pointer_long_Pointer deallocator,
    Pointer deallocator_arg, TF_Status status);

// Retrieves the address space (i.e. job, replia, task) of the local host and
// saves it in the buffer.
public static native void TFE_HostAddressSpace(TFE_Context ctx,
                                                TF_Buffer buf);
// Targeting ../TFE_OpAttrs.java



// Fetch a reference to `op`'s attributes. The returned reference is only valid
// while `op` is alive.
public static native @Const TFE_OpAttrs TFE_OpGetAttrs(@Const TFE_Op op);
// Add attributes in `attrs` to `op`.
//
// Does not overwrite or update existing attributes, but adds new ones.
public static native void TFE_OpAddAttrs(TFE_Op op, @Const TFE_OpAttrs attrs);

// Serialize `attrs` as a tensorflow::NameAttrList protocol buffer (into `buf`),
// containing the op name and a map of its attributes.
public static native void TFE_OpAttrsSerialize(@Const TFE_OpAttrs attrs,
                                                TF_Buffer buf,
                                                TF_Status status);

// Set an op's attribute from a serialized AttrValue protocol buffer.
//
// Analogous to TF_SetAttrValueProto for building graph operations.
public static native void TFE_OpSetAttrValueProto(@Const TFE_Op op,
                                                   @Cast("const char*") BytePointer attr_name,
                                                   @Const Pointer proto,
                                                   @Cast("size_t") long proto_len,
                                                   TF_Status status);
public static native void TFE_OpSetAttrValueProto(@Const TFE_Op op,
                                                   String attr_name,
                                                   @Const Pointer proto,
                                                   @Cast("size_t") long proto_len,
                                                   TF_Status status);

// TODO(b/166642410): It would be nice, for custom devices and for other users,
// to have a non-string representation of devices (TF_Device) extracted from
// tensors/ops/etc. and usable in APIs like OpSetDevice/ResetOp/etc.

public static final int TFE_CUSTOM_DEVICE_VERSION = 4;
// Targeting ../TFE_CustomDevice.java



// Registers a custom device for use with eager execution.
//
// Eager operations may be placed on this device, e.g.  `with
// tf.device("CUSTOM"):` from Python if `device_name` for this call is
// "/job:localhost/replica:0/task:0/device:CUSTOM:0".
//
// The custom device defines copy operations for moving TensorHandles on and
// off, and an execution operation for named operations. Often execution will
// simply wrap op execution on one or more physical devices.
//
// device_info is an opaque caller-defined type stored with the custom device
// which is passed to the functions referenced in the TFE_CustomDevice struct
// `device` (execute, delete_device, etc.). It can for example contain the
// names of wrapped devices.
//
// There are currently no graph semantics implemented for registered custom
// devices, so executing tf.functions which contain operations placed on the
// custom devices will fail.
//
// `device_name` must not name an existing physical or custom device. It must
// follow the format:
//
//    /job:<name>/replica:<replica>/task:<task>/device:<type>:<device_num>
//
// If the device is successfully registered, `status` is set to TF_OK. Otherwise
// the device is not usable. In case of a bad status, `device.delete_device` is
// still called on `device_info` (i.e. the caller does not retain ownership).
//
// This API is highly experimental, and in particular is expected to change when
// it starts supporting operations with attributes and when tf.function support
// is added.
public static native void TFE_RegisterCustomDevice(TFE_Context ctx,
                                                    @ByVal TFE_CustomDevice device,
                                                    @Cast("const char*") BytePointer device_name,
                                                    Pointer device_info,
                                                    TF_Status status);
public static native void TFE_RegisterCustomDevice(TFE_Context ctx,
                                                    @ByVal TFE_CustomDevice device,
                                                    String device_name,
                                                    Pointer device_info,
                                                    TF_Status status);

// Returns whether `device_name` maps to a registered custom device.
public static native @Cast("bool") boolean TFE_IsCustomDevice(TFE_Context ctx,
                                              @Cast("const char*") BytePointer device_name);
public static native @Cast("bool") boolean TFE_IsCustomDevice(TFE_Context ctx,
                                              String device_name);
// Targeting ../TFE_CustomDeviceTensorHandle.java



// Creates a new TensorHandle from memory residing in a custom device. Takes
// ownership of the memory pointed to by `tensor_handle_data`, and calls
// `methods.deallocator` to release it after TF no longer needs it or in case of
// an error.
//
// This call is similar to `TFE_NewTensorHandleFromDeviceMemory`, but supports
// custom devices instead of physical devices and does not require blocking
// waiting for exact shapes.
public static native TFE_TensorHandle TFE_NewCustomDeviceTensorHandle(
    TFE_Context arg0, @Cast("const char*") BytePointer device_name, @Cast("TF_DataType") int arg2, Pointer data,
    @ByVal TFE_CustomDeviceTensorHandle methods, TF_Status status);
public static native TFE_TensorHandle TFE_NewCustomDeviceTensorHandle(
    TFE_Context arg0, String device_name, @Cast("TF_DataType") int arg2, Pointer data,
    @ByVal TFE_CustomDeviceTensorHandle methods, TF_Status status);

public static native void TFE_ContextGetFunctionDef(TFE_Context ctx,
                                                     @Cast("const char*") BytePointer function_name,
                                                     TF_Buffer buf,
                                                     TF_Status status);
public static native void TFE_ContextGetFunctionDef(TFE_Context ctx,
                                                     String function_name,
                                                     TF_Buffer buf,
                                                     TF_Status status);

// Get GraphDebugInfo containing stack traces mapping to node names
public static native void TFE_ContextGetGraphDebugInfo(
    TFE_Context ctx, @Cast("const char*") BytePointer function_name, TF_Buffer buf,
    TF_Status status);
public static native void TFE_ContextGetGraphDebugInfo(
    TFE_Context ctx, String function_name, TF_Buffer buf,
    TF_Status status);

// Extracts a TF_Function from the context.
// Must call TF_DeleteFunction on the returned value.
public static native TF_Function TFE_ContextGetFunction(TFE_Context ctx,
                                                          @Cast("const char*") BytePointer name,
                                                          TF_Status status);
public static native TF_Function TFE_ContextGetFunction(TFE_Context ctx,
                                                          String name,
                                                          TF_Status status);

// Allocate and return a new Tensor on the host.
//
// The caller must set the Tensor values by writing them to the pointer returned
// by TF_TensorData with length TF_TensorByteSize.
public static native TF_Tensor TFE_AllocateHostTensor(TFE_Context ctx,
                                                        @Cast("TF_DataType") int dtype,
                                                        @Cast("const int64_t*") LongPointer dims,
                                                        int num_dims,
                                                        TF_Status status);
public static native TF_Tensor TFE_AllocateHostTensor(TFE_Context ctx,
                                                        @Cast("TF_DataType") int dtype,
                                                        @Cast("const int64_t*") LongBuffer dims,
                                                        int num_dims,
                                                        TF_Status status);
public static native TF_Tensor TFE_AllocateHostTensor(TFE_Context ctx,
                                                        @Cast("TF_DataType") int dtype,
                                                        @Cast("const int64_t*") long[] dims,
                                                        int num_dims,
                                                        TF_Status status);

// Given a Tensor, wrap it with a TensorHandle
//
// Similar to TFE_NewTensorHandle, but includes a pointer to the TFE_Context.
// The context should be identical to that of the Tensor.
public static native TFE_TensorHandle TFE_NewTensorHandleFromTensor(
    TFE_Context ctx, TF_Tensor t, TF_Status status);

// Create a packed TensorHandle with the given list of TensorHandles.
// If `handles` are on the same device, assign the same device to the packed
// handle; if `handles` are on different deivces, assign a CompositeDevice to
// it.
public static native TFE_TensorHandle TFE_CreatePackedTensorHandle(
    TFE_Context ctx, @Cast("TFE_TensorHandle**") PointerPointer handles, IntPointer num_handles,
    TF_Status status);
public static native TFE_TensorHandle TFE_CreatePackedTensorHandle(
    TFE_Context ctx, @ByPtrPtr TFE_TensorHandle handles, IntPointer num_handles,
    TF_Status status);
public static native TFE_TensorHandle TFE_CreatePackedTensorHandle(
    TFE_Context ctx, @ByPtrPtr TFE_TensorHandle handles, IntBuffer num_handles,
    TF_Status status);
public static native TFE_TensorHandle TFE_CreatePackedTensorHandle(
    TFE_Context ctx, @ByPtrPtr TFE_TensorHandle handles, int[] num_handles,
    TF_Status status);

// Configure soft device placement policy for the eager executor. Note this
// policy is applied to any subsequent op executions.
public static native void TFE_ContextSetSoftDevicePlacement(TFE_Context ctx,
                                                      @Cast("unsigned char") byte enable,
                                                      TF_Status status);

// Configure device placement policy logging for the eager executor. Note this
// policy is applied to any subsequent op executions.
public static native void TFE_ContextSetLogDevicePlacement(TFE_Context ctx,
                                                     @Cast("unsigned char") byte enable,
                                                     TF_Status status);

// Enables running eager ops as function.
public static native void TFE_ContextSetRunEagerOpAsFunction(TFE_Context ctx,
                                                       @Cast("unsigned char") byte enable,
                                                       TF_Status status);

// Enables rewrite jit_compile functions.
public static native void TFE_ContextSetJitCompileRewrite(TFE_Context ctx,
                                                    @Cast("unsigned char") byte enable,
                                                    TF_Status status);

// Returns the device type of the operation that produced `h`.
public static native @Cast("const char*") BytePointer TFE_TensorHandleDeviceType(
    TFE_TensorHandle h, TF_Status status);

// Returns the device ID of the operation that produced `h`.
public static native int TFE_TensorHandleDeviceID(TFE_TensorHandle h,
                                                   TF_Status status);

// Returns the status for the tensor handle. In TFRT, a tensor handle can carry
// error info if error happens. If so, the status will be set with the error
// info. If not, status will be set as OK.
public static native void TFE_TensorHandleGetStatus(TFE_TensorHandle h,
                                                     TF_Status status);

// Get a comma-separated list of op names executed in graph functions dispatched
// to `ctx`. This feature is currently only enabled for TFRT debug builds, for
// performance and simplicity reasons.
public static native void TFE_GetExecutedOpNames(TFE_Context ctx,
                                                  TF_Buffer buf,
                                                  TF_Status status);

// Set logical devices to the context's device manager.
// If logical devices are already configured at context initialization
// through TFE_ContextOptions, this method should not be called.
public static native void TFE_SetLogicalCpuDevices(TFE_Context ctx,
                                                    int num_cpus,
                                                    @Cast("const char*") BytePointer prefix,
                                                    TF_Status status);
public static native void TFE_SetLogicalCpuDevices(TFE_Context ctx,
                                                    int num_cpus,
                                                    String prefix,
                                                    TF_Status status);

// Set configuration key and value using coordination service.
// If coordination service is enabled, the key-value will be stored on the
// leader and become accessible to all workers in the cluster.
// Currently, a config key can only be set with one value, and subsequently
// setting the same key will lead to errors.
//
// Note that the key-values are only expected to be used for cluster
// configuration data, and should not be used for storing a large amount of data
// or being accessed very frequently.
public static native void TFE_InsertConfigKeyValue(TFE_Context ctx,
                                                    @Cast("const char*") BytePointer key,
                                                    @Cast("const char*") BytePointer value,
                                                    TF_Status status);
public static native void TFE_InsertConfigKeyValue(TFE_Context ctx,
                                                    String key,
                                                    String value,
                                                    TF_Status status);

// Get configuration key and value using coordination service.
// The config key must be set before getting its value. Getting value of
// non-existing config keys will result in errors.
// If `timeout_in_ms=0`, this call will block until the key-value is set or the
// worker shuts down.
public static native void TFE_GetConfigKeyValue(TFE_Context ctx,
                                                 @Cast("const char*") BytePointer key,
                                                 @Cast("int64_t") long timeout_in_ms,
                                                 TF_Buffer value_buf,
                                                 TF_Status status);
public static native void TFE_GetConfigKeyValue(TFE_Context ctx,
                                                 String key,
                                                 @Cast("int64_t") long timeout_in_ms,
                                                 TF_Buffer value_buf,
                                                 TF_Status status);

// Delete configuration key-value. If `key` is a directory, recursively clean up
// all key-values under the path specified by `key`.
public static native void TFE_DeleteConfigKeyValue(TFE_Context ctx,
                                                    @Cast("const char*") BytePointer key,
                                                    TF_Status status);
public static native void TFE_DeleteConfigKeyValue(TFE_Context ctx,
                                                    String key,
                                                    TF_Status status);

// Report error (specified by error_code and error_message) to other tasks in
// the cluster.
public static native void TFE_ReportErrorToCluster(TFE_Context ctx,
                                                    int error_code,
                                                    @Cast("const char*") BytePointer error_message,
                                                    TF_Status status);
public static native void TFE_ReportErrorToCluster(TFE_Context ctx,
                                                    int error_code,
                                                    String error_message,
                                                    TF_Status status);

// Get task states from the Coordination Service.
public static native void TFE_GetTaskStates(TFE_Context ctx,
                                             @Const @ByRef TF_Buffer tasks,
                                             Pointer states, TF_Status status);

public static native void TFE_WaitAtBarrier(TFE_Context ctx,
                                             @Cast("const char*") BytePointer barrier_id,
                                             @Cast("int64_t") long barrier_timeout_in_ms,
                                             TF_Status status);
public static native void TFE_WaitAtBarrier(TFE_Context ctx,
                                             String barrier_id,
                                             @Cast("int64_t") long barrier_timeout_in_ms,
                                             TF_Status status);

public static native void TFE_InitializeLocalOnlyContext(TFE_Context ctx,
                                                          int keep_alive_secs,
                                                          @Const Pointer proto,
                                                          @Cast("size_t") long proto_len,
                                                          TF_Status status);

// #ifdef __cplusplus /* end extern "C" */
// #endif

// #endif  // TENSORFLOW_C_EAGER_C_API_EXPERIMENTAL_H_


// Parsed from tfj_graph.h

/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_JAVA_GRAPH_H_
// #define TENSORFLOW_JAVA_GRAPH_H_

// #include "tensorflow/c/c_api.h"
// Targeting ../TFJ_GraphId.java



/** Returns the unique identifier of the graph {@code g} */
public static native TFJ_GraphId TFJ_GetGraphId(@Const TF_Graph g);

/** Remove an operation from the name map of the graph {@code g}, so that it cannot be reversely looked up by name.
 *  This is particularly useful for preventing custom gradient operations to pollute the graph namespace. */
public static native void TFJ_UnmapOperationName(TF_Graph g, TF_Operation operation);

// #include "tfj_graph_impl.cc" // include CC file in its header to compile it with JavaCPP

// #endif  // TENSORFLOW_JAVA_GRAPH_H_


// Parsed from tfj_scope.h

/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_JAVA_SCOPE_H_
// #define TENSORFLOW_JAVA_SCOPE_H_

// #include <string>

// #include "tensorflow/c/c_api.h"
// Targeting ../TFJ_Scope.java



// The following functions are for users making graphs. They return brand new
// scopes, or scopes derived from an existing scope object.

/** Return a new scope.
 *  This creates a new graph and all operations constructed in this graph
 *  should use the returned object as the "root" scope. */
public static native @ByVal TFJ_Scope TFJ_NewRootScope();

/** Return a new scope. Ops created with this scope will have
 *  {@code name/child_scope_name} as the prefix. The actual name will be unique
 *  in the current scope. All other properties are inherited from the current
 *  scope. If {@code child_scope_name} is empty, the {@code /} is elided. */
public static native @ByVal TFJ_Scope TFJ_NewSubScope(@Const TFJ_Scope scope, @Cast("const char*") BytePointer child_scope_name);
public static native @ByVal TFJ_Scope TFJ_NewSubScope(@Const TFJ_Scope scope, String child_scope_name);

/** Return a new scope. All ops created within the returned scope will have as
 *  control dependencies the union of operations in the control_deps vector
 *  and the control dependencies of the current scope. */
public static native @ByVal TFJ_Scope TFJ_NewScopeWithControlDependencies(@Const TFJ_Scope scope, TF_Operation control_deps, int control_deps_size);

/** Return a new scope. All ops created within the returned scope will have
 *  the device field set to 'device'. */
public static native @ByVal TFJ_Scope TFJ_NewScopeWithDevice(@Const TFJ_Scope scope, @Cast("const char*") BytePointer device);
public static native @ByVal TFJ_Scope TFJ_NewScopeWithDevice(@Const TFJ_Scope scope, String device);

/** Return a unique name, using default_name if an op name has not been specified.
 *  Note: returns C++ std string to prevent buffer to be freed up before consuming the characters */
public static native @StdString BytePointer TFJ_GetUniqueNameForOp(@Const TFJ_Scope scope, @Cast("const char*") BytePointer default_name);
public static native @StdString String TFJ_GetUniqueNameForOp(@Const TFJ_Scope scope, String default_name);

// #include "tfj_scope_impl.cc" // include CC file in its header to compile it with JavaCPP

// #endif  // TENSORFLOW_JAVA_SCOPE_H_


// Parsed from tfj_gradients.h

/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

// #ifndef TENSORFLOW_JAVA_GRADIENTS_H_
// #define TENSORFLOW_JAVA_GRADIENTS_H_

// #include "tfj_scope.h"

///
///
// #include "tensorflow/c/c_api.h"
// Targeting ../TFJ_GradFuncAdapter.java



/** Returns true if a gradient function has already be registered for operations of type {@code op_type} */

///
public static native @Cast("bool") boolean TFJ_HasGradient(@Cast("const char*") BytePointer op_type);
public static native @Cast("bool") boolean TFJ_HasGradient(String op_type);

/** Registers a gradient function for operations of type {@code op_type}.
 * 
 *  Returns true if the function has been registered successfully, false if operation failed or if gradient function is already registered to that {@code op_type}. */
public static native @Cast("bool") boolean TFJ_RegisterCustomGradient(@Cast("const char*") BytePointer op_type, TFJ_GradFuncAdapter custom_gradient_adapter);
public static native @Cast("bool") boolean TFJ_RegisterCustomGradient(String op_type, TFJ_GradFuncAdapter custom_gradient_adapter);

// #include "tfj_gradients_impl.cc" // include CC file in its header to compile it with JavaCPP

// #endif  // TENSORFLOW_JAVA_GRADIENTS_H_


}
